// Generated by GenerateBuiltinMetaData
unit ADOTypedTableStorage;
interface
uses
  System.Data,
  System.Collections,
  System.Reflection;

type
  TDataTypesRow = class;
  TDataTypesTable = class;
  TCatalogsRow = class;
  TCatalogsTable = class;
  TSchemasRow = class;
  TSchemasTable = class;
  TTablesRow = class;
  TTablesTable = class;
  TViewsRow = class;
  TViewsTable = class;
  TSynonymsRow = class;
  TSynonymsTable = class;
  TColumnsRow = class;
  TColumnsTable = class;
  TColumnConstraintsRow = class;
  TColumnConstraintsTable = class;
  TIndexesRow = class;
  TIndexesTable = class;
  TIndexColumnsRow = class;
  TIndexColumnsTable = class;
  TForeignKeysRow = class;
  TForeignKeysTable = class;
  TForeignKeyColumnsRow = class;
  TForeignKeyColumnsTable = class;
  TProceduresRow = class;
  TProceduresTable = class;
  TProcedureSourcesRow = class;
  TProcedureSourcesTable = class;
  TProcedureParametersRow = class;
  TProcedureParametersTable = class;
  TPackagesRow = class;
  TPackagesTable = class;
  TPackageProceduresRow = class;
  TPackageProceduresTable = class;
  TPackageProcedureParametersRow = class;
  TPackageProcedureParametersTable = class;
  TPackageSourcesRow = class;
  TPackageSourcesTable = class;
  TUsersRow = class;
  TUsersTable = class;
  TRolesRow = class;
  TRolesTable = class;
  TReservedWordsRow = class;
  TReservedWordsTable = class;

  TDataTypesTable = class(DataTable)
  private
    FColumnTypeName: DataColumn;
    FColumnDbxDataType: DataColumn;
    FColumnColumnSize: DataColumn;
    FColumnCreateFormat: DataColumn;
    FColumnCreateParameters: DataColumn;
    FColumnDataType: DataColumn;
    FColumnIsAutoIncrementable: DataColumn;
    FColumnIsBestMatch: DataColumn;
    FColumnIsCaseSensitive: DataColumn;
    FColumnIsFixedLength: DataColumn;
    FColumnIsFixedPrecisionScale: DataColumn;
    FColumnIsLong: DataColumn;
    FColumnIsNullable: DataColumn;
    FColumnIsSearchable: DataColumn;
    FColumnIsSearchableWithLike: DataColumn;
    FColumnIsUnsigned: DataColumn;
    FColumnMaximumScale: DataColumn;
    FColumnMinimumScale: DataColumn;
    FColumnIsConcurrencyType: DataColumn;
    FColumnMaximumVersion: DataColumn;
    FColumnMinimumVersion: DataColumn;
    FColumnIsLiteralSupported: DataColumn;
    FColumnLiteralPrefix: DataColumn;
    FColumnLiteralSuffix: DataColumn;
    FColumnIsUnicode: DataColumn;
    FColumnProviderDbType: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewDataTypesRow: TDataTypesRow;
    procedure RemoveDataTypesRow(Row: TDataTypesRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddDataTypesRow(Row: TDataTypesRow); overload;
    procedure AddDataTypesRow(TypeName: WideString; DbxDataType: Integer; ColumnSize: Int64; CreateFormat: WideString; CreateParameters: WideString; DataType: WideString; IsAutoIncrementable: Boolean; IsBestMatch: Boolean; IsCaseSensitive: Boolean; IsFixedLength: Boolean; IsFixedPrecisionScale: Boolean; IsLong: Boolean; IsNullable: Boolean; IsSearchable: Boolean; IsSearchableWithLike: Boolean; IsUnsigned: Boolean; MaximumScale: SmallInt; MinimumScale: SmallInt; IsConcurrencyType: Boolean; MaximumVersion: WideString; MinimumVersion: WideString; IsLiteralSupported: Boolean; LiteralPrefix: WideString; LiteralSuffix: WideString; IsUnicode: Boolean; ProviderDbType: Integer); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TDataTypesRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property TypeNameColumn: DataColumn read FColumnTypeName;
    property DbxDataTypeColumn: DataColumn read FColumnDbxDataType;
    property ColumnSizeColumn: DataColumn read FColumnColumnSize;
    property CreateFormatColumn: DataColumn read FColumnCreateFormat;
    property CreateParametersColumn: DataColumn read FColumnCreateParameters;
    property DataTypeColumn: DataColumn read FColumnDataType;
    property IsAutoIncrementableColumn: DataColumn read FColumnIsAutoIncrementable;
    property IsBestMatchColumn: DataColumn read FColumnIsBestMatch;
    property IsCaseSensitiveColumn: DataColumn read FColumnIsCaseSensitive;
    property IsFixedLengthColumn: DataColumn read FColumnIsFixedLength;
    property IsFixedPrecisionScaleColumn: DataColumn read FColumnIsFixedPrecisionScale;
    property IsLongColumn: DataColumn read FColumnIsLong;
    property IsNullableColumn: DataColumn read FColumnIsNullable;
    property IsSearchableColumn: DataColumn read FColumnIsSearchable;
    property IsSearchableWithLikeColumn: DataColumn read FColumnIsSearchableWithLike;
    property IsUnsignedColumn: DataColumn read FColumnIsUnsigned;
    property MaximumScaleColumn: DataColumn read FColumnMaximumScale;
    property MinimumScaleColumn: DataColumn read FColumnMinimumScale;
    property IsConcurrencyTypeColumn: DataColumn read FColumnIsConcurrencyType;
    property MaximumVersionColumn: DataColumn read FColumnMaximumVersion;
    property MinimumVersionColumn: DataColumn read FColumnMinimumVersion;
    property IsLiteralSupportedColumn: DataColumn read FColumnIsLiteralSupported;
    property LiteralPrefixColumn: DataColumn read FColumnLiteralPrefix;
    property LiteralSuffixColumn: DataColumn read FColumnLiteralSuffix;
    property IsUnicodeColumn: DataColumn read FColumnIsUnicode;
    property ProviderDbTypeColumn: DataColumn read FColumnProviderDbType;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TDataTypesRow read GetItem; default;
  end;

  TDataTypesRow = class(DataRow)
  private
    FTableDataTypes: TDataTypesTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsTypeNameNull: Boolean;
    procedure SetTypeNameNull;
    function IsDbxDataTypeNull: Boolean;
    procedure SetDbxDataTypeNull;
    function IsColumnSizeNull: Boolean;
    procedure SetColumnSizeNull;
    function IsCreateFormatNull: Boolean;
    procedure SetCreateFormatNull;
    function IsCreateParametersNull: Boolean;
    procedure SetCreateParametersNull;
    function IsDataTypeNull: Boolean;
    procedure SetDataTypeNull;
    function IsIsAutoIncrementableNull: Boolean;
    procedure SetIsAutoIncrementableNull;
    function IsIsBestMatchNull: Boolean;
    procedure SetIsBestMatchNull;
    function IsIsCaseSensitiveNull: Boolean;
    procedure SetIsCaseSensitiveNull;
    function IsIsFixedLengthNull: Boolean;
    procedure SetIsFixedLengthNull;
    function IsIsFixedPrecisionScaleNull: Boolean;
    procedure SetIsFixedPrecisionScaleNull;
    function IsIsLongNull: Boolean;
    procedure SetIsLongNull;
    function IsIsNullableNull: Boolean;
    procedure SetIsNullableNull;
    function IsIsSearchableNull: Boolean;
    procedure SetIsSearchableNull;
    function IsIsSearchableWithLikeNull: Boolean;
    procedure SetIsSearchableWithLikeNull;
    function IsIsUnsignedNull: Boolean;
    procedure SetIsUnsignedNull;
    function IsMaximumScaleNull: Boolean;
    procedure SetMaximumScaleNull;
    function IsMinimumScaleNull: Boolean;
    procedure SetMinimumScaleNull;
    function IsIsConcurrencyTypeNull: Boolean;
    procedure SetIsConcurrencyTypeNull;
    function IsMaximumVersionNull: Boolean;
    procedure SetMaximumVersionNull;
    function IsMinimumVersionNull: Boolean;
    procedure SetMinimumVersionNull;
    function IsIsLiteralSupportedNull: Boolean;
    procedure SetIsLiteralSupportedNull;
    function IsLiteralPrefixNull: Boolean;
    procedure SetLiteralPrefixNull;
    function IsLiteralSuffixNull: Boolean;
    procedure SetLiteralSuffixNull;
    function IsIsUnicodeNull: Boolean;
    procedure SetIsUnicodeNull;
    function IsProviderDbTypeNull: Boolean;
    procedure SetProviderDbTypeNull;
  protected
    function GetTypeName: WideString;
    procedure SetTypeName(NewValue: WideString);
    function GetDbxDataType: Integer;
    procedure SetDbxDataType(NewValue: Integer);
    function GetColumnSize: Int64;
    procedure SetColumnSize(NewValue: Int64);
    function GetCreateFormat: WideString;
    procedure SetCreateFormat(NewValue: WideString);
    function GetCreateParameters: WideString;
    procedure SetCreateParameters(NewValue: WideString);
    function GetDataType: WideString;
    procedure SetDataType(NewValue: WideString);
    function GetIsAutoIncrementable: Boolean;
    procedure SetIsAutoIncrementable(NewValue: Boolean);
    function GetIsBestMatch: Boolean;
    procedure SetIsBestMatch(NewValue: Boolean);
    function GetIsCaseSensitive: Boolean;
    procedure SetIsCaseSensitive(NewValue: Boolean);
    function GetIsFixedLength: Boolean;
    procedure SetIsFixedLength(NewValue: Boolean);
    function GetIsFixedPrecisionScale: Boolean;
    procedure SetIsFixedPrecisionScale(NewValue: Boolean);
    function GetIsLong: Boolean;
    procedure SetIsLong(NewValue: Boolean);
    function GetIsNullable: Boolean;
    procedure SetIsNullable(NewValue: Boolean);
    function GetIsSearchable: Boolean;
    procedure SetIsSearchable(NewValue: Boolean);
    function GetIsSearchableWithLike: Boolean;
    procedure SetIsSearchableWithLike(NewValue: Boolean);
    function GetIsUnsigned: Boolean;
    procedure SetIsUnsigned(NewValue: Boolean);
    function GetMaximumScale: SmallInt;
    procedure SetMaximumScale(NewValue: SmallInt);
    function GetMinimumScale: SmallInt;
    procedure SetMinimumScale(NewValue: SmallInt);
    function GetIsConcurrencyType: Boolean;
    procedure SetIsConcurrencyType(NewValue: Boolean);
    function GetMaximumVersion: WideString;
    procedure SetMaximumVersion(NewValue: WideString);
    function GetMinimumVersion: WideString;
    procedure SetMinimumVersion(NewValue: WideString);
    function GetIsLiteralSupported: Boolean;
    procedure SetIsLiteralSupported(NewValue: Boolean);
    function GetLiteralPrefix: WideString;
    procedure SetLiteralPrefix(NewValue: WideString);
    function GetLiteralSuffix: WideString;
    procedure SetLiteralSuffix(NewValue: WideString);
    function GetIsUnicode: Boolean;
    procedure SetIsUnicode(NewValue: Boolean);
    function GetProviderDbType: Integer;
    procedure SetProviderDbType(NewValue: Integer);
  public
    property TypeName: WideString read GetTypeName write SetTypeName;
    property DbxDataType: Integer read GetDbxDataType write SetDbxDataType;
    property ColumnSize: Int64 read GetColumnSize write SetColumnSize;
    property CreateFormat: WideString read GetCreateFormat write SetCreateFormat;
    property CreateParameters: WideString read GetCreateParameters write SetCreateParameters;
    property DataType: WideString read GetDataType write SetDataType;
    property IsAutoIncrementable: Boolean read GetIsAutoIncrementable write SetIsAutoIncrementable;
    property IsBestMatch: Boolean read GetIsBestMatch write SetIsBestMatch;
    property IsCaseSensitive: Boolean read GetIsCaseSensitive write SetIsCaseSensitive;
    property IsFixedLength: Boolean read GetIsFixedLength write SetIsFixedLength;
    property IsFixedPrecisionScale: Boolean read GetIsFixedPrecisionScale write SetIsFixedPrecisionScale;
    property IsLong: Boolean read GetIsLong write SetIsLong;
    property IsNullable: Boolean read GetIsNullable write SetIsNullable;
    property IsSearchable: Boolean read GetIsSearchable write SetIsSearchable;
    property IsSearchableWithLike: Boolean read GetIsSearchableWithLike write SetIsSearchableWithLike;
    property IsUnsigned: Boolean read GetIsUnsigned write SetIsUnsigned;
    property MaximumScale: SmallInt read GetMaximumScale write SetMaximumScale;
    property MinimumScale: SmallInt read GetMinimumScale write SetMinimumScale;
    property IsConcurrencyType: Boolean read GetIsConcurrencyType write SetIsConcurrencyType;
    property MaximumVersion: WideString read GetMaximumVersion write SetMaximumVersion;
    property MinimumVersion: WideString read GetMinimumVersion write SetMinimumVersion;
    property IsLiteralSupported: Boolean read GetIsLiteralSupported write SetIsLiteralSupported;
    property LiteralPrefix: WideString read GetLiteralPrefix write SetLiteralPrefix;
    property LiteralSuffix: WideString read GetLiteralSuffix write SetLiteralSuffix;
    property IsUnicode: Boolean read GetIsUnicode write SetIsUnicode;
    property ProviderDbType: Integer read GetProviderDbType write SetProviderDbType;
  end;

  TCatalogsTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewCatalogsRow: TCatalogsRow;
    procedure RemoveCatalogsRow(Row: TCatalogsRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddCatalogsRow(Row: TCatalogsRow); overload;
    procedure AddCatalogsRow(CatalogName: WideString); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TCatalogsRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TCatalogsRow read GetItem; default;
  end;

  TCatalogsRow = class(DataRow)
  private
    FTableCatalogs: TCatalogsTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
  end;

  TSchemasTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewSchemasRow: TSchemasRow;
    procedure RemoveSchemasRow(Row: TSchemasRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddSchemasRow(Row: TSchemasRow); overload;
    procedure AddSchemasRow(CatalogName: WideString; SchemaName: WideString); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TSchemasRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TSchemasRow read GetItem; default;
  end;

  TSchemasRow = class(DataRow)
  private
    FTableSchemas: TSchemasTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
  end;

  TTablesTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
    FColumnTableName: DataColumn;
    FColumnTableType: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewTablesRow: TTablesRow;
    procedure RemoveTablesRow(Row: TTablesRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddTablesRow(Row: TTablesRow); overload;
    procedure AddTablesRow(CatalogName: WideString; SchemaName: WideString; TableName: WideString; TableType: WideString); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TTablesRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property TableNameColumn: DataColumn read FColumnTableName;
    property TableTypeColumn: DataColumn read FColumnTableType;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TTablesRow read GetItem; default;
  end;

  TTablesRow = class(DataRow)
  private
    FTableTables: TTablesTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
    function IsTableNameNull: Boolean;
    procedure SetTableNameNull;
    function IsTableTypeNull: Boolean;
    procedure SetTableTypeNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
    function GetTableName: WideString;
    procedure SetTableName(NewValue: WideString);
    function GetTableType: WideString;
    procedure SetTableType(NewValue: WideString);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
    property TableName: WideString read GetTableName write SetTableName;
    property TableType: WideString read GetTableType write SetTableType;
  end;

  TViewsTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
    FColumnViewName: DataColumn;
    FColumnDefinition: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewViewsRow: TViewsRow;
    procedure RemoveViewsRow(Row: TViewsRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddViewsRow(Row: TViewsRow); overload;
    procedure AddViewsRow(CatalogName: WideString; SchemaName: WideString; ViewName: WideString; Definition: WideString); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TViewsRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property ViewNameColumn: DataColumn read FColumnViewName;
    property DefinitionColumn: DataColumn read FColumnDefinition;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TViewsRow read GetItem; default;
  end;

  TViewsRow = class(DataRow)
  private
    FTableViews: TViewsTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
    function IsViewNameNull: Boolean;
    procedure SetViewNameNull;
    function IsDefinitionNull: Boolean;
    procedure SetDefinitionNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
    function GetViewName: WideString;
    procedure SetViewName(NewValue: WideString);
    function GetDefinition: WideString;
    procedure SetDefinition(NewValue: WideString);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
    property ViewName: WideString read GetViewName write SetViewName;
    property Definition: WideString read GetDefinition write SetDefinition;
  end;

  TSynonymsTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
    FColumnSynonymName: DataColumn;
    FColumnTableCatalogName: DataColumn;
    FColumnTableSchemaName: DataColumn;
    FColumnTableName: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewSynonymsRow: TSynonymsRow;
    procedure RemoveSynonymsRow(Row: TSynonymsRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddSynonymsRow(Row: TSynonymsRow); overload;
    procedure AddSynonymsRow(CatalogName: WideString; SchemaName: WideString; SynonymName: WideString; TableCatalogName: WideString; TableSchemaName: WideString; TableName: WideString); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TSynonymsRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property SynonymNameColumn: DataColumn read FColumnSynonymName;
    property TableCatalogNameColumn: DataColumn read FColumnTableCatalogName;
    property TableSchemaNameColumn: DataColumn read FColumnTableSchemaName;
    property TableNameColumn: DataColumn read FColumnTableName;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TSynonymsRow read GetItem; default;
  end;

  TSynonymsRow = class(DataRow)
  private
    FTableSynonyms: TSynonymsTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
    function IsSynonymNameNull: Boolean;
    procedure SetSynonymNameNull;
    function IsTableCatalogNameNull: Boolean;
    procedure SetTableCatalogNameNull;
    function IsTableSchemaNameNull: Boolean;
    procedure SetTableSchemaNameNull;
    function IsTableNameNull: Boolean;
    procedure SetTableNameNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
    function GetSynonymName: WideString;
    procedure SetSynonymName(NewValue: WideString);
    function GetTableCatalogName: WideString;
    procedure SetTableCatalogName(NewValue: WideString);
    function GetTableSchemaName: WideString;
    procedure SetTableSchemaName(NewValue: WideString);
    function GetTableName: WideString;
    procedure SetTableName(NewValue: WideString);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
    property SynonymName: WideString read GetSynonymName write SetSynonymName;
    property TableCatalogName: WideString read GetTableCatalogName write SetTableCatalogName;
    property TableSchemaName: WideString read GetTableSchemaName write SetTableSchemaName;
    property TableName: WideString read GetTableName write SetTableName;
  end;

  TColumnsTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
    FColumnTableName: DataColumn;
    FColumnColumnName: DataColumn;
    FColumnTypeName: DataColumn;
    FColumnPrecision: DataColumn;
    FColumnScale: DataColumn;
    FColumnOrdinal: DataColumn;
    FColumnDefaultValue: DataColumn;
    FColumnIsNullable: DataColumn;
    FColumnIsAutoIncrement: DataColumn;
    FColumnMaxInline: DataColumn;
    FColumnDbxDataType: DataColumn;
    FColumnIsFixedLength: DataColumn;
    FColumnIsUnicode: DataColumn;
    FColumnIsLong: DataColumn;
    FColumnIsUnsigned: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewColumnsRow: TColumnsRow;
    procedure RemoveColumnsRow(Row: TColumnsRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddColumnsRow(Row: TColumnsRow); overload;
    procedure AddColumnsRow(CatalogName: WideString; SchemaName: WideString; TableName: WideString; ColumnName: WideString; TypeName: WideString; Precision: Integer; Scale: Integer; Ordinal: Integer; DefaultValue: WideString; IsNullable: Boolean; IsAutoIncrement: Boolean; MaxInline: Integer; DbxDataType: Integer; IsFixedLength: Boolean; IsUnicode: Boolean; IsLong: Boolean; IsUnsigned: Boolean); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TColumnsRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property TableNameColumn: DataColumn read FColumnTableName;
    property ColumnNameColumn: DataColumn read FColumnColumnName;
    property TypeNameColumn: DataColumn read FColumnTypeName;
    property PrecisionColumn: DataColumn read FColumnPrecision;
    property ScaleColumn: DataColumn read FColumnScale;
    property OrdinalColumn: DataColumn read FColumnOrdinal;
    property DefaultValueColumn: DataColumn read FColumnDefaultValue;
    property IsNullableColumn: DataColumn read FColumnIsNullable;
    property IsAutoIncrementColumn: DataColumn read FColumnIsAutoIncrement;
    property MaxInlineColumn: DataColumn read FColumnMaxInline;
    property DbxDataTypeColumn: DataColumn read FColumnDbxDataType;
    property IsFixedLengthColumn: DataColumn read FColumnIsFixedLength;
    property IsUnicodeColumn: DataColumn read FColumnIsUnicode;
    property IsLongColumn: DataColumn read FColumnIsLong;
    property IsUnsignedColumn: DataColumn read FColumnIsUnsigned;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TColumnsRow read GetItem; default;
  end;

  TColumnsRow = class(DataRow)
  private
    FTableColumns: TColumnsTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
    function IsTableNameNull: Boolean;
    procedure SetTableNameNull;
    function IsColumnNameNull: Boolean;
    procedure SetColumnNameNull;
    function IsTypeNameNull: Boolean;
    procedure SetTypeNameNull;
    function IsPrecisionNull: Boolean;
    procedure SetPrecisionNull;
    function IsScaleNull: Boolean;
    procedure SetScaleNull;
    function IsOrdinalNull: Boolean;
    procedure SetOrdinalNull;
    function IsDefaultValueNull: Boolean;
    procedure SetDefaultValueNull;
    function IsIsNullableNull: Boolean;
    procedure SetIsNullableNull;
    function IsIsAutoIncrementNull: Boolean;
    procedure SetIsAutoIncrementNull;
    function IsMaxInlineNull: Boolean;
    procedure SetMaxInlineNull;
    function IsDbxDataTypeNull: Boolean;
    procedure SetDbxDataTypeNull;
    function IsIsFixedLengthNull: Boolean;
    procedure SetIsFixedLengthNull;
    function IsIsUnicodeNull: Boolean;
    procedure SetIsUnicodeNull;
    function IsIsLongNull: Boolean;
    procedure SetIsLongNull;
    function IsIsUnsignedNull: Boolean;
    procedure SetIsUnsignedNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
    function GetTableName: WideString;
    procedure SetTableName(NewValue: WideString);
    function GetColumnName: WideString;
    procedure SetColumnName(NewValue: WideString);
    function GetTypeName: WideString;
    procedure SetTypeName(NewValue: WideString);
    function GetPrecision: Integer;
    procedure SetPrecision(NewValue: Integer);
    function GetScale: Integer;
    procedure SetScale(NewValue: Integer);
    function GetOrdinal: Integer;
    procedure SetOrdinal(NewValue: Integer);
    function GetDefaultValue: WideString;
    procedure SetDefaultValue(NewValue: WideString);
    function GetIsNullable: Boolean;
    procedure SetIsNullable(NewValue: Boolean);
    function GetIsAutoIncrement: Boolean;
    procedure SetIsAutoIncrement(NewValue: Boolean);
    function GetMaxInline: Integer;
    procedure SetMaxInline(NewValue: Integer);
    function GetDbxDataType: Integer;
    procedure SetDbxDataType(NewValue: Integer);
    function GetIsFixedLength: Boolean;
    procedure SetIsFixedLength(NewValue: Boolean);
    function GetIsUnicode: Boolean;
    procedure SetIsUnicode(NewValue: Boolean);
    function GetIsLong: Boolean;
    procedure SetIsLong(NewValue: Boolean);
    function GetIsUnsigned: Boolean;
    procedure SetIsUnsigned(NewValue: Boolean);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
    property TableName: WideString read GetTableName write SetTableName;
    property ColumnName: WideString read GetColumnName write SetColumnName;
    property TypeName: WideString read GetTypeName write SetTypeName;
    property Precision: Integer read GetPrecision write SetPrecision;
    property Scale: Integer read GetScale write SetScale;
    property Ordinal: Integer read GetOrdinal write SetOrdinal;
    property DefaultValue: WideString read GetDefaultValue write SetDefaultValue;
    property IsNullable: Boolean read GetIsNullable write SetIsNullable;
    property IsAutoIncrement: Boolean read GetIsAutoIncrement write SetIsAutoIncrement;
    property MaxInline: Integer read GetMaxInline write SetMaxInline;
    property DbxDataType: Integer read GetDbxDataType write SetDbxDataType;
    property IsFixedLength: Boolean read GetIsFixedLength write SetIsFixedLength;
    property IsUnicode: Boolean read GetIsUnicode write SetIsUnicode;
    property IsLong: Boolean read GetIsLong write SetIsLong;
    property IsUnsigned: Boolean read GetIsUnsigned write SetIsUnsigned;
  end;

  TColumnConstraintsTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
    FColumnTableName: DataColumn;
    FColumnConstraintName: DataColumn;
    FColumnColumnName: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewColumnConstraintsRow: TColumnConstraintsRow;
    procedure RemoveColumnConstraintsRow(Row: TColumnConstraintsRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddColumnConstraintsRow(Row: TColumnConstraintsRow); overload;
    procedure AddColumnConstraintsRow(CatalogName: WideString; SchemaName: WideString; TableName: WideString; ConstraintName: WideString; ColumnName: WideString); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TColumnConstraintsRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property TableNameColumn: DataColumn read FColumnTableName;
    property ConstraintNameColumn: DataColumn read FColumnConstraintName;
    property ColumnNameColumn: DataColumn read FColumnColumnName;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TColumnConstraintsRow read GetItem; default;
  end;

  TColumnConstraintsRow = class(DataRow)
  private
    FTableColumnConstraints: TColumnConstraintsTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
    function IsTableNameNull: Boolean;
    procedure SetTableNameNull;
    function IsConstraintNameNull: Boolean;
    procedure SetConstraintNameNull;
    function IsColumnNameNull: Boolean;
    procedure SetColumnNameNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
    function GetTableName: WideString;
    procedure SetTableName(NewValue: WideString);
    function GetConstraintName: WideString;
    procedure SetConstraintName(NewValue: WideString);
    function GetColumnName: WideString;
    procedure SetColumnName(NewValue: WideString);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
    property TableName: WideString read GetTableName write SetTableName;
    property ConstraintName: WideString read GetConstraintName write SetConstraintName;
    property ColumnName: WideString read GetColumnName write SetColumnName;
  end;

  TIndexesTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
    FColumnTableName: DataColumn;
    FColumnIndexName: DataColumn;
    FColumnConstraintName: DataColumn;
    FColumnIsPrimary: DataColumn;
    FColumnIsUnique: DataColumn;
    FColumnIsAscending: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewIndexesRow: TIndexesRow;
    procedure RemoveIndexesRow(Row: TIndexesRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddIndexesRow(Row: TIndexesRow); overload;
    procedure AddIndexesRow(CatalogName: WideString; SchemaName: WideString; TableName: WideString; IndexName: WideString; ConstraintName: WideString; IsPrimary: Boolean; IsUnique: Boolean; IsAscending: Boolean); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TIndexesRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property TableNameColumn: DataColumn read FColumnTableName;
    property IndexNameColumn: DataColumn read FColumnIndexName;
    property ConstraintNameColumn: DataColumn read FColumnConstraintName;
    property IsPrimaryColumn: DataColumn read FColumnIsPrimary;
    property IsUniqueColumn: DataColumn read FColumnIsUnique;
    property IsAscendingColumn: DataColumn read FColumnIsAscending;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TIndexesRow read GetItem; default;
  end;

  TIndexesRow = class(DataRow)
  private
    FTableIndexes: TIndexesTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
    function IsTableNameNull: Boolean;
    procedure SetTableNameNull;
    function IsIndexNameNull: Boolean;
    procedure SetIndexNameNull;
    function IsConstraintNameNull: Boolean;
    procedure SetConstraintNameNull;
    function IsIsPrimaryNull: Boolean;
    procedure SetIsPrimaryNull;
    function IsIsUniqueNull: Boolean;
    procedure SetIsUniqueNull;
    function IsIsAscendingNull: Boolean;
    procedure SetIsAscendingNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
    function GetTableName: WideString;
    procedure SetTableName(NewValue: WideString);
    function GetIndexName: WideString;
    procedure SetIndexName(NewValue: WideString);
    function GetConstraintName: WideString;
    procedure SetConstraintName(NewValue: WideString);
    function GetIsPrimary: Boolean;
    procedure SetIsPrimary(NewValue: Boolean);
    function GetIsUnique: Boolean;
    procedure SetIsUnique(NewValue: Boolean);
    function GetIsAscending: Boolean;
    procedure SetIsAscending(NewValue: Boolean);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
    property TableName: WideString read GetTableName write SetTableName;
    property IndexName: WideString read GetIndexName write SetIndexName;
    property ConstraintName: WideString read GetConstraintName write SetConstraintName;
    property IsPrimary: Boolean read GetIsPrimary write SetIsPrimary;
    property IsUnique: Boolean read GetIsUnique write SetIsUnique;
    property IsAscending: Boolean read GetIsAscending write SetIsAscending;
  end;

  TIndexColumnsTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
    FColumnTableName: DataColumn;
    FColumnIndexName: DataColumn;
    FColumnColumnName: DataColumn;
    FColumnOrdinal: DataColumn;
    FColumnIsAscending: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewIndexColumnsRow: TIndexColumnsRow;
    procedure RemoveIndexColumnsRow(Row: TIndexColumnsRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddIndexColumnsRow(Row: TIndexColumnsRow); overload;
    procedure AddIndexColumnsRow(CatalogName: WideString; SchemaName: WideString; TableName: WideString; IndexName: WideString; ColumnName: WideString; Ordinal: Integer; IsAscending: Boolean); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TIndexColumnsRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property TableNameColumn: DataColumn read FColumnTableName;
    property IndexNameColumn: DataColumn read FColumnIndexName;
    property ColumnNameColumn: DataColumn read FColumnColumnName;
    property OrdinalColumn: DataColumn read FColumnOrdinal;
    property IsAscendingColumn: DataColumn read FColumnIsAscending;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TIndexColumnsRow read GetItem; default;
  end;

  TIndexColumnsRow = class(DataRow)
  private
    FTableIndexColumns: TIndexColumnsTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
    function IsTableNameNull: Boolean;
    procedure SetTableNameNull;
    function IsIndexNameNull: Boolean;
    procedure SetIndexNameNull;
    function IsColumnNameNull: Boolean;
    procedure SetColumnNameNull;
    function IsOrdinalNull: Boolean;
    procedure SetOrdinalNull;
    function IsIsAscendingNull: Boolean;
    procedure SetIsAscendingNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
    function GetTableName: WideString;
    procedure SetTableName(NewValue: WideString);
    function GetIndexName: WideString;
    procedure SetIndexName(NewValue: WideString);
    function GetColumnName: WideString;
    procedure SetColumnName(NewValue: WideString);
    function GetOrdinal: Integer;
    procedure SetOrdinal(NewValue: Integer);
    function GetIsAscending: Boolean;
    procedure SetIsAscending(NewValue: Boolean);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
    property TableName: WideString read GetTableName write SetTableName;
    property IndexName: WideString read GetIndexName write SetIndexName;
    property ColumnName: WideString read GetColumnName write SetColumnName;
    property Ordinal: Integer read GetOrdinal write SetOrdinal;
    property IsAscending: Boolean read GetIsAscending write SetIsAscending;
  end;

  TForeignKeysTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
    FColumnTableName: DataColumn;
    FColumnForeignKeyName: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewForeignKeysRow: TForeignKeysRow;
    procedure RemoveForeignKeysRow(Row: TForeignKeysRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddForeignKeysRow(Row: TForeignKeysRow); overload;
    procedure AddForeignKeysRow(CatalogName: WideString; SchemaName: WideString; TableName: WideString; ForeignKeyName: WideString); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TForeignKeysRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property TableNameColumn: DataColumn read FColumnTableName;
    property ForeignKeyNameColumn: DataColumn read FColumnForeignKeyName;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TForeignKeysRow read GetItem; default;
  end;

  TForeignKeysRow = class(DataRow)
  private
    FTableForeignKeys: TForeignKeysTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
    function IsTableNameNull: Boolean;
    procedure SetTableNameNull;
    function IsForeignKeyNameNull: Boolean;
    procedure SetForeignKeyNameNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
    function GetTableName: WideString;
    procedure SetTableName(NewValue: WideString);
    function GetForeignKeyName: WideString;
    procedure SetForeignKeyName(NewValue: WideString);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
    property TableName: WideString read GetTableName write SetTableName;
    property ForeignKeyName: WideString read GetForeignKeyName write SetForeignKeyName;
  end;

  TForeignKeyColumnsTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
    FColumnTableName: DataColumn;
    FColumnForeignKeyName: DataColumn;
    FColumnColumnName: DataColumn;
    FColumnPrimaryCatalogName: DataColumn;
    FColumnPrimarySchemaName: DataColumn;
    FColumnPrimaryTableName: DataColumn;
    FColumnPrimaryKeyName: DataColumn;
    FColumnPrimaryColumnName: DataColumn;
    FColumnOrdinal: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewForeignKeyColumnsRow: TForeignKeyColumnsRow;
    procedure RemoveForeignKeyColumnsRow(Row: TForeignKeyColumnsRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddForeignKeyColumnsRow(Row: TForeignKeyColumnsRow); overload;
    procedure AddForeignKeyColumnsRow(CatalogName: WideString; SchemaName: WideString; TableName: WideString; ForeignKeyName: WideString; ColumnName: WideString; PrimaryCatalogName: WideString; PrimarySchemaName: WideString; PrimaryTableName: WideString; PrimaryKeyName: WideString; PrimaryColumnName: WideString; Ordinal: Integer); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TForeignKeyColumnsRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property TableNameColumn: DataColumn read FColumnTableName;
    property ForeignKeyNameColumn: DataColumn read FColumnForeignKeyName;
    property ColumnNameColumn: DataColumn read FColumnColumnName;
    property PrimaryCatalogNameColumn: DataColumn read FColumnPrimaryCatalogName;
    property PrimarySchemaNameColumn: DataColumn read FColumnPrimarySchemaName;
    property PrimaryTableNameColumn: DataColumn read FColumnPrimaryTableName;
    property PrimaryKeyNameColumn: DataColumn read FColumnPrimaryKeyName;
    property PrimaryColumnNameColumn: DataColumn read FColumnPrimaryColumnName;
    property OrdinalColumn: DataColumn read FColumnOrdinal;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TForeignKeyColumnsRow read GetItem; default;
  end;

  TForeignKeyColumnsRow = class(DataRow)
  private
    FTableForeignKeyColumns: TForeignKeyColumnsTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
    function IsTableNameNull: Boolean;
    procedure SetTableNameNull;
    function IsForeignKeyNameNull: Boolean;
    procedure SetForeignKeyNameNull;
    function IsColumnNameNull: Boolean;
    procedure SetColumnNameNull;
    function IsPrimaryCatalogNameNull: Boolean;
    procedure SetPrimaryCatalogNameNull;
    function IsPrimarySchemaNameNull: Boolean;
    procedure SetPrimarySchemaNameNull;
    function IsPrimaryTableNameNull: Boolean;
    procedure SetPrimaryTableNameNull;
    function IsPrimaryKeyNameNull: Boolean;
    procedure SetPrimaryKeyNameNull;
    function IsPrimaryColumnNameNull: Boolean;
    procedure SetPrimaryColumnNameNull;
    function IsOrdinalNull: Boolean;
    procedure SetOrdinalNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
    function GetTableName: WideString;
    procedure SetTableName(NewValue: WideString);
    function GetForeignKeyName: WideString;
    procedure SetForeignKeyName(NewValue: WideString);
    function GetColumnName: WideString;
    procedure SetColumnName(NewValue: WideString);
    function GetPrimaryCatalogName: WideString;
    procedure SetPrimaryCatalogName(NewValue: WideString);
    function GetPrimarySchemaName: WideString;
    procedure SetPrimarySchemaName(NewValue: WideString);
    function GetPrimaryTableName: WideString;
    procedure SetPrimaryTableName(NewValue: WideString);
    function GetPrimaryKeyName: WideString;
    procedure SetPrimaryKeyName(NewValue: WideString);
    function GetPrimaryColumnName: WideString;
    procedure SetPrimaryColumnName(NewValue: WideString);
    function GetOrdinal: Integer;
    procedure SetOrdinal(NewValue: Integer);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
    property TableName: WideString read GetTableName write SetTableName;
    property ForeignKeyName: WideString read GetForeignKeyName write SetForeignKeyName;
    property ColumnName: WideString read GetColumnName write SetColumnName;
    property PrimaryCatalogName: WideString read GetPrimaryCatalogName write SetPrimaryCatalogName;
    property PrimarySchemaName: WideString read GetPrimarySchemaName write SetPrimarySchemaName;
    property PrimaryTableName: WideString read GetPrimaryTableName write SetPrimaryTableName;
    property PrimaryKeyName: WideString read GetPrimaryKeyName write SetPrimaryKeyName;
    property PrimaryColumnName: WideString read GetPrimaryColumnName write SetPrimaryColumnName;
    property Ordinal: Integer read GetOrdinal write SetOrdinal;
  end;

  TProceduresTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
    FColumnProcedureName: DataColumn;
    FColumnProcedureType: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewProceduresRow: TProceduresRow;
    procedure RemoveProceduresRow(Row: TProceduresRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddProceduresRow(Row: TProceduresRow); overload;
    procedure AddProceduresRow(CatalogName: WideString; SchemaName: WideString; ProcedureName: WideString; ProcedureType: WideString); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TProceduresRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property ProcedureNameColumn: DataColumn read FColumnProcedureName;
    property ProcedureTypeColumn: DataColumn read FColumnProcedureType;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TProceduresRow read GetItem; default;
  end;

  TProceduresRow = class(DataRow)
  private
    FTableProcedures: TProceduresTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
    function IsProcedureNameNull: Boolean;
    procedure SetProcedureNameNull;
    function IsProcedureTypeNull: Boolean;
    procedure SetProcedureTypeNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
    function GetProcedureName: WideString;
    procedure SetProcedureName(NewValue: WideString);
    function GetProcedureType: WideString;
    procedure SetProcedureType(NewValue: WideString);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
    property ProcedureName: WideString read GetProcedureName write SetProcedureName;
    property ProcedureType: WideString read GetProcedureType write SetProcedureType;
  end;

  TProcedureSourcesTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
    FColumnProcedureName: DataColumn;
    FColumnProcedureType: DataColumn;
    FColumnDefinition: DataColumn;
    FColumnExternalDefinition: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewProcedureSourcesRow: TProcedureSourcesRow;
    procedure RemoveProcedureSourcesRow(Row: TProcedureSourcesRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddProcedureSourcesRow(Row: TProcedureSourcesRow); overload;
    procedure AddProcedureSourcesRow(CatalogName: WideString; SchemaName: WideString; ProcedureName: WideString; ProcedureType: WideString; Definition: WideString; ExternalDefinition: WideString); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TProcedureSourcesRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property ProcedureNameColumn: DataColumn read FColumnProcedureName;
    property ProcedureTypeColumn: DataColumn read FColumnProcedureType;
    property DefinitionColumn: DataColumn read FColumnDefinition;
    property ExternalDefinitionColumn: DataColumn read FColumnExternalDefinition;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TProcedureSourcesRow read GetItem; default;
  end;

  TProcedureSourcesRow = class(DataRow)
  private
    FTableProcedureSources: TProcedureSourcesTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
    function IsProcedureNameNull: Boolean;
    procedure SetProcedureNameNull;
    function IsProcedureTypeNull: Boolean;
    procedure SetProcedureTypeNull;
    function IsDefinitionNull: Boolean;
    procedure SetDefinitionNull;
    function IsExternalDefinitionNull: Boolean;
    procedure SetExternalDefinitionNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
    function GetProcedureName: WideString;
    procedure SetProcedureName(NewValue: WideString);
    function GetProcedureType: WideString;
    procedure SetProcedureType(NewValue: WideString);
    function GetDefinition: WideString;
    procedure SetDefinition(NewValue: WideString);
    function GetExternalDefinition: WideString;
    procedure SetExternalDefinition(NewValue: WideString);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
    property ProcedureName: WideString read GetProcedureName write SetProcedureName;
    property ProcedureType: WideString read GetProcedureType write SetProcedureType;
    property Definition: WideString read GetDefinition write SetDefinition;
    property ExternalDefinition: WideString read GetExternalDefinition write SetExternalDefinition;
  end;

  TProcedureParametersTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
    FColumnProcedureName: DataColumn;
    FColumnParameterName: DataColumn;
    FColumnParameterMode: DataColumn;
    FColumnTypeName: DataColumn;
    FColumnPrecision: DataColumn;
    FColumnScale: DataColumn;
    FColumnOrdinal: DataColumn;
    FColumnIsNullable: DataColumn;
    FColumnDbxDataType: DataColumn;
    FColumnIsFixedLength: DataColumn;
    FColumnIsUnicode: DataColumn;
    FColumnIsLong: DataColumn;
    FColumnIsUnsigned: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewProcedureParametersRow: TProcedureParametersRow;
    procedure RemoveProcedureParametersRow(Row: TProcedureParametersRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddProcedureParametersRow(Row: TProcedureParametersRow); overload;
    procedure AddProcedureParametersRow(CatalogName: WideString; SchemaName: WideString; ProcedureName: WideString; ParameterName: WideString; ParameterMode: WideString; TypeName: WideString; Precision: Integer; Scale: Integer; Ordinal: Integer; IsNullable: Boolean; DbxDataType: Integer; IsFixedLength: Boolean; IsUnicode: Boolean; IsLong: Boolean; IsUnsigned: Boolean); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TProcedureParametersRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property ProcedureNameColumn: DataColumn read FColumnProcedureName;
    property ParameterNameColumn: DataColumn read FColumnParameterName;
    property ParameterModeColumn: DataColumn read FColumnParameterMode;
    property TypeNameColumn: DataColumn read FColumnTypeName;
    property PrecisionColumn: DataColumn read FColumnPrecision;
    property ScaleColumn: DataColumn read FColumnScale;
    property OrdinalColumn: DataColumn read FColumnOrdinal;
    property IsNullableColumn: DataColumn read FColumnIsNullable;
    property DbxDataTypeColumn: DataColumn read FColumnDbxDataType;
    property IsFixedLengthColumn: DataColumn read FColumnIsFixedLength;
    property IsUnicodeColumn: DataColumn read FColumnIsUnicode;
    property IsLongColumn: DataColumn read FColumnIsLong;
    property IsUnsignedColumn: DataColumn read FColumnIsUnsigned;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TProcedureParametersRow read GetItem; default;
  end;

  TProcedureParametersRow = class(DataRow)
  private
    FTableProcedureParameters: TProcedureParametersTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
    function IsProcedureNameNull: Boolean;
    procedure SetProcedureNameNull;
    function IsParameterNameNull: Boolean;
    procedure SetParameterNameNull;
    function IsParameterModeNull: Boolean;
    procedure SetParameterModeNull;
    function IsTypeNameNull: Boolean;
    procedure SetTypeNameNull;
    function IsPrecisionNull: Boolean;
    procedure SetPrecisionNull;
    function IsScaleNull: Boolean;
    procedure SetScaleNull;
    function IsOrdinalNull: Boolean;
    procedure SetOrdinalNull;
    function IsIsNullableNull: Boolean;
    procedure SetIsNullableNull;
    function IsDbxDataTypeNull: Boolean;
    procedure SetDbxDataTypeNull;
    function IsIsFixedLengthNull: Boolean;
    procedure SetIsFixedLengthNull;
    function IsIsUnicodeNull: Boolean;
    procedure SetIsUnicodeNull;
    function IsIsLongNull: Boolean;
    procedure SetIsLongNull;
    function IsIsUnsignedNull: Boolean;
    procedure SetIsUnsignedNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
    function GetProcedureName: WideString;
    procedure SetProcedureName(NewValue: WideString);
    function GetParameterName: WideString;
    procedure SetParameterName(NewValue: WideString);
    function GetParameterMode: WideString;
    procedure SetParameterMode(NewValue: WideString);
    function GetTypeName: WideString;
    procedure SetTypeName(NewValue: WideString);
    function GetPrecision: Integer;
    procedure SetPrecision(NewValue: Integer);
    function GetScale: Integer;
    procedure SetScale(NewValue: Integer);
    function GetOrdinal: Integer;
    procedure SetOrdinal(NewValue: Integer);
    function GetIsNullable: Boolean;
    procedure SetIsNullable(NewValue: Boolean);
    function GetDbxDataType: Integer;
    procedure SetDbxDataType(NewValue: Integer);
    function GetIsFixedLength: Boolean;
    procedure SetIsFixedLength(NewValue: Boolean);
    function GetIsUnicode: Boolean;
    procedure SetIsUnicode(NewValue: Boolean);
    function GetIsLong: Boolean;
    procedure SetIsLong(NewValue: Boolean);
    function GetIsUnsigned: Boolean;
    procedure SetIsUnsigned(NewValue: Boolean);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
    property ProcedureName: WideString read GetProcedureName write SetProcedureName;
    property ParameterName: WideString read GetParameterName write SetParameterName;
    property ParameterMode: WideString read GetParameterMode write SetParameterMode;
    property TypeName: WideString read GetTypeName write SetTypeName;
    property Precision: Integer read GetPrecision write SetPrecision;
    property Scale: Integer read GetScale write SetScale;
    property Ordinal: Integer read GetOrdinal write SetOrdinal;
    property IsNullable: Boolean read GetIsNullable write SetIsNullable;
    property DbxDataType: Integer read GetDbxDataType write SetDbxDataType;
    property IsFixedLength: Boolean read GetIsFixedLength write SetIsFixedLength;
    property IsUnicode: Boolean read GetIsUnicode write SetIsUnicode;
    property IsLong: Boolean read GetIsLong write SetIsLong;
    property IsUnsigned: Boolean read GetIsUnsigned write SetIsUnsigned;
  end;

  TPackagesTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
    FColumnPackageName: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewPackagesRow: TPackagesRow;
    procedure RemovePackagesRow(Row: TPackagesRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddPackagesRow(Row: TPackagesRow); overload;
    procedure AddPackagesRow(CatalogName: WideString; SchemaName: WideString; PackageName: WideString); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TPackagesRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property PackageNameColumn: DataColumn read FColumnPackageName;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TPackagesRow read GetItem; default;
  end;

  TPackagesRow = class(DataRow)
  private
    FTablePackages: TPackagesTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
    function IsPackageNameNull: Boolean;
    procedure SetPackageNameNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
    function GetPackageName: WideString;
    procedure SetPackageName(NewValue: WideString);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
    property PackageName: WideString read GetPackageName write SetPackageName;
  end;

  TPackageProceduresTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
    FColumnPackageName: DataColumn;
    FColumnProcedureName: DataColumn;
    FColumnProcedureType: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewPackageProceduresRow: TPackageProceduresRow;
    procedure RemovePackageProceduresRow(Row: TPackageProceduresRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddPackageProceduresRow(Row: TPackageProceduresRow); overload;
    procedure AddPackageProceduresRow(CatalogName: WideString; SchemaName: WideString; PackageName: WideString; ProcedureName: WideString; ProcedureType: WideString); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TPackageProceduresRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property PackageNameColumn: DataColumn read FColumnPackageName;
    property ProcedureNameColumn: DataColumn read FColumnProcedureName;
    property ProcedureTypeColumn: DataColumn read FColumnProcedureType;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TPackageProceduresRow read GetItem; default;
  end;

  TPackageProceduresRow = class(DataRow)
  private
    FTablePackageProcedures: TPackageProceduresTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
    function IsPackageNameNull: Boolean;
    procedure SetPackageNameNull;
    function IsProcedureNameNull: Boolean;
    procedure SetProcedureNameNull;
    function IsProcedureTypeNull: Boolean;
    procedure SetProcedureTypeNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
    function GetPackageName: WideString;
    procedure SetPackageName(NewValue: WideString);
    function GetProcedureName: WideString;
    procedure SetProcedureName(NewValue: WideString);
    function GetProcedureType: WideString;
    procedure SetProcedureType(NewValue: WideString);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
    property PackageName: WideString read GetPackageName write SetPackageName;
    property ProcedureName: WideString read GetProcedureName write SetProcedureName;
    property ProcedureType: WideString read GetProcedureType write SetProcedureType;
  end;

  TPackageProcedureParametersTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
    FColumnPackageName: DataColumn;
    FColumnProcedureName: DataColumn;
    FColumnParameterName: DataColumn;
    FColumnParameterMode: DataColumn;
    FColumnTypeName: DataColumn;
    FColumnPrecision: DataColumn;
    FColumnScale: DataColumn;
    FColumnOrdinal: DataColumn;
    FColumnIsNullable: DataColumn;
    FColumnDbxDataType: DataColumn;
    FColumnIsFixedLength: DataColumn;
    FColumnIsUnicode: DataColumn;
    FColumnIsLong: DataColumn;
    FColumnIsUnsigned: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewPackageProcedureParametersRow: TPackageProcedureParametersRow;
    procedure RemovePackageProcedureParametersRow(Row: TPackageProcedureParametersRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddPackageProcedureParametersRow(Row: TPackageProcedureParametersRow); overload;
    procedure AddPackageProcedureParametersRow(CatalogName: WideString; SchemaName: WideString; PackageName: WideString; ProcedureName: WideString; ParameterName: WideString; ParameterMode: WideString; TypeName: WideString; Precision: Integer; Scale: Integer; Ordinal: Integer; IsNullable: Boolean; DbxDataType: Integer; IsFixedLength: Boolean; IsUnicode: Boolean; IsLong: Boolean; IsUnsigned: Boolean); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TPackageProcedureParametersRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property PackageNameColumn: DataColumn read FColumnPackageName;
    property ProcedureNameColumn: DataColumn read FColumnProcedureName;
    property ParameterNameColumn: DataColumn read FColumnParameterName;
    property ParameterModeColumn: DataColumn read FColumnParameterMode;
    property TypeNameColumn: DataColumn read FColumnTypeName;
    property PrecisionColumn: DataColumn read FColumnPrecision;
    property ScaleColumn: DataColumn read FColumnScale;
    property OrdinalColumn: DataColumn read FColumnOrdinal;
    property IsNullableColumn: DataColumn read FColumnIsNullable;
    property DbxDataTypeColumn: DataColumn read FColumnDbxDataType;
    property IsFixedLengthColumn: DataColumn read FColumnIsFixedLength;
    property IsUnicodeColumn: DataColumn read FColumnIsUnicode;
    property IsLongColumn: DataColumn read FColumnIsLong;
    property IsUnsignedColumn: DataColumn read FColumnIsUnsigned;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TPackageProcedureParametersRow read GetItem; default;
  end;

  TPackageProcedureParametersRow = class(DataRow)
  private
    FTablePackageProcedureParameters: TPackageProcedureParametersTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
    function IsPackageNameNull: Boolean;
    procedure SetPackageNameNull;
    function IsProcedureNameNull: Boolean;
    procedure SetProcedureNameNull;
    function IsParameterNameNull: Boolean;
    procedure SetParameterNameNull;
    function IsParameterModeNull: Boolean;
    procedure SetParameterModeNull;
    function IsTypeNameNull: Boolean;
    procedure SetTypeNameNull;
    function IsPrecisionNull: Boolean;
    procedure SetPrecisionNull;
    function IsScaleNull: Boolean;
    procedure SetScaleNull;
    function IsOrdinalNull: Boolean;
    procedure SetOrdinalNull;
    function IsIsNullableNull: Boolean;
    procedure SetIsNullableNull;
    function IsDbxDataTypeNull: Boolean;
    procedure SetDbxDataTypeNull;
    function IsIsFixedLengthNull: Boolean;
    procedure SetIsFixedLengthNull;
    function IsIsUnicodeNull: Boolean;
    procedure SetIsUnicodeNull;
    function IsIsLongNull: Boolean;
    procedure SetIsLongNull;
    function IsIsUnsignedNull: Boolean;
    procedure SetIsUnsignedNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
    function GetPackageName: WideString;
    procedure SetPackageName(NewValue: WideString);
    function GetProcedureName: WideString;
    procedure SetProcedureName(NewValue: WideString);
    function GetParameterName: WideString;
    procedure SetParameterName(NewValue: WideString);
    function GetParameterMode: WideString;
    procedure SetParameterMode(NewValue: WideString);
    function GetTypeName: WideString;
    procedure SetTypeName(NewValue: WideString);
    function GetPrecision: Integer;
    procedure SetPrecision(NewValue: Integer);
    function GetScale: Integer;
    procedure SetScale(NewValue: Integer);
    function GetOrdinal: Integer;
    procedure SetOrdinal(NewValue: Integer);
    function GetIsNullable: Boolean;
    procedure SetIsNullable(NewValue: Boolean);
    function GetDbxDataType: Integer;
    procedure SetDbxDataType(NewValue: Integer);
    function GetIsFixedLength: Boolean;
    procedure SetIsFixedLength(NewValue: Boolean);
    function GetIsUnicode: Boolean;
    procedure SetIsUnicode(NewValue: Boolean);
    function GetIsLong: Boolean;
    procedure SetIsLong(NewValue: Boolean);
    function GetIsUnsigned: Boolean;
    procedure SetIsUnsigned(NewValue: Boolean);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
    property PackageName: WideString read GetPackageName write SetPackageName;
    property ProcedureName: WideString read GetProcedureName write SetProcedureName;
    property ParameterName: WideString read GetParameterName write SetParameterName;
    property ParameterMode: WideString read GetParameterMode write SetParameterMode;
    property TypeName: WideString read GetTypeName write SetTypeName;
    property Precision: Integer read GetPrecision write SetPrecision;
    property Scale: Integer read GetScale write SetScale;
    property Ordinal: Integer read GetOrdinal write SetOrdinal;
    property IsNullable: Boolean read GetIsNullable write SetIsNullable;
    property DbxDataType: Integer read GetDbxDataType write SetDbxDataType;
    property IsFixedLength: Boolean read GetIsFixedLength write SetIsFixedLength;
    property IsUnicode: Boolean read GetIsUnicode write SetIsUnicode;
    property IsLong: Boolean read GetIsLong write SetIsLong;
    property IsUnsigned: Boolean read GetIsUnsigned write SetIsUnsigned;
  end;

  TPackageSourcesTable = class(DataTable)
  private
    FColumnCatalogName: DataColumn;
    FColumnSchemaName: DataColumn;
    FColumnPackageName: DataColumn;
    FColumnDefinition: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewPackageSourcesRow: TPackageSourcesRow;
    procedure RemovePackageSourcesRow(Row: TPackageSourcesRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddPackageSourcesRow(Row: TPackageSourcesRow); overload;
    procedure AddPackageSourcesRow(CatalogName: WideString; SchemaName: WideString; PackageName: WideString; Definition: WideString); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TPackageSourcesRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property CatalogNameColumn: DataColumn read FColumnCatalogName;
    property SchemaNameColumn: DataColumn read FColumnSchemaName;
    property PackageNameColumn: DataColumn read FColumnPackageName;
    property DefinitionColumn: DataColumn read FColumnDefinition;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TPackageSourcesRow read GetItem; default;
  end;

  TPackageSourcesRow = class(DataRow)
  private
    FTablePackageSources: TPackageSourcesTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsCatalogNameNull: Boolean;
    procedure SetCatalogNameNull;
    function IsSchemaNameNull: Boolean;
    procedure SetSchemaNameNull;
    function IsPackageNameNull: Boolean;
    procedure SetPackageNameNull;
    function IsDefinitionNull: Boolean;
    procedure SetDefinitionNull;
  protected
    function GetCatalogName: WideString;
    procedure SetCatalogName(NewValue: WideString);
    function GetSchemaName: WideString;
    procedure SetSchemaName(NewValue: WideString);
    function GetPackageName: WideString;
    procedure SetPackageName(NewValue: WideString);
    function GetDefinition: WideString;
    procedure SetDefinition(NewValue: WideString);
  public
    property CatalogName: WideString read GetCatalogName write SetCatalogName;
    property SchemaName: WideString read GetSchemaName write SetSchemaName;
    property PackageName: WideString read GetPackageName write SetPackageName;
    property Definition: WideString read GetDefinition write SetDefinition;
  end;

  TUsersTable = class(DataTable)
  private
    FColumnUserName: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewUsersRow: TUsersRow;
    procedure RemoveUsersRow(Row: TUsersRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddUsersRow(Row: TUsersRow); overload;
    procedure AddUsersRow(UserName: WideString); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TUsersRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property UserNameColumn: DataColumn read FColumnUserName;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TUsersRow read GetItem; default;
  end;

  TUsersRow = class(DataRow)
  private
    FTableUsers: TUsersTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsUserNameNull: Boolean;
    procedure SetUserNameNull;
  protected
    function GetUserName: WideString;
    procedure SetUserName(NewValue: WideString);
  public
    property UserName: WideString read GetUserName write SetUserName;
  end;

  TRolesTable = class(DataTable)
  private
    FColumnRoleName: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewRolesRow: TRolesRow;
    procedure RemoveRolesRow(Row: TRolesRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddRolesRow(Row: TRolesRow); overload;
    procedure AddRolesRow(RoleName: WideString); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TRolesRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property RoleNameColumn: DataColumn read FColumnRoleName;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TRolesRow read GetItem; default;
  end;

  TRolesRow = class(DataRow)
  private
    FTableRoles: TRolesTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsRoleNameNull: Boolean;
    procedure SetRoleNameNull;
  protected
    function GetRoleName: WideString;
    procedure SetRoleName(NewValue: WideString);
  public
    property RoleName: WideString read GetRoleName write SetRoleName;
  end;

  TReservedWordsTable = class(DataTable)
  private
    FColumnReservedWord: DataColumn;
  public
    constructor Create;
    function Clone: DataTable; override;
    function NewReservedWordsRow: TReservedWordsRow;
    procedure RemoveReservedWordsRow(Row: TReservedWordsRow);
    function GetEnumerator: IEnumerator; virtual;
    procedure AddReservedWordsRow(Row: TReservedWordsRow); overload;
    procedure AddReservedWordsRow(ReservedWord: WideString); overload;
  strict protected
    function CreateInstance: DataTable; override;
    function NewRowFromBuilder(Builder: DataRowBuilder): DataRow; override;
    function GetRowType: System.Type; override;
    function GetItem(Index: Integer): TReservedWordsRow;
    function GetCount: Integer;
  private
    procedure InitClass;
    procedure InitVariables;
  public
    property ReservedWordColumn: DataColumn read FColumnReservedWord;
    property Count: Integer read GetCount;
    property Item[Index: Integer]: TReservedWordsRow read GetItem; default;
  end;

  TReservedWordsRow = class(DataRow)
  private
    FTableReservedWords: TReservedWordsTable;
  public
    constructor Create(Builder: DataRowBuilder);
    function IsReservedWordNull: Boolean;
    procedure SetReservedWordNull;
  protected
    function GetReservedWord: WideString;
    procedure SetReservedWord(NewValue: WideString);
  public
    property ReservedWord: WideString read GetReservedWord write SetReservedWord;
  end;

implementation
uses
  DBXMetaDataNames,
  DBXMetaDataReader;

constructor TDataTypesRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableDataTypes := TDataTypesTable(Table);
end;

function TDataTypesRow.IsTypeNameNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.TypeNameColumn);
end;

procedure TDataTypesRow.SetTypeNameNull;
begin
  Item[FTableDataTypes.TypeNameColumn] := DBNull.Value;
end;

function TDataTypesRow.IsDbxDataTypeNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.DbxDataTypeColumn);
end;

procedure TDataTypesRow.SetDbxDataTypeNull;
begin
  Item[FTableDataTypes.DbxDataTypeColumn] := DBNull.Value;
end;

function TDataTypesRow.IsColumnSizeNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.ColumnSizeColumn);
end;

procedure TDataTypesRow.SetColumnSizeNull;
begin
  Item[FTableDataTypes.ColumnSizeColumn] := DBNull.Value;
end;

function TDataTypesRow.IsCreateFormatNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.CreateFormatColumn);
end;

procedure TDataTypesRow.SetCreateFormatNull;
begin
  Item[FTableDataTypes.CreateFormatColumn] := DBNull.Value;
end;

function TDataTypesRow.IsCreateParametersNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.CreateParametersColumn);
end;

procedure TDataTypesRow.SetCreateParametersNull;
begin
  Item[FTableDataTypes.CreateParametersColumn] := DBNull.Value;
end;

function TDataTypesRow.IsDataTypeNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.DataTypeColumn);
end;

procedure TDataTypesRow.SetDataTypeNull;
begin
  Item[FTableDataTypes.DataTypeColumn] := DBNull.Value;
end;

function TDataTypesRow.IsIsAutoIncrementableNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.IsAutoIncrementableColumn);
end;

procedure TDataTypesRow.SetIsAutoIncrementableNull;
begin
  Item[FTableDataTypes.IsAutoIncrementableColumn] := DBNull.Value;
end;

function TDataTypesRow.IsIsBestMatchNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.IsBestMatchColumn);
end;

procedure TDataTypesRow.SetIsBestMatchNull;
begin
  Item[FTableDataTypes.IsBestMatchColumn] := DBNull.Value;
end;

function TDataTypesRow.IsIsCaseSensitiveNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.IsCaseSensitiveColumn);
end;

procedure TDataTypesRow.SetIsCaseSensitiveNull;
begin
  Item[FTableDataTypes.IsCaseSensitiveColumn] := DBNull.Value;
end;

function TDataTypesRow.IsIsFixedLengthNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.IsFixedLengthColumn);
end;

procedure TDataTypesRow.SetIsFixedLengthNull;
begin
  Item[FTableDataTypes.IsFixedLengthColumn] := DBNull.Value;
end;

function TDataTypesRow.IsIsFixedPrecisionScaleNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.IsFixedPrecisionScaleColumn);
end;

procedure TDataTypesRow.SetIsFixedPrecisionScaleNull;
begin
  Item[FTableDataTypes.IsFixedPrecisionScaleColumn] := DBNull.Value;
end;

function TDataTypesRow.IsIsLongNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.IsLongColumn);
end;

procedure TDataTypesRow.SetIsLongNull;
begin
  Item[FTableDataTypes.IsLongColumn] := DBNull.Value;
end;

function TDataTypesRow.IsIsNullableNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.IsNullableColumn);
end;

procedure TDataTypesRow.SetIsNullableNull;
begin
  Item[FTableDataTypes.IsNullableColumn] := DBNull.Value;
end;

function TDataTypesRow.IsIsSearchableNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.IsSearchableColumn);
end;

procedure TDataTypesRow.SetIsSearchableNull;
begin
  Item[FTableDataTypes.IsSearchableColumn] := DBNull.Value;
end;

function TDataTypesRow.IsIsSearchableWithLikeNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.IsSearchableWithLikeColumn);
end;

procedure TDataTypesRow.SetIsSearchableWithLikeNull;
begin
  Item[FTableDataTypes.IsSearchableWithLikeColumn] := DBNull.Value;
end;

function TDataTypesRow.IsIsUnsignedNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.IsUnsignedColumn);
end;

procedure TDataTypesRow.SetIsUnsignedNull;
begin
  Item[FTableDataTypes.IsUnsignedColumn] := DBNull.Value;
end;

function TDataTypesRow.IsMaximumScaleNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.MaximumScaleColumn);
end;

procedure TDataTypesRow.SetMaximumScaleNull;
begin
  Item[FTableDataTypes.MaximumScaleColumn] := DBNull.Value;
end;

function TDataTypesRow.IsMinimumScaleNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.MinimumScaleColumn);
end;

procedure TDataTypesRow.SetMinimumScaleNull;
begin
  Item[FTableDataTypes.MinimumScaleColumn] := DBNull.Value;
end;

function TDataTypesRow.IsIsConcurrencyTypeNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.IsConcurrencyTypeColumn);
end;

procedure TDataTypesRow.SetIsConcurrencyTypeNull;
begin
  Item[FTableDataTypes.IsConcurrencyTypeColumn] := DBNull.Value;
end;

function TDataTypesRow.IsMaximumVersionNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.MaximumVersionColumn);
end;

procedure TDataTypesRow.SetMaximumVersionNull;
begin
  Item[FTableDataTypes.MaximumVersionColumn] := DBNull.Value;
end;

function TDataTypesRow.IsMinimumVersionNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.MinimumVersionColumn);
end;

procedure TDataTypesRow.SetMinimumVersionNull;
begin
  Item[FTableDataTypes.MinimumVersionColumn] := DBNull.Value;
end;

function TDataTypesRow.IsIsLiteralSupportedNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.IsLiteralSupportedColumn);
end;

procedure TDataTypesRow.SetIsLiteralSupportedNull;
begin
  Item[FTableDataTypes.IsLiteralSupportedColumn] := DBNull.Value;
end;

function TDataTypesRow.IsLiteralPrefixNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.LiteralPrefixColumn);
end;

procedure TDataTypesRow.SetLiteralPrefixNull;
begin
  Item[FTableDataTypes.LiteralPrefixColumn] := DBNull.Value;
end;

function TDataTypesRow.IsLiteralSuffixNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.LiteralSuffixColumn);
end;

procedure TDataTypesRow.SetLiteralSuffixNull;
begin
  Item[FTableDataTypes.LiteralSuffixColumn] := DBNull.Value;
end;

function TDataTypesRow.IsIsUnicodeNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.IsUnicodeColumn);
end;

procedure TDataTypesRow.SetIsUnicodeNull;
begin
  Item[FTableDataTypes.IsUnicodeColumn] := DBNull.Value;
end;

function TDataTypesRow.IsProviderDbTypeNull: Boolean;
begin
  Result := IsNull(FTableDataTypes.ProviderDbTypeColumn);
end;

procedure TDataTypesRow.SetProviderDbTypeNull;
begin
  Item[FTableDataTypes.ProviderDbTypeColumn] := DBNull.Value;
end;

function TDataTypesRow.GetTypeName: WideString;
begin
  Result := Item[FTableDataTypes.TypeNameColumn] as WideString;
end;

procedure TDataTypesRow.SetTypeName(NewValue: WideString);
begin
  Item[FTableDataTypes.TypeNameColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetDbxDataType: Integer;
begin
  Result := Item[FTableDataTypes.DbxDataTypeColumn] as Integer;
end;

procedure TDataTypesRow.SetDbxDataType(NewValue: Integer);
begin
  Item[FTableDataTypes.DbxDataTypeColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetColumnSize: Int64;
begin
  Result := Item[FTableDataTypes.ColumnSizeColumn] as Int64;
end;

procedure TDataTypesRow.SetColumnSize(NewValue: Int64);
begin
  Item[FTableDataTypes.ColumnSizeColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetCreateFormat: WideString;
begin
  Result := Item[FTableDataTypes.CreateFormatColumn] as WideString;
end;

procedure TDataTypesRow.SetCreateFormat(NewValue: WideString);
begin
  Item[FTableDataTypes.CreateFormatColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetCreateParameters: WideString;
begin
  Result := Item[FTableDataTypes.CreateParametersColumn] as WideString;
end;

procedure TDataTypesRow.SetCreateParameters(NewValue: WideString);
begin
  Item[FTableDataTypes.CreateParametersColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetDataType: WideString;
begin
  Result := Item[FTableDataTypes.DataTypeColumn] as WideString;
end;

procedure TDataTypesRow.SetDataType(NewValue: WideString);
begin
  Item[FTableDataTypes.DataTypeColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetIsAutoIncrementable: Boolean;
begin
  Result := Item[FTableDataTypes.IsAutoIncrementableColumn] as Boolean;
end;

procedure TDataTypesRow.SetIsAutoIncrementable(NewValue: Boolean);
begin
  Item[FTableDataTypes.IsAutoIncrementableColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetIsBestMatch: Boolean;
begin
  Result := Item[FTableDataTypes.IsBestMatchColumn] as Boolean;
end;

procedure TDataTypesRow.SetIsBestMatch(NewValue: Boolean);
begin
  Item[FTableDataTypes.IsBestMatchColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetIsCaseSensitive: Boolean;
begin
  Result := Item[FTableDataTypes.IsCaseSensitiveColumn] as Boolean;
end;

procedure TDataTypesRow.SetIsCaseSensitive(NewValue: Boolean);
begin
  Item[FTableDataTypes.IsCaseSensitiveColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetIsFixedLength: Boolean;
begin
  Result := Item[FTableDataTypes.IsFixedLengthColumn] as Boolean;
end;

procedure TDataTypesRow.SetIsFixedLength(NewValue: Boolean);
begin
  Item[FTableDataTypes.IsFixedLengthColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetIsFixedPrecisionScale: Boolean;
begin
  Result := Item[FTableDataTypes.IsFixedPrecisionScaleColumn] as Boolean;
end;

procedure TDataTypesRow.SetIsFixedPrecisionScale(NewValue: Boolean);
begin
  Item[FTableDataTypes.IsFixedPrecisionScaleColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetIsLong: Boolean;
begin
  Result := Item[FTableDataTypes.IsLongColumn] as Boolean;
end;

procedure TDataTypesRow.SetIsLong(NewValue: Boolean);
begin
  Item[FTableDataTypes.IsLongColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetIsNullable: Boolean;
begin
  Result := Item[FTableDataTypes.IsNullableColumn] as Boolean;
end;

procedure TDataTypesRow.SetIsNullable(NewValue: Boolean);
begin
  Item[FTableDataTypes.IsNullableColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetIsSearchable: Boolean;
begin
  Result := Item[FTableDataTypes.IsSearchableColumn] as Boolean;
end;

procedure TDataTypesRow.SetIsSearchable(NewValue: Boolean);
begin
  Item[FTableDataTypes.IsSearchableColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetIsSearchableWithLike: Boolean;
begin
  Result := Item[FTableDataTypes.IsSearchableWithLikeColumn] as Boolean;
end;

procedure TDataTypesRow.SetIsSearchableWithLike(NewValue: Boolean);
begin
  Item[FTableDataTypes.IsSearchableWithLikeColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetIsUnsigned: Boolean;
begin
  Result := Item[FTableDataTypes.IsUnsignedColumn] as Boolean;
end;

procedure TDataTypesRow.SetIsUnsigned(NewValue: Boolean);
begin
  Item[FTableDataTypes.IsUnsignedColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetMaximumScale: SmallInt;
begin
  Result := Item[FTableDataTypes.MaximumScaleColumn] as SmallInt;
end;

procedure TDataTypesRow.SetMaximumScale(NewValue: SmallInt);
begin
  Item[FTableDataTypes.MaximumScaleColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetMinimumScale: SmallInt;
begin
  Result := Item[FTableDataTypes.MinimumScaleColumn] as SmallInt;
end;

procedure TDataTypesRow.SetMinimumScale(NewValue: SmallInt);
begin
  Item[FTableDataTypes.MinimumScaleColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetIsConcurrencyType: Boolean;
begin
  Result := Item[FTableDataTypes.IsConcurrencyTypeColumn] as Boolean;
end;

procedure TDataTypesRow.SetIsConcurrencyType(NewValue: Boolean);
begin
  Item[FTableDataTypes.IsConcurrencyTypeColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetMaximumVersion: WideString;
begin
  Result := Item[FTableDataTypes.MaximumVersionColumn] as WideString;
end;

procedure TDataTypesRow.SetMaximumVersion(NewValue: WideString);
begin
  Item[FTableDataTypes.MaximumVersionColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetMinimumVersion: WideString;
begin
  Result := Item[FTableDataTypes.MinimumVersionColumn] as WideString;
end;

procedure TDataTypesRow.SetMinimumVersion(NewValue: WideString);
begin
  Item[FTableDataTypes.MinimumVersionColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetIsLiteralSupported: Boolean;
begin
  Result := Item[FTableDataTypes.IsLiteralSupportedColumn] as Boolean;
end;

procedure TDataTypesRow.SetIsLiteralSupported(NewValue: Boolean);
begin
  Item[FTableDataTypes.IsLiteralSupportedColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetLiteralPrefix: WideString;
begin
  Result := Item[FTableDataTypes.LiteralPrefixColumn] as WideString;
end;

procedure TDataTypesRow.SetLiteralPrefix(NewValue: WideString);
begin
  Item[FTableDataTypes.LiteralPrefixColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetLiteralSuffix: WideString;
begin
  Result := Item[FTableDataTypes.LiteralSuffixColumn] as WideString;
end;

procedure TDataTypesRow.SetLiteralSuffix(NewValue: WideString);
begin
  Item[FTableDataTypes.LiteralSuffixColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetIsUnicode: Boolean;
begin
  Result := Item[FTableDataTypes.IsUnicodeColumn] as Boolean;
end;

procedure TDataTypesRow.SetIsUnicode(NewValue: Boolean);
begin
  Item[FTableDataTypes.IsUnicodeColumn] := TObject(NewValue);
end;

function TDataTypesRow.GetProviderDbType: Integer;
begin
  Result := Item[FTableDataTypes.ProviderDbTypeColumn] as Integer;
end;

procedure TDataTypesRow.SetProviderDbType(NewValue: Integer);
begin
  Item[FTableDataTypes.ProviderDbTypeColumn] := TObject(NewValue);
end;

constructor TDataTypesTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.DataTypes;
  BeginInit();
  InitClass();
  EndInit();
end;

function TDataTypesTable.Clone: DataTable;
var
  NewClone: TDataTypesTable;
begin
  NewClone := TDataTypesTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TDataTypesTable.CreateInstance: DataTable;
begin
  Result := TDataTypesTable.Create;
end;

function TDataTypesTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TDataTypesTable.GetItem(Index: Integer): TDataTypesRow;
begin
  Result := TDataTypesRow(Rows.Item[Index]);
end;

function TDataTypesTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TDataTypesTable.AddDataTypesRow(Row: TDataTypesRow);
begin
  Rows.Add(Row);
end;

procedure TDataTypesTable.AddDataTypesRow(TypeName: WideString; DbxDataType: Integer; ColumnSize: Int64; CreateFormat: WideString; CreateParameters: WideString; DataType: WideString; IsAutoIncrementable: Boolean; IsBestMatch: Boolean; IsCaseSensitive: Boolean; IsFixedLength: Boolean; IsFixedPrecisionScale: Boolean; IsLong: Boolean; IsNullable: Boolean; IsSearchable: Boolean; IsSearchableWithLike: Boolean; IsUnsigned: Boolean; MaximumScale: SmallInt; MinimumScale: SmallInt; IsConcurrencyType: Boolean; MaximumVersion: WideString; MinimumVersion: WideString; IsLiteralSupported: Boolean; LiteralPrefix: WideString; LiteralSuffix: WideString; IsUnicode: Boolean; ProviderDbType: Integer);
var
  NewRow: TDataTypesRow;
begin
  NewRow := NewDataTypesRow;
  NewRow.TypeName := TypeName;
  NewRow.DbxDataType := DbxDataType;
  NewRow.ColumnSize := ColumnSize;
  NewRow.CreateFormat := CreateFormat;
  NewRow.CreateParameters := CreateParameters;
  NewRow.DataType := DataType;
  NewRow.IsAutoIncrementable := IsAutoIncrementable;
  NewRow.IsBestMatch := IsBestMatch;
  NewRow.IsCaseSensitive := IsCaseSensitive;
  NewRow.IsFixedLength := IsFixedLength;
  NewRow.IsFixedPrecisionScale := IsFixedPrecisionScale;
  NewRow.IsLong := IsLong;
  NewRow.IsNullable := IsNullable;
  NewRow.IsSearchable := IsSearchable;
  NewRow.IsSearchableWithLike := IsSearchableWithLike;
  NewRow.IsUnsigned := IsUnsigned;
  NewRow.MaximumScale := MaximumScale;
  NewRow.MinimumScale := MinimumScale;
  NewRow.IsConcurrencyType := IsConcurrencyType;
  NewRow.MaximumVersion := MaximumVersion;
  NewRow.MinimumVersion := MinimumVersion;
  NewRow.IsLiteralSupported := IsLiteralSupported;
  NewRow.LiteralPrefix := LiteralPrefix;
  NewRow.LiteralSuffix := LiteralSuffix;
  NewRow.IsUnicode := IsUnicode;
  NewRow.ProviderDbType := ProviderDbType;
  AddDataTypesRow(NewRow);
end;

function TDataTypesTable.NewDataTypesRow: TDataTypesRow;
begin
  Result := TDataTypesRow(NewRow);
end;

procedure TDataTypesTable.RemoveDataTypesRow(Row: TDataTypesRow);
begin
  Rows.Remove(Row);
end;

function TDataTypesTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TDataTypesRow.Create(Builder);
end;

function TDataTypesTable.GetRowType: System.Type;
begin
  Result := typeof(TDataTypesRow);
end;

procedure TDataTypesTable.InitClass;
begin
  FColumnTypeName := DataColumn.Create(TDBXDataTypesColumns.TypeName, typeof(WideString));
  FColumnTypeName.Caption := STypeName;
  Columns.Add(FColumnTypeName);
  FColumnDbxDataType := DataColumn.Create(TDBXDataTypesColumns.DbxDataType, typeof(Integer));
  FColumnDbxDataType.Caption := SDbxDataType;
  Columns.Add(FColumnDbxDataType);
  FColumnColumnSize := DataColumn.Create(TDBXDataTypesColumns.ColumnSize, typeof(Int64));
  FColumnColumnSize.Caption := SColumnSize;
  Columns.Add(FColumnColumnSize);
  FColumnCreateFormat := DataColumn.Create(TDBXDataTypesColumns.CreateFormat, typeof(WideString));
  FColumnCreateFormat.Caption := SCreateFormat;
  Columns.Add(FColumnCreateFormat);
  FColumnCreateParameters := DataColumn.Create(TDBXDataTypesColumns.CreateParameters, typeof(WideString));
  FColumnCreateParameters.Caption := SCreateParameters;
  Columns.Add(FColumnCreateParameters);
  FColumnDataType := DataColumn.Create(TDBXDataTypesColumns.DataType, typeof(WideString));
  FColumnDataType.Caption := SDataType;
  Columns.Add(FColumnDataType);
  FColumnIsAutoIncrementable := DataColumn.Create(TDBXDataTypesColumns.IsAutoIncrementable, typeof(Boolean));
  FColumnIsAutoIncrementable.Caption := SIsAutoIncrementable;
  Columns.Add(FColumnIsAutoIncrementable);
  FColumnIsBestMatch := DataColumn.Create(TDBXDataTypesColumns.IsBestMatch, typeof(Boolean));
  FColumnIsBestMatch.Caption := SIsBestMatch;
  Columns.Add(FColumnIsBestMatch);
  FColumnIsCaseSensitive := DataColumn.Create(TDBXDataTypesColumns.IsCaseSensitive, typeof(Boolean));
  FColumnIsCaseSensitive.Caption := SIsCaseSensitive;
  Columns.Add(FColumnIsCaseSensitive);
  FColumnIsFixedLength := DataColumn.Create(TDBXDataTypesColumns.IsFixedLength, typeof(Boolean));
  FColumnIsFixedLength.Caption := SIsFixedLength;
  Columns.Add(FColumnIsFixedLength);
  FColumnIsFixedPrecisionScale := DataColumn.Create(TDBXDataTypesColumns.IsFixedPrecisionScale, typeof(Boolean));
  FColumnIsFixedPrecisionScale.Caption := SIsFixedPrecisionScale;
  Columns.Add(FColumnIsFixedPrecisionScale);
  FColumnIsLong := DataColumn.Create(TDBXDataTypesColumns.IsLong, typeof(Boolean));
  FColumnIsLong.Caption := SIsLong;
  Columns.Add(FColumnIsLong);
  FColumnIsNullable := DataColumn.Create(TDBXDataTypesColumns.IsNullable, typeof(Boolean));
  FColumnIsNullable.Caption := SIsNullable;
  Columns.Add(FColumnIsNullable);
  FColumnIsSearchable := DataColumn.Create(TDBXDataTypesColumns.IsSearchable, typeof(Boolean));
  FColumnIsSearchable.Caption := SIsSearchable;
  Columns.Add(FColumnIsSearchable);
  FColumnIsSearchableWithLike := DataColumn.Create(TDBXDataTypesColumns.IsSearchableWithLike, typeof(Boolean));
  FColumnIsSearchableWithLike.Caption := SIsSearchableWithLike;
  Columns.Add(FColumnIsSearchableWithLike);
  FColumnIsUnsigned := DataColumn.Create(TDBXDataTypesColumns.IsUnsigned, typeof(Boolean));
  FColumnIsUnsigned.Caption := SIsUnsigned;
  Columns.Add(FColumnIsUnsigned);
  FColumnMaximumScale := DataColumn.Create(TDBXDataTypesColumns.MaximumScale, typeof(SmallInt));
  FColumnMaximumScale.Caption := SMaximumScale;
  Columns.Add(FColumnMaximumScale);
  FColumnMinimumScale := DataColumn.Create(TDBXDataTypesColumns.MinimumScale, typeof(SmallInt));
  FColumnMinimumScale.Caption := SMinimumScale;
  Columns.Add(FColumnMinimumScale);
  FColumnIsConcurrencyType := DataColumn.Create(TDBXDataTypesColumns.IsConcurrencyType, typeof(Boolean));
  FColumnIsConcurrencyType.Caption := SIsConcurrencyType;
  Columns.Add(FColumnIsConcurrencyType);
  FColumnMaximumVersion := DataColumn.Create(TDBXDataTypesColumns.MaximumVersion, typeof(WideString));
  FColumnMaximumVersion.Caption := SMaximumVersion;
  Columns.Add(FColumnMaximumVersion);
  FColumnMinimumVersion := DataColumn.Create(TDBXDataTypesColumns.MinimumVersion, typeof(WideString));
  FColumnMinimumVersion.Caption := SMinimumVersion;
  Columns.Add(FColumnMinimumVersion);
  FColumnIsLiteralSupported := DataColumn.Create(TDBXDataTypesColumns.IsLiteralSupported, typeof(Boolean));
  FColumnIsLiteralSupported.Caption := SIsLiteralSupported;
  Columns.Add(FColumnIsLiteralSupported);
  FColumnLiteralPrefix := DataColumn.Create(TDBXDataTypesColumns.LiteralPrefix, typeof(WideString));
  FColumnLiteralPrefix.Caption := SLiteralPrefix;
  Columns.Add(FColumnLiteralPrefix);
  FColumnLiteralSuffix := DataColumn.Create(TDBXDataTypesColumns.LiteralSuffix, typeof(WideString));
  FColumnLiteralSuffix.Caption := SLiteralSuffix;
  Columns.Add(FColumnLiteralSuffix);
  FColumnIsUnicode := DataColumn.Create(TDBXDataTypesColumns.IsUnicode, typeof(Boolean));
  FColumnIsUnicode.Caption := SIsUnicode;
  Columns.Add(FColumnIsUnicode);
  FColumnProviderDbType := DataColumn.Create(TDBXDataTypesColumns.ProviderDbType, typeof(Integer));
  FColumnProviderDbType.Caption := SProviderDbType;
  Columns.Add(FColumnProviderDbType);
end;

procedure TDataTypesTable.InitVariables;
begin
  FColumnTypeName := Columns[TDBXDataTypesColumns.TypeName];
  FColumnDbxDataType := Columns[TDBXDataTypesColumns.DbxDataType];
  FColumnColumnSize := Columns[TDBXDataTypesColumns.ColumnSize];
  FColumnCreateFormat := Columns[TDBXDataTypesColumns.CreateFormat];
  FColumnCreateParameters := Columns[TDBXDataTypesColumns.CreateParameters];
  FColumnDataType := Columns[TDBXDataTypesColumns.DataType];
  FColumnIsAutoIncrementable := Columns[TDBXDataTypesColumns.IsAutoIncrementable];
  FColumnIsBestMatch := Columns[TDBXDataTypesColumns.IsBestMatch];
  FColumnIsCaseSensitive := Columns[TDBXDataTypesColumns.IsCaseSensitive];
  FColumnIsFixedLength := Columns[TDBXDataTypesColumns.IsFixedLength];
  FColumnIsFixedPrecisionScale := Columns[TDBXDataTypesColumns.IsFixedPrecisionScale];
  FColumnIsLong := Columns[TDBXDataTypesColumns.IsLong];
  FColumnIsNullable := Columns[TDBXDataTypesColumns.IsNullable];
  FColumnIsSearchable := Columns[TDBXDataTypesColumns.IsSearchable];
  FColumnIsSearchableWithLike := Columns[TDBXDataTypesColumns.IsSearchableWithLike];
  FColumnIsUnsigned := Columns[TDBXDataTypesColumns.IsUnsigned];
  FColumnMaximumScale := Columns[TDBXDataTypesColumns.MaximumScale];
  FColumnMinimumScale := Columns[TDBXDataTypesColumns.MinimumScale];
  FColumnIsConcurrencyType := Columns[TDBXDataTypesColumns.IsConcurrencyType];
  FColumnMaximumVersion := Columns[TDBXDataTypesColumns.MaximumVersion];
  FColumnMinimumVersion := Columns[TDBXDataTypesColumns.MinimumVersion];
  FColumnIsLiteralSupported := Columns[TDBXDataTypesColumns.IsLiteralSupported];
  FColumnLiteralPrefix := Columns[TDBXDataTypesColumns.LiteralPrefix];
  FColumnLiteralSuffix := Columns[TDBXDataTypesColumns.LiteralSuffix];
  FColumnIsUnicode := Columns[TDBXDataTypesColumns.IsUnicode];
  FColumnProviderDbType := Columns[TDBXDataTypesColumns.ProviderDbType];
end;

constructor TCatalogsRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableCatalogs := TCatalogsTable(Table);
end;

function TCatalogsRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTableCatalogs.CatalogNameColumn);
end;

procedure TCatalogsRow.SetCatalogNameNull;
begin
  Item[FTableCatalogs.CatalogNameColumn] := DBNull.Value;
end;

function TCatalogsRow.GetCatalogName: WideString;
begin
  Result := Item[FTableCatalogs.CatalogNameColumn] as WideString;
end;

procedure TCatalogsRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTableCatalogs.CatalogNameColumn] := TObject(NewValue);
end;

constructor TCatalogsTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.Catalogs;
  BeginInit();
  InitClass();
  EndInit();
end;

function TCatalogsTable.Clone: DataTable;
var
  NewClone: TCatalogsTable;
begin
  NewClone := TCatalogsTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TCatalogsTable.CreateInstance: DataTable;
begin
  Result := TCatalogsTable.Create;
end;

function TCatalogsTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TCatalogsTable.GetItem(Index: Integer): TCatalogsRow;
begin
  Result := TCatalogsRow(Rows.Item[Index]);
end;

function TCatalogsTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TCatalogsTable.AddCatalogsRow(Row: TCatalogsRow);
begin
  Rows.Add(Row);
end;

procedure TCatalogsTable.AddCatalogsRow(CatalogName: WideString);
var
  NewRow: TCatalogsRow;
begin
  NewRow := NewCatalogsRow;
  NewRow.CatalogName := CatalogName;
  AddCatalogsRow(NewRow);
end;

function TCatalogsTable.NewCatalogsRow: TCatalogsRow;
begin
  Result := TCatalogsRow(NewRow);
end;

procedure TCatalogsTable.RemoveCatalogsRow(Row: TCatalogsRow);
begin
  Rows.Remove(Row);
end;

function TCatalogsTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TCatalogsRow.Create(Builder);
end;

function TCatalogsTable.GetRowType: System.Type;
begin
  Result := typeof(TCatalogsRow);
end;

procedure TCatalogsTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXCatalogsColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
end;

procedure TCatalogsTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXCatalogsColumns.CatalogName];
end;

constructor TSchemasRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableSchemas := TSchemasTable(Table);
end;

function TSchemasRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTableSchemas.CatalogNameColumn);
end;

procedure TSchemasRow.SetCatalogNameNull;
begin
  Item[FTableSchemas.CatalogNameColumn] := DBNull.Value;
end;

function TSchemasRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTableSchemas.SchemaNameColumn);
end;

procedure TSchemasRow.SetSchemaNameNull;
begin
  Item[FTableSchemas.SchemaNameColumn] := DBNull.Value;
end;

function TSchemasRow.GetCatalogName: WideString;
begin
  Result := Item[FTableSchemas.CatalogNameColumn] as WideString;
end;

procedure TSchemasRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTableSchemas.CatalogNameColumn] := TObject(NewValue);
end;

function TSchemasRow.GetSchemaName: WideString;
begin
  Result := Item[FTableSchemas.SchemaNameColumn] as WideString;
end;

procedure TSchemasRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTableSchemas.SchemaNameColumn] := TObject(NewValue);
end;

constructor TSchemasTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.Schemas;
  BeginInit();
  InitClass();
  EndInit();
end;

function TSchemasTable.Clone: DataTable;
var
  NewClone: TSchemasTable;
begin
  NewClone := TSchemasTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TSchemasTable.CreateInstance: DataTable;
begin
  Result := TSchemasTable.Create;
end;

function TSchemasTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TSchemasTable.GetItem(Index: Integer): TSchemasRow;
begin
  Result := TSchemasRow(Rows.Item[Index]);
end;

function TSchemasTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TSchemasTable.AddSchemasRow(Row: TSchemasRow);
begin
  Rows.Add(Row);
end;

procedure TSchemasTable.AddSchemasRow(CatalogName: WideString; SchemaName: WideString);
var
  NewRow: TSchemasRow;
begin
  NewRow := NewSchemasRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  AddSchemasRow(NewRow);
end;

function TSchemasTable.NewSchemasRow: TSchemasRow;
begin
  Result := TSchemasRow(NewRow);
end;

procedure TSchemasTable.RemoveSchemasRow(Row: TSchemasRow);
begin
  Rows.Remove(Row);
end;

function TSchemasTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TSchemasRow.Create(Builder);
end;

function TSchemasTable.GetRowType: System.Type;
begin
  Result := typeof(TSchemasRow);
end;

procedure TSchemasTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXSchemasColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXSchemasColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
end;

procedure TSchemasTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXSchemasColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXSchemasColumns.SchemaName];
end;

constructor TTablesRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableTables := TTablesTable(Table);
end;

function TTablesRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTableTables.CatalogNameColumn);
end;

procedure TTablesRow.SetCatalogNameNull;
begin
  Item[FTableTables.CatalogNameColumn] := DBNull.Value;
end;

function TTablesRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTableTables.SchemaNameColumn);
end;

procedure TTablesRow.SetSchemaNameNull;
begin
  Item[FTableTables.SchemaNameColumn] := DBNull.Value;
end;

function TTablesRow.IsTableNameNull: Boolean;
begin
  Result := IsNull(FTableTables.TableNameColumn);
end;

procedure TTablesRow.SetTableNameNull;
begin
  Item[FTableTables.TableNameColumn] := DBNull.Value;
end;

function TTablesRow.IsTableTypeNull: Boolean;
begin
  Result := IsNull(FTableTables.TableTypeColumn);
end;

procedure TTablesRow.SetTableTypeNull;
begin
  Item[FTableTables.TableTypeColumn] := DBNull.Value;
end;

function TTablesRow.GetCatalogName: WideString;
begin
  Result := Item[FTableTables.CatalogNameColumn] as WideString;
end;

procedure TTablesRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTableTables.CatalogNameColumn] := TObject(NewValue);
end;

function TTablesRow.GetSchemaName: WideString;
begin
  Result := Item[FTableTables.SchemaNameColumn] as WideString;
end;

procedure TTablesRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTableTables.SchemaNameColumn] := TObject(NewValue);
end;

function TTablesRow.GetTableName: WideString;
begin
  Result := Item[FTableTables.TableNameColumn] as WideString;
end;

procedure TTablesRow.SetTableName(NewValue: WideString);
begin
  Item[FTableTables.TableNameColumn] := TObject(NewValue);
end;

function TTablesRow.GetTableType: WideString;
begin
  Result := Item[FTableTables.TableTypeColumn] as WideString;
end;

procedure TTablesRow.SetTableType(NewValue: WideString);
begin
  Item[FTableTables.TableTypeColumn] := TObject(NewValue);
end;

constructor TTablesTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.Tables;
  BeginInit();
  InitClass();
  EndInit();
end;

function TTablesTable.Clone: DataTable;
var
  NewClone: TTablesTable;
begin
  NewClone := TTablesTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TTablesTable.CreateInstance: DataTable;
begin
  Result := TTablesTable.Create;
end;

function TTablesTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TTablesTable.GetItem(Index: Integer): TTablesRow;
begin
  Result := TTablesRow(Rows.Item[Index]);
end;

function TTablesTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TTablesTable.AddTablesRow(Row: TTablesRow);
begin
  Rows.Add(Row);
end;

procedure TTablesTable.AddTablesRow(CatalogName: WideString; SchemaName: WideString; TableName: WideString; TableType: WideString);
var
  NewRow: TTablesRow;
begin
  NewRow := NewTablesRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  NewRow.TableName := TableName;
  NewRow.TableType := TableType;
  AddTablesRow(NewRow);
end;

function TTablesTable.NewTablesRow: TTablesRow;
begin
  Result := TTablesRow(NewRow);
end;

procedure TTablesTable.RemoveTablesRow(Row: TTablesRow);
begin
  Rows.Remove(Row);
end;

function TTablesTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TTablesRow.Create(Builder);
end;

function TTablesTable.GetRowType: System.Type;
begin
  Result := typeof(TTablesRow);
end;

procedure TTablesTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXTablesColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXTablesColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
  FColumnTableName := DataColumn.Create(TDBXTablesColumns.TableName, typeof(WideString));
  FColumnTableName.Caption := STableName;
  Columns.Add(FColumnTableName);
  FColumnTableType := DataColumn.Create(TDBXTablesColumns.TableType, typeof(WideString));
  FColumnTableType.Caption := STableType;
  Columns.Add(FColumnTableType);
end;

procedure TTablesTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXTablesColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXTablesColumns.SchemaName];
  FColumnTableName := Columns[TDBXTablesColumns.TableName];
  FColumnTableType := Columns[TDBXTablesColumns.TableType];
end;

constructor TViewsRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableViews := TViewsTable(Table);
end;

function TViewsRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTableViews.CatalogNameColumn);
end;

procedure TViewsRow.SetCatalogNameNull;
begin
  Item[FTableViews.CatalogNameColumn] := DBNull.Value;
end;

function TViewsRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTableViews.SchemaNameColumn);
end;

procedure TViewsRow.SetSchemaNameNull;
begin
  Item[FTableViews.SchemaNameColumn] := DBNull.Value;
end;

function TViewsRow.IsViewNameNull: Boolean;
begin
  Result := IsNull(FTableViews.ViewNameColumn);
end;

procedure TViewsRow.SetViewNameNull;
begin
  Item[FTableViews.ViewNameColumn] := DBNull.Value;
end;

function TViewsRow.IsDefinitionNull: Boolean;
begin
  Result := IsNull(FTableViews.DefinitionColumn);
end;

procedure TViewsRow.SetDefinitionNull;
begin
  Item[FTableViews.DefinitionColumn] := DBNull.Value;
end;

function TViewsRow.GetCatalogName: WideString;
begin
  Result := Item[FTableViews.CatalogNameColumn] as WideString;
end;

procedure TViewsRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTableViews.CatalogNameColumn] := TObject(NewValue);
end;

function TViewsRow.GetSchemaName: WideString;
begin
  Result := Item[FTableViews.SchemaNameColumn] as WideString;
end;

procedure TViewsRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTableViews.SchemaNameColumn] := TObject(NewValue);
end;

function TViewsRow.GetViewName: WideString;
begin
  Result := Item[FTableViews.ViewNameColumn] as WideString;
end;

procedure TViewsRow.SetViewName(NewValue: WideString);
begin
  Item[FTableViews.ViewNameColumn] := TObject(NewValue);
end;

function TViewsRow.GetDefinition: WideString;
begin
  Result := Item[FTableViews.DefinitionColumn] as WideString;
end;

procedure TViewsRow.SetDefinition(NewValue: WideString);
begin
  Item[FTableViews.DefinitionColumn] := TObject(NewValue);
end;

constructor TViewsTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.Views;
  BeginInit();
  InitClass();
  EndInit();
end;

function TViewsTable.Clone: DataTable;
var
  NewClone: TViewsTable;
begin
  NewClone := TViewsTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TViewsTable.CreateInstance: DataTable;
begin
  Result := TViewsTable.Create;
end;

function TViewsTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TViewsTable.GetItem(Index: Integer): TViewsRow;
begin
  Result := TViewsRow(Rows.Item[Index]);
end;

function TViewsTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TViewsTable.AddViewsRow(Row: TViewsRow);
begin
  Rows.Add(Row);
end;

procedure TViewsTable.AddViewsRow(CatalogName: WideString; SchemaName: WideString; ViewName: WideString; Definition: WideString);
var
  NewRow: TViewsRow;
begin
  NewRow := NewViewsRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  NewRow.ViewName := ViewName;
  NewRow.Definition := Definition;
  AddViewsRow(NewRow);
end;

function TViewsTable.NewViewsRow: TViewsRow;
begin
  Result := TViewsRow(NewRow);
end;

procedure TViewsTable.RemoveViewsRow(Row: TViewsRow);
begin
  Rows.Remove(Row);
end;

function TViewsTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TViewsRow.Create(Builder);
end;

function TViewsTable.GetRowType: System.Type;
begin
  Result := typeof(TViewsRow);
end;

procedure TViewsTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXViewsColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXViewsColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
  FColumnViewName := DataColumn.Create(TDBXViewsColumns.ViewName, typeof(WideString));
  FColumnViewName.Caption := SViewName;
  Columns.Add(FColumnViewName);
  FColumnDefinition := DataColumn.Create(TDBXViewsColumns.Definition, typeof(WideString));
  FColumnDefinition.Caption := SDefinition;
  Columns.Add(FColumnDefinition);
end;

procedure TViewsTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXViewsColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXViewsColumns.SchemaName];
  FColumnViewName := Columns[TDBXViewsColumns.ViewName];
  FColumnDefinition := Columns[TDBXViewsColumns.Definition];
end;

constructor TSynonymsRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableSynonyms := TSynonymsTable(Table);
end;

function TSynonymsRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTableSynonyms.CatalogNameColumn);
end;

procedure TSynonymsRow.SetCatalogNameNull;
begin
  Item[FTableSynonyms.CatalogNameColumn] := DBNull.Value;
end;

function TSynonymsRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTableSynonyms.SchemaNameColumn);
end;

procedure TSynonymsRow.SetSchemaNameNull;
begin
  Item[FTableSynonyms.SchemaNameColumn] := DBNull.Value;
end;

function TSynonymsRow.IsSynonymNameNull: Boolean;
begin
  Result := IsNull(FTableSynonyms.SynonymNameColumn);
end;

procedure TSynonymsRow.SetSynonymNameNull;
begin
  Item[FTableSynonyms.SynonymNameColumn] := DBNull.Value;
end;

function TSynonymsRow.IsTableCatalogNameNull: Boolean;
begin
  Result := IsNull(FTableSynonyms.TableCatalogNameColumn);
end;

procedure TSynonymsRow.SetTableCatalogNameNull;
begin
  Item[FTableSynonyms.TableCatalogNameColumn] := DBNull.Value;
end;

function TSynonymsRow.IsTableSchemaNameNull: Boolean;
begin
  Result := IsNull(FTableSynonyms.TableSchemaNameColumn);
end;

procedure TSynonymsRow.SetTableSchemaNameNull;
begin
  Item[FTableSynonyms.TableSchemaNameColumn] := DBNull.Value;
end;

function TSynonymsRow.IsTableNameNull: Boolean;
begin
  Result := IsNull(FTableSynonyms.TableNameColumn);
end;

procedure TSynonymsRow.SetTableNameNull;
begin
  Item[FTableSynonyms.TableNameColumn] := DBNull.Value;
end;

function TSynonymsRow.GetCatalogName: WideString;
begin
  Result := Item[FTableSynonyms.CatalogNameColumn] as WideString;
end;

procedure TSynonymsRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTableSynonyms.CatalogNameColumn] := TObject(NewValue);
end;

function TSynonymsRow.GetSchemaName: WideString;
begin
  Result := Item[FTableSynonyms.SchemaNameColumn] as WideString;
end;

procedure TSynonymsRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTableSynonyms.SchemaNameColumn] := TObject(NewValue);
end;

function TSynonymsRow.GetSynonymName: WideString;
begin
  Result := Item[FTableSynonyms.SynonymNameColumn] as WideString;
end;

procedure TSynonymsRow.SetSynonymName(NewValue: WideString);
begin
  Item[FTableSynonyms.SynonymNameColumn] := TObject(NewValue);
end;

function TSynonymsRow.GetTableCatalogName: WideString;
begin
  Result := Item[FTableSynonyms.TableCatalogNameColumn] as WideString;
end;

procedure TSynonymsRow.SetTableCatalogName(NewValue: WideString);
begin
  Item[FTableSynonyms.TableCatalogNameColumn] := TObject(NewValue);
end;

function TSynonymsRow.GetTableSchemaName: WideString;
begin
  Result := Item[FTableSynonyms.TableSchemaNameColumn] as WideString;
end;

procedure TSynonymsRow.SetTableSchemaName(NewValue: WideString);
begin
  Item[FTableSynonyms.TableSchemaNameColumn] := TObject(NewValue);
end;

function TSynonymsRow.GetTableName: WideString;
begin
  Result := Item[FTableSynonyms.TableNameColumn] as WideString;
end;

procedure TSynonymsRow.SetTableName(NewValue: WideString);
begin
  Item[FTableSynonyms.TableNameColumn] := TObject(NewValue);
end;

constructor TSynonymsTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.Synonyms;
  BeginInit();
  InitClass();
  EndInit();
end;

function TSynonymsTable.Clone: DataTable;
var
  NewClone: TSynonymsTable;
begin
  NewClone := TSynonymsTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TSynonymsTable.CreateInstance: DataTable;
begin
  Result := TSynonymsTable.Create;
end;

function TSynonymsTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TSynonymsTable.GetItem(Index: Integer): TSynonymsRow;
begin
  Result := TSynonymsRow(Rows.Item[Index]);
end;

function TSynonymsTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TSynonymsTable.AddSynonymsRow(Row: TSynonymsRow);
begin
  Rows.Add(Row);
end;

procedure TSynonymsTable.AddSynonymsRow(CatalogName: WideString; SchemaName: WideString; SynonymName: WideString; TableCatalogName: WideString; TableSchemaName: WideString; TableName: WideString);
var
  NewRow: TSynonymsRow;
begin
  NewRow := NewSynonymsRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  NewRow.SynonymName := SynonymName;
  NewRow.TableCatalogName := TableCatalogName;
  NewRow.TableSchemaName := TableSchemaName;
  NewRow.TableName := TableName;
  AddSynonymsRow(NewRow);
end;

function TSynonymsTable.NewSynonymsRow: TSynonymsRow;
begin
  Result := TSynonymsRow(NewRow);
end;

procedure TSynonymsTable.RemoveSynonymsRow(Row: TSynonymsRow);
begin
  Rows.Remove(Row);
end;

function TSynonymsTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TSynonymsRow.Create(Builder);
end;

function TSynonymsTable.GetRowType: System.Type;
begin
  Result := typeof(TSynonymsRow);
end;

procedure TSynonymsTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXSynonymsColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXSynonymsColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
  FColumnSynonymName := DataColumn.Create(TDBXSynonymsColumns.SynonymName, typeof(WideString));
  FColumnSynonymName.Caption := SSynonymName;
  Columns.Add(FColumnSynonymName);
  FColumnTableCatalogName := DataColumn.Create(TDBXSynonymsColumns.TableCatalogName, typeof(WideString));
  FColumnTableCatalogName.Caption := STableCatalogName;
  Columns.Add(FColumnTableCatalogName);
  FColumnTableSchemaName := DataColumn.Create(TDBXSynonymsColumns.TableSchemaName, typeof(WideString));
  FColumnTableSchemaName.Caption := STableSchemaName;
  Columns.Add(FColumnTableSchemaName);
  FColumnTableName := DataColumn.Create(TDBXSynonymsColumns.TableName, typeof(WideString));
  FColumnTableName.Caption := STableName;
  Columns.Add(FColumnTableName);
end;

procedure TSynonymsTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXSynonymsColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXSynonymsColumns.SchemaName];
  FColumnSynonymName := Columns[TDBXSynonymsColumns.SynonymName];
  FColumnTableCatalogName := Columns[TDBXSynonymsColumns.TableCatalogName];
  FColumnTableSchemaName := Columns[TDBXSynonymsColumns.TableSchemaName];
  FColumnTableName := Columns[TDBXSynonymsColumns.TableName];
end;

constructor TColumnsRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableColumns := TColumnsTable(Table);
end;

function TColumnsRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTableColumns.CatalogNameColumn);
end;

procedure TColumnsRow.SetCatalogNameNull;
begin
  Item[FTableColumns.CatalogNameColumn] := DBNull.Value;
end;

function TColumnsRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTableColumns.SchemaNameColumn);
end;

procedure TColumnsRow.SetSchemaNameNull;
begin
  Item[FTableColumns.SchemaNameColumn] := DBNull.Value;
end;

function TColumnsRow.IsTableNameNull: Boolean;
begin
  Result := IsNull(FTableColumns.TableNameColumn);
end;

procedure TColumnsRow.SetTableNameNull;
begin
  Item[FTableColumns.TableNameColumn] := DBNull.Value;
end;

function TColumnsRow.IsColumnNameNull: Boolean;
begin
  Result := IsNull(FTableColumns.ColumnNameColumn);
end;

procedure TColumnsRow.SetColumnNameNull;
begin
  Item[FTableColumns.ColumnNameColumn] := DBNull.Value;
end;

function TColumnsRow.IsTypeNameNull: Boolean;
begin
  Result := IsNull(FTableColumns.TypeNameColumn);
end;

procedure TColumnsRow.SetTypeNameNull;
begin
  Item[FTableColumns.TypeNameColumn] := DBNull.Value;
end;

function TColumnsRow.IsPrecisionNull: Boolean;
begin
  Result := IsNull(FTableColumns.PrecisionColumn);
end;

procedure TColumnsRow.SetPrecisionNull;
begin
  Item[FTableColumns.PrecisionColumn] := DBNull.Value;
end;

function TColumnsRow.IsScaleNull: Boolean;
begin
  Result := IsNull(FTableColumns.ScaleColumn);
end;

procedure TColumnsRow.SetScaleNull;
begin
  Item[FTableColumns.ScaleColumn] := DBNull.Value;
end;

function TColumnsRow.IsOrdinalNull: Boolean;
begin
  Result := IsNull(FTableColumns.OrdinalColumn);
end;

procedure TColumnsRow.SetOrdinalNull;
begin
  Item[FTableColumns.OrdinalColumn] := DBNull.Value;
end;

function TColumnsRow.IsDefaultValueNull: Boolean;
begin
  Result := IsNull(FTableColumns.DefaultValueColumn);
end;

procedure TColumnsRow.SetDefaultValueNull;
begin
  Item[FTableColumns.DefaultValueColumn] := DBNull.Value;
end;

function TColumnsRow.IsIsNullableNull: Boolean;
begin
  Result := IsNull(FTableColumns.IsNullableColumn);
end;

procedure TColumnsRow.SetIsNullableNull;
begin
  Item[FTableColumns.IsNullableColumn] := DBNull.Value;
end;

function TColumnsRow.IsIsAutoIncrementNull: Boolean;
begin
  Result := IsNull(FTableColumns.IsAutoIncrementColumn);
end;

procedure TColumnsRow.SetIsAutoIncrementNull;
begin
  Item[FTableColumns.IsAutoIncrementColumn] := DBNull.Value;
end;

function TColumnsRow.IsMaxInlineNull: Boolean;
begin
  Result := IsNull(FTableColumns.MaxInlineColumn);
end;

procedure TColumnsRow.SetMaxInlineNull;
begin
  Item[FTableColumns.MaxInlineColumn] := DBNull.Value;
end;

function TColumnsRow.IsDbxDataTypeNull: Boolean;
begin
  Result := IsNull(FTableColumns.DbxDataTypeColumn);
end;

procedure TColumnsRow.SetDbxDataTypeNull;
begin
  Item[FTableColumns.DbxDataTypeColumn] := DBNull.Value;
end;

function TColumnsRow.IsIsFixedLengthNull: Boolean;
begin
  Result := IsNull(FTableColumns.IsFixedLengthColumn);
end;

procedure TColumnsRow.SetIsFixedLengthNull;
begin
  Item[FTableColumns.IsFixedLengthColumn] := DBNull.Value;
end;

function TColumnsRow.IsIsUnicodeNull: Boolean;
begin
  Result := IsNull(FTableColumns.IsUnicodeColumn);
end;

procedure TColumnsRow.SetIsUnicodeNull;
begin
  Item[FTableColumns.IsUnicodeColumn] := DBNull.Value;
end;

function TColumnsRow.IsIsLongNull: Boolean;
begin
  Result := IsNull(FTableColumns.IsLongColumn);
end;

procedure TColumnsRow.SetIsLongNull;
begin
  Item[FTableColumns.IsLongColumn] := DBNull.Value;
end;

function TColumnsRow.IsIsUnsignedNull: Boolean;
begin
  Result := IsNull(FTableColumns.IsUnsignedColumn);
end;

procedure TColumnsRow.SetIsUnsignedNull;
begin
  Item[FTableColumns.IsUnsignedColumn] := DBNull.Value;
end;

function TColumnsRow.GetCatalogName: WideString;
begin
  Result := Item[FTableColumns.CatalogNameColumn] as WideString;
end;

procedure TColumnsRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTableColumns.CatalogNameColumn] := TObject(NewValue);
end;

function TColumnsRow.GetSchemaName: WideString;
begin
  Result := Item[FTableColumns.SchemaNameColumn] as WideString;
end;

procedure TColumnsRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTableColumns.SchemaNameColumn] := TObject(NewValue);
end;

function TColumnsRow.GetTableName: WideString;
begin
  Result := Item[FTableColumns.TableNameColumn] as WideString;
end;

procedure TColumnsRow.SetTableName(NewValue: WideString);
begin
  Item[FTableColumns.TableNameColumn] := TObject(NewValue);
end;

function TColumnsRow.GetColumnName: WideString;
begin
  Result := Item[FTableColumns.ColumnNameColumn] as WideString;
end;

procedure TColumnsRow.SetColumnName(NewValue: WideString);
begin
  Item[FTableColumns.ColumnNameColumn] := TObject(NewValue);
end;

function TColumnsRow.GetTypeName: WideString;
begin
  Result := Item[FTableColumns.TypeNameColumn] as WideString;
end;

procedure TColumnsRow.SetTypeName(NewValue: WideString);
begin
  Item[FTableColumns.TypeNameColumn] := TObject(NewValue);
end;

function TColumnsRow.GetPrecision: Integer;
begin
  Result := Item[FTableColumns.PrecisionColumn] as Integer;
end;

procedure TColumnsRow.SetPrecision(NewValue: Integer);
begin
  Item[FTableColumns.PrecisionColumn] := TObject(NewValue);
end;

function TColumnsRow.GetScale: Integer;
begin
  Result := Item[FTableColumns.ScaleColumn] as Integer;
end;

procedure TColumnsRow.SetScale(NewValue: Integer);
begin
  Item[FTableColumns.ScaleColumn] := TObject(NewValue);
end;

function TColumnsRow.GetOrdinal: Integer;
begin
  Result := Item[FTableColumns.OrdinalColumn] as Integer;
end;

procedure TColumnsRow.SetOrdinal(NewValue: Integer);
begin
  Item[FTableColumns.OrdinalColumn] := TObject(NewValue);
end;

function TColumnsRow.GetDefaultValue: WideString;
begin
  Result := Item[FTableColumns.DefaultValueColumn] as WideString;
end;

procedure TColumnsRow.SetDefaultValue(NewValue: WideString);
begin
  Item[FTableColumns.DefaultValueColumn] := TObject(NewValue);
end;

function TColumnsRow.GetIsNullable: Boolean;
begin
  Result := Item[FTableColumns.IsNullableColumn] as Boolean;
end;

procedure TColumnsRow.SetIsNullable(NewValue: Boolean);
begin
  Item[FTableColumns.IsNullableColumn] := TObject(NewValue);
end;

function TColumnsRow.GetIsAutoIncrement: Boolean;
begin
  Result := Item[FTableColumns.IsAutoIncrementColumn] as Boolean;
end;

procedure TColumnsRow.SetIsAutoIncrement(NewValue: Boolean);
begin
  Item[FTableColumns.IsAutoIncrementColumn] := TObject(NewValue);
end;

function TColumnsRow.GetMaxInline: Integer;
begin
  Result := Item[FTableColumns.MaxInlineColumn] as Integer;
end;

procedure TColumnsRow.SetMaxInline(NewValue: Integer);
begin
  Item[FTableColumns.MaxInlineColumn] := TObject(NewValue);
end;

function TColumnsRow.GetDbxDataType: Integer;
begin
  Result := Item[FTableColumns.DbxDataTypeColumn] as Integer;
end;

procedure TColumnsRow.SetDbxDataType(NewValue: Integer);
begin
  Item[FTableColumns.DbxDataTypeColumn] := TObject(NewValue);
end;

function TColumnsRow.GetIsFixedLength: Boolean;
begin
  Result := Item[FTableColumns.IsFixedLengthColumn] as Boolean;
end;

procedure TColumnsRow.SetIsFixedLength(NewValue: Boolean);
begin
  Item[FTableColumns.IsFixedLengthColumn] := TObject(NewValue);
end;

function TColumnsRow.GetIsUnicode: Boolean;
begin
  Result := Item[FTableColumns.IsUnicodeColumn] as Boolean;
end;

procedure TColumnsRow.SetIsUnicode(NewValue: Boolean);
begin
  Item[FTableColumns.IsUnicodeColumn] := TObject(NewValue);
end;

function TColumnsRow.GetIsLong: Boolean;
begin
  Result := Item[FTableColumns.IsLongColumn] as Boolean;
end;

procedure TColumnsRow.SetIsLong(NewValue: Boolean);
begin
  Item[FTableColumns.IsLongColumn] := TObject(NewValue);
end;

function TColumnsRow.GetIsUnsigned: Boolean;
begin
  Result := Item[FTableColumns.IsUnsignedColumn] as Boolean;
end;

procedure TColumnsRow.SetIsUnsigned(NewValue: Boolean);
begin
  Item[FTableColumns.IsUnsignedColumn] := TObject(NewValue);
end;

constructor TColumnsTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.Columns;
  BeginInit();
  InitClass();
  EndInit();
end;

function TColumnsTable.Clone: DataTable;
var
  NewClone: TColumnsTable;
begin
  NewClone := TColumnsTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TColumnsTable.CreateInstance: DataTable;
begin
  Result := TColumnsTable.Create;
end;

function TColumnsTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TColumnsTable.GetItem(Index: Integer): TColumnsRow;
begin
  Result := TColumnsRow(Rows.Item[Index]);
end;

function TColumnsTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TColumnsTable.AddColumnsRow(Row: TColumnsRow);
begin
  Rows.Add(Row);
end;

procedure TColumnsTable.AddColumnsRow(CatalogName: WideString; SchemaName: WideString; TableName: WideString; ColumnName: WideString; TypeName: WideString; Precision: Integer; Scale: Integer; Ordinal: Integer; DefaultValue: WideString; IsNullable: Boolean; IsAutoIncrement: Boolean; MaxInline: Integer; DbxDataType: Integer; IsFixedLength: Boolean; IsUnicode: Boolean; IsLong: Boolean; IsUnsigned: Boolean);
var
  NewRow: TColumnsRow;
begin
  NewRow := NewColumnsRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  NewRow.TableName := TableName;
  NewRow.ColumnName := ColumnName;
  NewRow.TypeName := TypeName;
  NewRow.Precision := Precision;
  NewRow.Scale := Scale;
  NewRow.Ordinal := Ordinal;
  NewRow.DefaultValue := DefaultValue;
  NewRow.IsNullable := IsNullable;
  NewRow.IsAutoIncrement := IsAutoIncrement;
  NewRow.MaxInline := MaxInline;
  NewRow.DbxDataType := DbxDataType;
  NewRow.IsFixedLength := IsFixedLength;
  NewRow.IsUnicode := IsUnicode;
  NewRow.IsLong := IsLong;
  NewRow.IsUnsigned := IsUnsigned;
  AddColumnsRow(NewRow);
end;

function TColumnsTable.NewColumnsRow: TColumnsRow;
begin
  Result := TColumnsRow(NewRow);
end;

procedure TColumnsTable.RemoveColumnsRow(Row: TColumnsRow);
begin
  Rows.Remove(Row);
end;

function TColumnsTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TColumnsRow.Create(Builder);
end;

function TColumnsTable.GetRowType: System.Type;
begin
  Result := typeof(TColumnsRow);
end;

procedure TColumnsTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXColumnsColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXColumnsColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
  FColumnTableName := DataColumn.Create(TDBXColumnsColumns.TableName, typeof(WideString));
  FColumnTableName.Caption := STableName;
  Columns.Add(FColumnTableName);
  FColumnColumnName := DataColumn.Create(TDBXColumnsColumns.ColumnName, typeof(WideString));
  FColumnColumnName.Caption := SColumnName;
  Columns.Add(FColumnColumnName);
  FColumnTypeName := DataColumn.Create(TDBXColumnsColumns.TypeName, typeof(WideString));
  FColumnTypeName.Caption := STypeName;
  Columns.Add(FColumnTypeName);
  FColumnPrecision := DataColumn.Create(TDBXColumnsColumns.Precision, typeof(Integer));
  FColumnPrecision.Caption := SPrecision;
  Columns.Add(FColumnPrecision);
  FColumnScale := DataColumn.Create(TDBXColumnsColumns.Scale, typeof(Integer));
  FColumnScale.Caption := SScale;
  Columns.Add(FColumnScale);
  FColumnOrdinal := DataColumn.Create(TDBXColumnsColumns.Ordinal, typeof(Integer));
  FColumnOrdinal.Caption := SOrdinal;
  Columns.Add(FColumnOrdinal);
  FColumnDefaultValue := DataColumn.Create(TDBXColumnsColumns.DefaultValue, typeof(WideString));
  FColumnDefaultValue.Caption := SDefaultValue;
  Columns.Add(FColumnDefaultValue);
  FColumnIsNullable := DataColumn.Create(TDBXColumnsColumns.IsNullable, typeof(Boolean));
  FColumnIsNullable.Caption := SIsNullable;
  Columns.Add(FColumnIsNullable);
  FColumnIsAutoIncrement := DataColumn.Create(TDBXColumnsColumns.IsAutoIncrement, typeof(Boolean));
  FColumnIsAutoIncrement.Caption := SIsAutoIncrement;
  Columns.Add(FColumnIsAutoIncrement);
  FColumnMaxInline := DataColumn.Create(TDBXColumnsColumns.MaxInline, typeof(Integer));
  FColumnMaxInline.Caption := SMaxInline;
  Columns.Add(FColumnMaxInline);
  FColumnDbxDataType := DataColumn.Create(TDBXColumnsColumns.DbxDataType, typeof(Integer));
  FColumnDbxDataType.Caption := SDbxDataType;
  Columns.Add(FColumnDbxDataType);
  FColumnIsFixedLength := DataColumn.Create(TDBXColumnsColumns.IsFixedLength, typeof(Boolean));
  FColumnIsFixedLength.Caption := SIsFixedLength;
  Columns.Add(FColumnIsFixedLength);
  FColumnIsUnicode := DataColumn.Create(TDBXColumnsColumns.IsUnicode, typeof(Boolean));
  FColumnIsUnicode.Caption := SIsUnicode;
  Columns.Add(FColumnIsUnicode);
  FColumnIsLong := DataColumn.Create(TDBXColumnsColumns.IsLong, typeof(Boolean));
  FColumnIsLong.Caption := SIsLong;
  Columns.Add(FColumnIsLong);
  FColumnIsUnsigned := DataColumn.Create(TDBXColumnsColumns.IsUnsigned, typeof(Boolean));
  FColumnIsUnsigned.Caption := SIsUnsigned;
  Columns.Add(FColumnIsUnsigned);
end;

procedure TColumnsTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXColumnsColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXColumnsColumns.SchemaName];
  FColumnTableName := Columns[TDBXColumnsColumns.TableName];
  FColumnColumnName := Columns[TDBXColumnsColumns.ColumnName];
  FColumnTypeName := Columns[TDBXColumnsColumns.TypeName];
  FColumnPrecision := Columns[TDBXColumnsColumns.Precision];
  FColumnScale := Columns[TDBXColumnsColumns.Scale];
  FColumnOrdinal := Columns[TDBXColumnsColumns.Ordinal];
  FColumnDefaultValue := Columns[TDBXColumnsColumns.DefaultValue];
  FColumnIsNullable := Columns[TDBXColumnsColumns.IsNullable];
  FColumnIsAutoIncrement := Columns[TDBXColumnsColumns.IsAutoIncrement];
  FColumnMaxInline := Columns[TDBXColumnsColumns.MaxInline];
  FColumnDbxDataType := Columns[TDBXColumnsColumns.DbxDataType];
  FColumnIsFixedLength := Columns[TDBXColumnsColumns.IsFixedLength];
  FColumnIsUnicode := Columns[TDBXColumnsColumns.IsUnicode];
  FColumnIsLong := Columns[TDBXColumnsColumns.IsLong];
  FColumnIsUnsigned := Columns[TDBXColumnsColumns.IsUnsigned];
end;

constructor TColumnConstraintsRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableColumnConstraints := TColumnConstraintsTable(Table);
end;

function TColumnConstraintsRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTableColumnConstraints.CatalogNameColumn);
end;

procedure TColumnConstraintsRow.SetCatalogNameNull;
begin
  Item[FTableColumnConstraints.CatalogNameColumn] := DBNull.Value;
end;

function TColumnConstraintsRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTableColumnConstraints.SchemaNameColumn);
end;

procedure TColumnConstraintsRow.SetSchemaNameNull;
begin
  Item[FTableColumnConstraints.SchemaNameColumn] := DBNull.Value;
end;

function TColumnConstraintsRow.IsTableNameNull: Boolean;
begin
  Result := IsNull(FTableColumnConstraints.TableNameColumn);
end;

procedure TColumnConstraintsRow.SetTableNameNull;
begin
  Item[FTableColumnConstraints.TableNameColumn] := DBNull.Value;
end;

function TColumnConstraintsRow.IsConstraintNameNull: Boolean;
begin
  Result := IsNull(FTableColumnConstraints.ConstraintNameColumn);
end;

procedure TColumnConstraintsRow.SetConstraintNameNull;
begin
  Item[FTableColumnConstraints.ConstraintNameColumn] := DBNull.Value;
end;

function TColumnConstraintsRow.IsColumnNameNull: Boolean;
begin
  Result := IsNull(FTableColumnConstraints.ColumnNameColumn);
end;

procedure TColumnConstraintsRow.SetColumnNameNull;
begin
  Item[FTableColumnConstraints.ColumnNameColumn] := DBNull.Value;
end;

function TColumnConstraintsRow.GetCatalogName: WideString;
begin
  Result := Item[FTableColumnConstraints.CatalogNameColumn] as WideString;
end;

procedure TColumnConstraintsRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTableColumnConstraints.CatalogNameColumn] := TObject(NewValue);
end;

function TColumnConstraintsRow.GetSchemaName: WideString;
begin
  Result := Item[FTableColumnConstraints.SchemaNameColumn] as WideString;
end;

procedure TColumnConstraintsRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTableColumnConstraints.SchemaNameColumn] := TObject(NewValue);
end;

function TColumnConstraintsRow.GetTableName: WideString;
begin
  Result := Item[FTableColumnConstraints.TableNameColumn] as WideString;
end;

procedure TColumnConstraintsRow.SetTableName(NewValue: WideString);
begin
  Item[FTableColumnConstraints.TableNameColumn] := TObject(NewValue);
end;

function TColumnConstraintsRow.GetConstraintName: WideString;
begin
  Result := Item[FTableColumnConstraints.ConstraintNameColumn] as WideString;
end;

procedure TColumnConstraintsRow.SetConstraintName(NewValue: WideString);
begin
  Item[FTableColumnConstraints.ConstraintNameColumn] := TObject(NewValue);
end;

function TColumnConstraintsRow.GetColumnName: WideString;
begin
  Result := Item[FTableColumnConstraints.ColumnNameColumn] as WideString;
end;

procedure TColumnConstraintsRow.SetColumnName(NewValue: WideString);
begin
  Item[FTableColumnConstraints.ColumnNameColumn] := TObject(NewValue);
end;

constructor TColumnConstraintsTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.ColumnConstraints;
  BeginInit();
  InitClass();
  EndInit();
end;

function TColumnConstraintsTable.Clone: DataTable;
var
  NewClone: TColumnConstraintsTable;
begin
  NewClone := TColumnConstraintsTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TColumnConstraintsTable.CreateInstance: DataTable;
begin
  Result := TColumnConstraintsTable.Create;
end;

function TColumnConstraintsTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TColumnConstraintsTable.GetItem(Index: Integer): TColumnConstraintsRow;
begin
  Result := TColumnConstraintsRow(Rows.Item[Index]);
end;

function TColumnConstraintsTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TColumnConstraintsTable.AddColumnConstraintsRow(Row: TColumnConstraintsRow);
begin
  Rows.Add(Row);
end;

procedure TColumnConstraintsTable.AddColumnConstraintsRow(CatalogName: WideString; SchemaName: WideString; TableName: WideString; ConstraintName: WideString; ColumnName: WideString);
var
  NewRow: TColumnConstraintsRow;
begin
  NewRow := NewColumnConstraintsRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  NewRow.TableName := TableName;
  NewRow.ConstraintName := ConstraintName;
  NewRow.ColumnName := ColumnName;
  AddColumnConstraintsRow(NewRow);
end;

function TColumnConstraintsTable.NewColumnConstraintsRow: TColumnConstraintsRow;
begin
  Result := TColumnConstraintsRow(NewRow);
end;

procedure TColumnConstraintsTable.RemoveColumnConstraintsRow(Row: TColumnConstraintsRow);
begin
  Rows.Remove(Row);
end;

function TColumnConstraintsTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TColumnConstraintsRow.Create(Builder);
end;

function TColumnConstraintsTable.GetRowType: System.Type;
begin
  Result := typeof(TColumnConstraintsRow);
end;

procedure TColumnConstraintsTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXColumnConstraintsColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXColumnConstraintsColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
  FColumnTableName := DataColumn.Create(TDBXColumnConstraintsColumns.TableName, typeof(WideString));
  FColumnTableName.Caption := STableName;
  Columns.Add(FColumnTableName);
  FColumnConstraintName := DataColumn.Create(TDBXColumnConstraintsColumns.ConstraintName, typeof(WideString));
  FColumnConstraintName.Caption := SConstraintName;
  Columns.Add(FColumnConstraintName);
  FColumnColumnName := DataColumn.Create(TDBXColumnConstraintsColumns.ColumnName, typeof(WideString));
  FColumnColumnName.Caption := SColumnName;
  Columns.Add(FColumnColumnName);
end;

procedure TColumnConstraintsTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXColumnConstraintsColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXColumnConstraintsColumns.SchemaName];
  FColumnTableName := Columns[TDBXColumnConstraintsColumns.TableName];
  FColumnConstraintName := Columns[TDBXColumnConstraintsColumns.ConstraintName];
  FColumnColumnName := Columns[TDBXColumnConstraintsColumns.ColumnName];
end;

constructor TIndexesRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableIndexes := TIndexesTable(Table);
end;

function TIndexesRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTableIndexes.CatalogNameColumn);
end;

procedure TIndexesRow.SetCatalogNameNull;
begin
  Item[FTableIndexes.CatalogNameColumn] := DBNull.Value;
end;

function TIndexesRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTableIndexes.SchemaNameColumn);
end;

procedure TIndexesRow.SetSchemaNameNull;
begin
  Item[FTableIndexes.SchemaNameColumn] := DBNull.Value;
end;

function TIndexesRow.IsTableNameNull: Boolean;
begin
  Result := IsNull(FTableIndexes.TableNameColumn);
end;

procedure TIndexesRow.SetTableNameNull;
begin
  Item[FTableIndexes.TableNameColumn] := DBNull.Value;
end;

function TIndexesRow.IsIndexNameNull: Boolean;
begin
  Result := IsNull(FTableIndexes.IndexNameColumn);
end;

procedure TIndexesRow.SetIndexNameNull;
begin
  Item[FTableIndexes.IndexNameColumn] := DBNull.Value;
end;

function TIndexesRow.IsConstraintNameNull: Boolean;
begin
  Result := IsNull(FTableIndexes.ConstraintNameColumn);
end;

procedure TIndexesRow.SetConstraintNameNull;
begin
  Item[FTableIndexes.ConstraintNameColumn] := DBNull.Value;
end;

function TIndexesRow.IsIsPrimaryNull: Boolean;
begin
  Result := IsNull(FTableIndexes.IsPrimaryColumn);
end;

procedure TIndexesRow.SetIsPrimaryNull;
begin
  Item[FTableIndexes.IsPrimaryColumn] := DBNull.Value;
end;

function TIndexesRow.IsIsUniqueNull: Boolean;
begin
  Result := IsNull(FTableIndexes.IsUniqueColumn);
end;

procedure TIndexesRow.SetIsUniqueNull;
begin
  Item[FTableIndexes.IsUniqueColumn] := DBNull.Value;
end;

function TIndexesRow.IsIsAscendingNull: Boolean;
begin
  Result := IsNull(FTableIndexes.IsAscendingColumn);
end;

procedure TIndexesRow.SetIsAscendingNull;
begin
  Item[FTableIndexes.IsAscendingColumn] := DBNull.Value;
end;

function TIndexesRow.GetCatalogName: WideString;
begin
  Result := Item[FTableIndexes.CatalogNameColumn] as WideString;
end;

procedure TIndexesRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTableIndexes.CatalogNameColumn] := TObject(NewValue);
end;

function TIndexesRow.GetSchemaName: WideString;
begin
  Result := Item[FTableIndexes.SchemaNameColumn] as WideString;
end;

procedure TIndexesRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTableIndexes.SchemaNameColumn] := TObject(NewValue);
end;

function TIndexesRow.GetTableName: WideString;
begin
  Result := Item[FTableIndexes.TableNameColumn] as WideString;
end;

procedure TIndexesRow.SetTableName(NewValue: WideString);
begin
  Item[FTableIndexes.TableNameColumn] := TObject(NewValue);
end;

function TIndexesRow.GetIndexName: WideString;
begin
  Result := Item[FTableIndexes.IndexNameColumn] as WideString;
end;

procedure TIndexesRow.SetIndexName(NewValue: WideString);
begin
  Item[FTableIndexes.IndexNameColumn] := TObject(NewValue);
end;

function TIndexesRow.GetConstraintName: WideString;
begin
  Result := Item[FTableIndexes.ConstraintNameColumn] as WideString;
end;

procedure TIndexesRow.SetConstraintName(NewValue: WideString);
begin
  Item[FTableIndexes.ConstraintNameColumn] := TObject(NewValue);
end;

function TIndexesRow.GetIsPrimary: Boolean;
begin
  Result := Item[FTableIndexes.IsPrimaryColumn] as Boolean;
end;

procedure TIndexesRow.SetIsPrimary(NewValue: Boolean);
begin
  Item[FTableIndexes.IsPrimaryColumn] := TObject(NewValue);
end;

function TIndexesRow.GetIsUnique: Boolean;
begin
  Result := Item[FTableIndexes.IsUniqueColumn] as Boolean;
end;

procedure TIndexesRow.SetIsUnique(NewValue: Boolean);
begin
  Item[FTableIndexes.IsUniqueColumn] := TObject(NewValue);
end;

function TIndexesRow.GetIsAscending: Boolean;
begin
  Result := Item[FTableIndexes.IsAscendingColumn] as Boolean;
end;

procedure TIndexesRow.SetIsAscending(NewValue: Boolean);
begin
  Item[FTableIndexes.IsAscendingColumn] := TObject(NewValue);
end;

constructor TIndexesTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.Indexes;
  BeginInit();
  InitClass();
  EndInit();
end;

function TIndexesTable.Clone: DataTable;
var
  NewClone: TIndexesTable;
begin
  NewClone := TIndexesTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TIndexesTable.CreateInstance: DataTable;
begin
  Result := TIndexesTable.Create;
end;

function TIndexesTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TIndexesTable.GetItem(Index: Integer): TIndexesRow;
begin
  Result := TIndexesRow(Rows.Item[Index]);
end;

function TIndexesTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TIndexesTable.AddIndexesRow(Row: TIndexesRow);
begin
  Rows.Add(Row);
end;

procedure TIndexesTable.AddIndexesRow(CatalogName: WideString; SchemaName: WideString; TableName: WideString; IndexName: WideString; ConstraintName: WideString; IsPrimary: Boolean; IsUnique: Boolean; IsAscending: Boolean);
var
  NewRow: TIndexesRow;
begin
  NewRow := NewIndexesRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  NewRow.TableName := TableName;
  NewRow.IndexName := IndexName;
  NewRow.ConstraintName := ConstraintName;
  NewRow.IsPrimary := IsPrimary;
  NewRow.IsUnique := IsUnique;
  NewRow.IsAscending := IsAscending;
  AddIndexesRow(NewRow);
end;

function TIndexesTable.NewIndexesRow: TIndexesRow;
begin
  Result := TIndexesRow(NewRow);
end;

procedure TIndexesTable.RemoveIndexesRow(Row: TIndexesRow);
begin
  Rows.Remove(Row);
end;

function TIndexesTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TIndexesRow.Create(Builder);
end;

function TIndexesTable.GetRowType: System.Type;
begin
  Result := typeof(TIndexesRow);
end;

procedure TIndexesTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXIndexesColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXIndexesColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
  FColumnTableName := DataColumn.Create(TDBXIndexesColumns.TableName, typeof(WideString));
  FColumnTableName.Caption := STableName;
  Columns.Add(FColumnTableName);
  FColumnIndexName := DataColumn.Create(TDBXIndexesColumns.IndexName, typeof(WideString));
  FColumnIndexName.Caption := SIndexName;
  Columns.Add(FColumnIndexName);
  FColumnConstraintName := DataColumn.Create(TDBXIndexesColumns.ConstraintName, typeof(WideString));
  FColumnConstraintName.Caption := SConstraintName;
  Columns.Add(FColumnConstraintName);
  FColumnIsPrimary := DataColumn.Create(TDBXIndexesColumns.IsPrimary, typeof(Boolean));
  FColumnIsPrimary.Caption := SIsPrimary;
  Columns.Add(FColumnIsPrimary);
  FColumnIsUnique := DataColumn.Create(TDBXIndexesColumns.IsUnique, typeof(Boolean));
  FColumnIsUnique.Caption := SIsUnique;
  Columns.Add(FColumnIsUnique);
  FColumnIsAscending := DataColumn.Create(TDBXIndexesColumns.IsAscending, typeof(Boolean));
  FColumnIsAscending.Caption := SIsAscending;
  Columns.Add(FColumnIsAscending);
end;

procedure TIndexesTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXIndexesColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXIndexesColumns.SchemaName];
  FColumnTableName := Columns[TDBXIndexesColumns.TableName];
  FColumnIndexName := Columns[TDBXIndexesColumns.IndexName];
  FColumnConstraintName := Columns[TDBXIndexesColumns.ConstraintName];
  FColumnIsPrimary := Columns[TDBXIndexesColumns.IsPrimary];
  FColumnIsUnique := Columns[TDBXIndexesColumns.IsUnique];
  FColumnIsAscending := Columns[TDBXIndexesColumns.IsAscending];
end;

constructor TIndexColumnsRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableIndexColumns := TIndexColumnsTable(Table);
end;

function TIndexColumnsRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTableIndexColumns.CatalogNameColumn);
end;

procedure TIndexColumnsRow.SetCatalogNameNull;
begin
  Item[FTableIndexColumns.CatalogNameColumn] := DBNull.Value;
end;

function TIndexColumnsRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTableIndexColumns.SchemaNameColumn);
end;

procedure TIndexColumnsRow.SetSchemaNameNull;
begin
  Item[FTableIndexColumns.SchemaNameColumn] := DBNull.Value;
end;

function TIndexColumnsRow.IsTableNameNull: Boolean;
begin
  Result := IsNull(FTableIndexColumns.TableNameColumn);
end;

procedure TIndexColumnsRow.SetTableNameNull;
begin
  Item[FTableIndexColumns.TableNameColumn] := DBNull.Value;
end;

function TIndexColumnsRow.IsIndexNameNull: Boolean;
begin
  Result := IsNull(FTableIndexColumns.IndexNameColumn);
end;

procedure TIndexColumnsRow.SetIndexNameNull;
begin
  Item[FTableIndexColumns.IndexNameColumn] := DBNull.Value;
end;

function TIndexColumnsRow.IsColumnNameNull: Boolean;
begin
  Result := IsNull(FTableIndexColumns.ColumnNameColumn);
end;

procedure TIndexColumnsRow.SetColumnNameNull;
begin
  Item[FTableIndexColumns.ColumnNameColumn] := DBNull.Value;
end;

function TIndexColumnsRow.IsOrdinalNull: Boolean;
begin
  Result := IsNull(FTableIndexColumns.OrdinalColumn);
end;

procedure TIndexColumnsRow.SetOrdinalNull;
begin
  Item[FTableIndexColumns.OrdinalColumn] := DBNull.Value;
end;

function TIndexColumnsRow.IsIsAscendingNull: Boolean;
begin
  Result := IsNull(FTableIndexColumns.IsAscendingColumn);
end;

procedure TIndexColumnsRow.SetIsAscendingNull;
begin
  Item[FTableIndexColumns.IsAscendingColumn] := DBNull.Value;
end;

function TIndexColumnsRow.GetCatalogName: WideString;
begin
  Result := Item[FTableIndexColumns.CatalogNameColumn] as WideString;
end;

procedure TIndexColumnsRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTableIndexColumns.CatalogNameColumn] := TObject(NewValue);
end;

function TIndexColumnsRow.GetSchemaName: WideString;
begin
  Result := Item[FTableIndexColumns.SchemaNameColumn] as WideString;
end;

procedure TIndexColumnsRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTableIndexColumns.SchemaNameColumn] := TObject(NewValue);
end;

function TIndexColumnsRow.GetTableName: WideString;
begin
  Result := Item[FTableIndexColumns.TableNameColumn] as WideString;
end;

procedure TIndexColumnsRow.SetTableName(NewValue: WideString);
begin
  Item[FTableIndexColumns.TableNameColumn] := TObject(NewValue);
end;

function TIndexColumnsRow.GetIndexName: WideString;
begin
  Result := Item[FTableIndexColumns.IndexNameColumn] as WideString;
end;

procedure TIndexColumnsRow.SetIndexName(NewValue: WideString);
begin
  Item[FTableIndexColumns.IndexNameColumn] := TObject(NewValue);
end;

function TIndexColumnsRow.GetColumnName: WideString;
begin
  Result := Item[FTableIndexColumns.ColumnNameColumn] as WideString;
end;

procedure TIndexColumnsRow.SetColumnName(NewValue: WideString);
begin
  Item[FTableIndexColumns.ColumnNameColumn] := TObject(NewValue);
end;

function TIndexColumnsRow.GetOrdinal: Integer;
begin
  Result := Item[FTableIndexColumns.OrdinalColumn] as Integer;
end;

procedure TIndexColumnsRow.SetOrdinal(NewValue: Integer);
begin
  Item[FTableIndexColumns.OrdinalColumn] := TObject(NewValue);
end;

function TIndexColumnsRow.GetIsAscending: Boolean;
begin
  Result := Item[FTableIndexColumns.IsAscendingColumn] as Boolean;
end;

procedure TIndexColumnsRow.SetIsAscending(NewValue: Boolean);
begin
  Item[FTableIndexColumns.IsAscendingColumn] := TObject(NewValue);
end;

constructor TIndexColumnsTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.IndexColumns;
  BeginInit();
  InitClass();
  EndInit();
end;

function TIndexColumnsTable.Clone: DataTable;
var
  NewClone: TIndexColumnsTable;
begin
  NewClone := TIndexColumnsTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TIndexColumnsTable.CreateInstance: DataTable;
begin
  Result := TIndexColumnsTable.Create;
end;

function TIndexColumnsTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TIndexColumnsTable.GetItem(Index: Integer): TIndexColumnsRow;
begin
  Result := TIndexColumnsRow(Rows.Item[Index]);
end;

function TIndexColumnsTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TIndexColumnsTable.AddIndexColumnsRow(Row: TIndexColumnsRow);
begin
  Rows.Add(Row);
end;

procedure TIndexColumnsTable.AddIndexColumnsRow(CatalogName: WideString; SchemaName: WideString; TableName: WideString; IndexName: WideString; ColumnName: WideString; Ordinal: Integer; IsAscending: Boolean);
var
  NewRow: TIndexColumnsRow;
begin
  NewRow := NewIndexColumnsRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  NewRow.TableName := TableName;
  NewRow.IndexName := IndexName;
  NewRow.ColumnName := ColumnName;
  NewRow.Ordinal := Ordinal;
  NewRow.IsAscending := IsAscending;
  AddIndexColumnsRow(NewRow);
end;

function TIndexColumnsTable.NewIndexColumnsRow: TIndexColumnsRow;
begin
  Result := TIndexColumnsRow(NewRow);
end;

procedure TIndexColumnsTable.RemoveIndexColumnsRow(Row: TIndexColumnsRow);
begin
  Rows.Remove(Row);
end;

function TIndexColumnsTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TIndexColumnsRow.Create(Builder);
end;

function TIndexColumnsTable.GetRowType: System.Type;
begin
  Result := typeof(TIndexColumnsRow);
end;

procedure TIndexColumnsTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXIndexColumnsColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXIndexColumnsColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
  FColumnTableName := DataColumn.Create(TDBXIndexColumnsColumns.TableName, typeof(WideString));
  FColumnTableName.Caption := STableName;
  Columns.Add(FColumnTableName);
  FColumnIndexName := DataColumn.Create(TDBXIndexColumnsColumns.IndexName, typeof(WideString));
  FColumnIndexName.Caption := SIndexName;
  Columns.Add(FColumnIndexName);
  FColumnColumnName := DataColumn.Create(TDBXIndexColumnsColumns.ColumnName, typeof(WideString));
  FColumnColumnName.Caption := SColumnName;
  Columns.Add(FColumnColumnName);
  FColumnOrdinal := DataColumn.Create(TDBXIndexColumnsColumns.Ordinal, typeof(Integer));
  FColumnOrdinal.Caption := SOrdinal;
  Columns.Add(FColumnOrdinal);
  FColumnIsAscending := DataColumn.Create(TDBXIndexColumnsColumns.IsAscending, typeof(Boolean));
  FColumnIsAscending.Caption := SIsAscending;
  Columns.Add(FColumnIsAscending);
end;

procedure TIndexColumnsTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXIndexColumnsColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXIndexColumnsColumns.SchemaName];
  FColumnTableName := Columns[TDBXIndexColumnsColumns.TableName];
  FColumnIndexName := Columns[TDBXIndexColumnsColumns.IndexName];
  FColumnColumnName := Columns[TDBXIndexColumnsColumns.ColumnName];
  FColumnOrdinal := Columns[TDBXIndexColumnsColumns.Ordinal];
  FColumnIsAscending := Columns[TDBXIndexColumnsColumns.IsAscending];
end;

constructor TForeignKeysRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableForeignKeys := TForeignKeysTable(Table);
end;

function TForeignKeysRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTableForeignKeys.CatalogNameColumn);
end;

procedure TForeignKeysRow.SetCatalogNameNull;
begin
  Item[FTableForeignKeys.CatalogNameColumn] := DBNull.Value;
end;

function TForeignKeysRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTableForeignKeys.SchemaNameColumn);
end;

procedure TForeignKeysRow.SetSchemaNameNull;
begin
  Item[FTableForeignKeys.SchemaNameColumn] := DBNull.Value;
end;

function TForeignKeysRow.IsTableNameNull: Boolean;
begin
  Result := IsNull(FTableForeignKeys.TableNameColumn);
end;

procedure TForeignKeysRow.SetTableNameNull;
begin
  Item[FTableForeignKeys.TableNameColumn] := DBNull.Value;
end;

function TForeignKeysRow.IsForeignKeyNameNull: Boolean;
begin
  Result := IsNull(FTableForeignKeys.ForeignKeyNameColumn);
end;

procedure TForeignKeysRow.SetForeignKeyNameNull;
begin
  Item[FTableForeignKeys.ForeignKeyNameColumn] := DBNull.Value;
end;

function TForeignKeysRow.GetCatalogName: WideString;
begin
  Result := Item[FTableForeignKeys.CatalogNameColumn] as WideString;
end;

procedure TForeignKeysRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTableForeignKeys.CatalogNameColumn] := TObject(NewValue);
end;

function TForeignKeysRow.GetSchemaName: WideString;
begin
  Result := Item[FTableForeignKeys.SchemaNameColumn] as WideString;
end;

procedure TForeignKeysRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTableForeignKeys.SchemaNameColumn] := TObject(NewValue);
end;

function TForeignKeysRow.GetTableName: WideString;
begin
  Result := Item[FTableForeignKeys.TableNameColumn] as WideString;
end;

procedure TForeignKeysRow.SetTableName(NewValue: WideString);
begin
  Item[FTableForeignKeys.TableNameColumn] := TObject(NewValue);
end;

function TForeignKeysRow.GetForeignKeyName: WideString;
begin
  Result := Item[FTableForeignKeys.ForeignKeyNameColumn] as WideString;
end;

procedure TForeignKeysRow.SetForeignKeyName(NewValue: WideString);
begin
  Item[FTableForeignKeys.ForeignKeyNameColumn] := TObject(NewValue);
end;

constructor TForeignKeysTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.ForeignKeys;
  BeginInit();
  InitClass();
  EndInit();
end;

function TForeignKeysTable.Clone: DataTable;
var
  NewClone: TForeignKeysTable;
begin
  NewClone := TForeignKeysTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TForeignKeysTable.CreateInstance: DataTable;
begin
  Result := TForeignKeysTable.Create;
end;

function TForeignKeysTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TForeignKeysTable.GetItem(Index: Integer): TForeignKeysRow;
begin
  Result := TForeignKeysRow(Rows.Item[Index]);
end;

function TForeignKeysTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TForeignKeysTable.AddForeignKeysRow(Row: TForeignKeysRow);
begin
  Rows.Add(Row);
end;

procedure TForeignKeysTable.AddForeignKeysRow(CatalogName: WideString; SchemaName: WideString; TableName: WideString; ForeignKeyName: WideString);
var
  NewRow: TForeignKeysRow;
begin
  NewRow := NewForeignKeysRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  NewRow.TableName := TableName;
  NewRow.ForeignKeyName := ForeignKeyName;
  AddForeignKeysRow(NewRow);
end;

function TForeignKeysTable.NewForeignKeysRow: TForeignKeysRow;
begin
  Result := TForeignKeysRow(NewRow);
end;

procedure TForeignKeysTable.RemoveForeignKeysRow(Row: TForeignKeysRow);
begin
  Rows.Remove(Row);
end;

function TForeignKeysTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TForeignKeysRow.Create(Builder);
end;

function TForeignKeysTable.GetRowType: System.Type;
begin
  Result := typeof(TForeignKeysRow);
end;

procedure TForeignKeysTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXForeignKeysColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXForeignKeysColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
  FColumnTableName := DataColumn.Create(TDBXForeignKeysColumns.TableName, typeof(WideString));
  FColumnTableName.Caption := STableName;
  Columns.Add(FColumnTableName);
  FColumnForeignKeyName := DataColumn.Create(TDBXForeignKeysColumns.ForeignKeyName, typeof(WideString));
  FColumnForeignKeyName.Caption := SForeignKeyName;
  Columns.Add(FColumnForeignKeyName);
end;

procedure TForeignKeysTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXForeignKeysColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXForeignKeysColumns.SchemaName];
  FColumnTableName := Columns[TDBXForeignKeysColumns.TableName];
  FColumnForeignKeyName := Columns[TDBXForeignKeysColumns.ForeignKeyName];
end;

constructor TForeignKeyColumnsRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableForeignKeyColumns := TForeignKeyColumnsTable(Table);
end;

function TForeignKeyColumnsRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTableForeignKeyColumns.CatalogNameColumn);
end;

procedure TForeignKeyColumnsRow.SetCatalogNameNull;
begin
  Item[FTableForeignKeyColumns.CatalogNameColumn] := DBNull.Value;
end;

function TForeignKeyColumnsRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTableForeignKeyColumns.SchemaNameColumn);
end;

procedure TForeignKeyColumnsRow.SetSchemaNameNull;
begin
  Item[FTableForeignKeyColumns.SchemaNameColumn] := DBNull.Value;
end;

function TForeignKeyColumnsRow.IsTableNameNull: Boolean;
begin
  Result := IsNull(FTableForeignKeyColumns.TableNameColumn);
end;

procedure TForeignKeyColumnsRow.SetTableNameNull;
begin
  Item[FTableForeignKeyColumns.TableNameColumn] := DBNull.Value;
end;

function TForeignKeyColumnsRow.IsForeignKeyNameNull: Boolean;
begin
  Result := IsNull(FTableForeignKeyColumns.ForeignKeyNameColumn);
end;

procedure TForeignKeyColumnsRow.SetForeignKeyNameNull;
begin
  Item[FTableForeignKeyColumns.ForeignKeyNameColumn] := DBNull.Value;
end;

function TForeignKeyColumnsRow.IsColumnNameNull: Boolean;
begin
  Result := IsNull(FTableForeignKeyColumns.ColumnNameColumn);
end;

procedure TForeignKeyColumnsRow.SetColumnNameNull;
begin
  Item[FTableForeignKeyColumns.ColumnNameColumn] := DBNull.Value;
end;

function TForeignKeyColumnsRow.IsPrimaryCatalogNameNull: Boolean;
begin
  Result := IsNull(FTableForeignKeyColumns.PrimaryCatalogNameColumn);
end;

procedure TForeignKeyColumnsRow.SetPrimaryCatalogNameNull;
begin
  Item[FTableForeignKeyColumns.PrimaryCatalogNameColumn] := DBNull.Value;
end;

function TForeignKeyColumnsRow.IsPrimarySchemaNameNull: Boolean;
begin
  Result := IsNull(FTableForeignKeyColumns.PrimarySchemaNameColumn);
end;

procedure TForeignKeyColumnsRow.SetPrimarySchemaNameNull;
begin
  Item[FTableForeignKeyColumns.PrimarySchemaNameColumn] := DBNull.Value;
end;

function TForeignKeyColumnsRow.IsPrimaryTableNameNull: Boolean;
begin
  Result := IsNull(FTableForeignKeyColumns.PrimaryTableNameColumn);
end;

procedure TForeignKeyColumnsRow.SetPrimaryTableNameNull;
begin
  Item[FTableForeignKeyColumns.PrimaryTableNameColumn] := DBNull.Value;
end;

function TForeignKeyColumnsRow.IsPrimaryKeyNameNull: Boolean;
begin
  Result := IsNull(FTableForeignKeyColumns.PrimaryKeyNameColumn);
end;

procedure TForeignKeyColumnsRow.SetPrimaryKeyNameNull;
begin
  Item[FTableForeignKeyColumns.PrimaryKeyNameColumn] := DBNull.Value;
end;

function TForeignKeyColumnsRow.IsPrimaryColumnNameNull: Boolean;
begin
  Result := IsNull(FTableForeignKeyColumns.PrimaryColumnNameColumn);
end;

procedure TForeignKeyColumnsRow.SetPrimaryColumnNameNull;
begin
  Item[FTableForeignKeyColumns.PrimaryColumnNameColumn] := DBNull.Value;
end;

function TForeignKeyColumnsRow.IsOrdinalNull: Boolean;
begin
  Result := IsNull(FTableForeignKeyColumns.OrdinalColumn);
end;

procedure TForeignKeyColumnsRow.SetOrdinalNull;
begin
  Item[FTableForeignKeyColumns.OrdinalColumn] := DBNull.Value;
end;

function TForeignKeyColumnsRow.GetCatalogName: WideString;
begin
  Result := Item[FTableForeignKeyColumns.CatalogNameColumn] as WideString;
end;

procedure TForeignKeyColumnsRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTableForeignKeyColumns.CatalogNameColumn] := TObject(NewValue);
end;

function TForeignKeyColumnsRow.GetSchemaName: WideString;
begin
  Result := Item[FTableForeignKeyColumns.SchemaNameColumn] as WideString;
end;

procedure TForeignKeyColumnsRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTableForeignKeyColumns.SchemaNameColumn] := TObject(NewValue);
end;

function TForeignKeyColumnsRow.GetTableName: WideString;
begin
  Result := Item[FTableForeignKeyColumns.TableNameColumn] as WideString;
end;

procedure TForeignKeyColumnsRow.SetTableName(NewValue: WideString);
begin
  Item[FTableForeignKeyColumns.TableNameColumn] := TObject(NewValue);
end;

function TForeignKeyColumnsRow.GetForeignKeyName: WideString;
begin
  Result := Item[FTableForeignKeyColumns.ForeignKeyNameColumn] as WideString;
end;

procedure TForeignKeyColumnsRow.SetForeignKeyName(NewValue: WideString);
begin
  Item[FTableForeignKeyColumns.ForeignKeyNameColumn] := TObject(NewValue);
end;

function TForeignKeyColumnsRow.GetColumnName: WideString;
begin
  Result := Item[FTableForeignKeyColumns.ColumnNameColumn] as WideString;
end;

procedure TForeignKeyColumnsRow.SetColumnName(NewValue: WideString);
begin
  Item[FTableForeignKeyColumns.ColumnNameColumn] := TObject(NewValue);
end;

function TForeignKeyColumnsRow.GetPrimaryCatalogName: WideString;
begin
  Result := Item[FTableForeignKeyColumns.PrimaryCatalogNameColumn] as WideString;
end;

procedure TForeignKeyColumnsRow.SetPrimaryCatalogName(NewValue: WideString);
begin
  Item[FTableForeignKeyColumns.PrimaryCatalogNameColumn] := TObject(NewValue);
end;

function TForeignKeyColumnsRow.GetPrimarySchemaName: WideString;
begin
  Result := Item[FTableForeignKeyColumns.PrimarySchemaNameColumn] as WideString;
end;

procedure TForeignKeyColumnsRow.SetPrimarySchemaName(NewValue: WideString);
begin
  Item[FTableForeignKeyColumns.PrimarySchemaNameColumn] := TObject(NewValue);
end;

function TForeignKeyColumnsRow.GetPrimaryTableName: WideString;
begin
  Result := Item[FTableForeignKeyColumns.PrimaryTableNameColumn] as WideString;
end;

procedure TForeignKeyColumnsRow.SetPrimaryTableName(NewValue: WideString);
begin
  Item[FTableForeignKeyColumns.PrimaryTableNameColumn] := TObject(NewValue);
end;

function TForeignKeyColumnsRow.GetPrimaryKeyName: WideString;
begin
  Result := Item[FTableForeignKeyColumns.PrimaryKeyNameColumn] as WideString;
end;

procedure TForeignKeyColumnsRow.SetPrimaryKeyName(NewValue: WideString);
begin
  Item[FTableForeignKeyColumns.PrimaryKeyNameColumn] := TObject(NewValue);
end;

function TForeignKeyColumnsRow.GetPrimaryColumnName: WideString;
begin
  Result := Item[FTableForeignKeyColumns.PrimaryColumnNameColumn] as WideString;
end;

procedure TForeignKeyColumnsRow.SetPrimaryColumnName(NewValue: WideString);
begin
  Item[FTableForeignKeyColumns.PrimaryColumnNameColumn] := TObject(NewValue);
end;

function TForeignKeyColumnsRow.GetOrdinal: Integer;
begin
  Result := Item[FTableForeignKeyColumns.OrdinalColumn] as Integer;
end;

procedure TForeignKeyColumnsRow.SetOrdinal(NewValue: Integer);
begin
  Item[FTableForeignKeyColumns.OrdinalColumn] := TObject(NewValue);
end;

constructor TForeignKeyColumnsTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.ForeignKeyColumns;
  BeginInit();
  InitClass();
  EndInit();
end;

function TForeignKeyColumnsTable.Clone: DataTable;
var
  NewClone: TForeignKeyColumnsTable;
begin
  NewClone := TForeignKeyColumnsTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TForeignKeyColumnsTable.CreateInstance: DataTable;
begin
  Result := TForeignKeyColumnsTable.Create;
end;

function TForeignKeyColumnsTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TForeignKeyColumnsTable.GetItem(Index: Integer): TForeignKeyColumnsRow;
begin
  Result := TForeignKeyColumnsRow(Rows.Item[Index]);
end;

function TForeignKeyColumnsTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TForeignKeyColumnsTable.AddForeignKeyColumnsRow(Row: TForeignKeyColumnsRow);
begin
  Rows.Add(Row);
end;

procedure TForeignKeyColumnsTable.AddForeignKeyColumnsRow(CatalogName: WideString; SchemaName: WideString; TableName: WideString; ForeignKeyName: WideString; ColumnName: WideString; PrimaryCatalogName: WideString; PrimarySchemaName: WideString; PrimaryTableName: WideString; PrimaryKeyName: WideString; PrimaryColumnName: WideString; Ordinal: Integer);
var
  NewRow: TForeignKeyColumnsRow;
begin
  NewRow := NewForeignKeyColumnsRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  NewRow.TableName := TableName;
  NewRow.ForeignKeyName := ForeignKeyName;
  NewRow.ColumnName := ColumnName;
  NewRow.PrimaryCatalogName := PrimaryCatalogName;
  NewRow.PrimarySchemaName := PrimarySchemaName;
  NewRow.PrimaryTableName := PrimaryTableName;
  NewRow.PrimaryKeyName := PrimaryKeyName;
  NewRow.PrimaryColumnName := PrimaryColumnName;
  NewRow.Ordinal := Ordinal;
  AddForeignKeyColumnsRow(NewRow);
end;

function TForeignKeyColumnsTable.NewForeignKeyColumnsRow: TForeignKeyColumnsRow;
begin
  Result := TForeignKeyColumnsRow(NewRow);
end;

procedure TForeignKeyColumnsTable.RemoveForeignKeyColumnsRow(Row: TForeignKeyColumnsRow);
begin
  Rows.Remove(Row);
end;

function TForeignKeyColumnsTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TForeignKeyColumnsRow.Create(Builder);
end;

function TForeignKeyColumnsTable.GetRowType: System.Type;
begin
  Result := typeof(TForeignKeyColumnsRow);
end;

procedure TForeignKeyColumnsTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXForeignKeyColumnsColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXForeignKeyColumnsColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
  FColumnTableName := DataColumn.Create(TDBXForeignKeyColumnsColumns.TableName, typeof(WideString));
  FColumnTableName.Caption := STableName;
  Columns.Add(FColumnTableName);
  FColumnForeignKeyName := DataColumn.Create(TDBXForeignKeyColumnsColumns.ForeignKeyName, typeof(WideString));
  FColumnForeignKeyName.Caption := SForeignKeyName;
  Columns.Add(FColumnForeignKeyName);
  FColumnColumnName := DataColumn.Create(TDBXForeignKeyColumnsColumns.ColumnName, typeof(WideString));
  FColumnColumnName.Caption := SColumnName;
  Columns.Add(FColumnColumnName);
  FColumnPrimaryCatalogName := DataColumn.Create(TDBXForeignKeyColumnsColumns.PrimaryCatalogName, typeof(WideString));
  FColumnPrimaryCatalogName.Caption := SPrimaryCatalogName;
  Columns.Add(FColumnPrimaryCatalogName);
  FColumnPrimarySchemaName := DataColumn.Create(TDBXForeignKeyColumnsColumns.PrimarySchemaName, typeof(WideString));
  FColumnPrimarySchemaName.Caption := SPrimarySchemaName;
  Columns.Add(FColumnPrimarySchemaName);
  FColumnPrimaryTableName := DataColumn.Create(TDBXForeignKeyColumnsColumns.PrimaryTableName, typeof(WideString));
  FColumnPrimaryTableName.Caption := SPrimaryTableName;
  Columns.Add(FColumnPrimaryTableName);
  FColumnPrimaryKeyName := DataColumn.Create(TDBXForeignKeyColumnsColumns.PrimaryKeyName, typeof(WideString));
  FColumnPrimaryKeyName.Caption := SPrimaryKeyName;
  Columns.Add(FColumnPrimaryKeyName);
  FColumnPrimaryColumnName := DataColumn.Create(TDBXForeignKeyColumnsColumns.PrimaryColumnName, typeof(WideString));
  FColumnPrimaryColumnName.Caption := SPrimaryColumnName;
  Columns.Add(FColumnPrimaryColumnName);
  FColumnOrdinal := DataColumn.Create(TDBXForeignKeyColumnsColumns.Ordinal, typeof(Integer));
  FColumnOrdinal.Caption := SOrdinal;
  Columns.Add(FColumnOrdinal);
end;

procedure TForeignKeyColumnsTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXForeignKeyColumnsColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXForeignKeyColumnsColumns.SchemaName];
  FColumnTableName := Columns[TDBXForeignKeyColumnsColumns.TableName];
  FColumnForeignKeyName := Columns[TDBXForeignKeyColumnsColumns.ForeignKeyName];
  FColumnColumnName := Columns[TDBXForeignKeyColumnsColumns.ColumnName];
  FColumnPrimaryCatalogName := Columns[TDBXForeignKeyColumnsColumns.PrimaryCatalogName];
  FColumnPrimarySchemaName := Columns[TDBXForeignKeyColumnsColumns.PrimarySchemaName];
  FColumnPrimaryTableName := Columns[TDBXForeignKeyColumnsColumns.PrimaryTableName];
  FColumnPrimaryKeyName := Columns[TDBXForeignKeyColumnsColumns.PrimaryKeyName];
  FColumnPrimaryColumnName := Columns[TDBXForeignKeyColumnsColumns.PrimaryColumnName];
  FColumnOrdinal := Columns[TDBXForeignKeyColumnsColumns.Ordinal];
end;

constructor TProceduresRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableProcedures := TProceduresTable(Table);
end;

function TProceduresRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTableProcedures.CatalogNameColumn);
end;

procedure TProceduresRow.SetCatalogNameNull;
begin
  Item[FTableProcedures.CatalogNameColumn] := DBNull.Value;
end;

function TProceduresRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTableProcedures.SchemaNameColumn);
end;

procedure TProceduresRow.SetSchemaNameNull;
begin
  Item[FTableProcedures.SchemaNameColumn] := DBNull.Value;
end;

function TProceduresRow.IsProcedureNameNull: Boolean;
begin
  Result := IsNull(FTableProcedures.ProcedureNameColumn);
end;

procedure TProceduresRow.SetProcedureNameNull;
begin
  Item[FTableProcedures.ProcedureNameColumn] := DBNull.Value;
end;

function TProceduresRow.IsProcedureTypeNull: Boolean;
begin
  Result := IsNull(FTableProcedures.ProcedureTypeColumn);
end;

procedure TProceduresRow.SetProcedureTypeNull;
begin
  Item[FTableProcedures.ProcedureTypeColumn] := DBNull.Value;
end;

function TProceduresRow.GetCatalogName: WideString;
begin
  Result := Item[FTableProcedures.CatalogNameColumn] as WideString;
end;

procedure TProceduresRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTableProcedures.CatalogNameColumn] := TObject(NewValue);
end;

function TProceduresRow.GetSchemaName: WideString;
begin
  Result := Item[FTableProcedures.SchemaNameColumn] as WideString;
end;

procedure TProceduresRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTableProcedures.SchemaNameColumn] := TObject(NewValue);
end;

function TProceduresRow.GetProcedureName: WideString;
begin
  Result := Item[FTableProcedures.ProcedureNameColumn] as WideString;
end;

procedure TProceduresRow.SetProcedureName(NewValue: WideString);
begin
  Item[FTableProcedures.ProcedureNameColumn] := TObject(NewValue);
end;

function TProceduresRow.GetProcedureType: WideString;
begin
  Result := Item[FTableProcedures.ProcedureTypeColumn] as WideString;
end;

procedure TProceduresRow.SetProcedureType(NewValue: WideString);
begin
  Item[FTableProcedures.ProcedureTypeColumn] := TObject(NewValue);
end;

constructor TProceduresTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.Procedures;
  BeginInit();
  InitClass();
  EndInit();
end;

function TProceduresTable.Clone: DataTable;
var
  NewClone: TProceduresTable;
begin
  NewClone := TProceduresTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TProceduresTable.CreateInstance: DataTable;
begin
  Result := TProceduresTable.Create;
end;

function TProceduresTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TProceduresTable.GetItem(Index: Integer): TProceduresRow;
begin
  Result := TProceduresRow(Rows.Item[Index]);
end;

function TProceduresTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TProceduresTable.AddProceduresRow(Row: TProceduresRow);
begin
  Rows.Add(Row);
end;

procedure TProceduresTable.AddProceduresRow(CatalogName: WideString; SchemaName: WideString; ProcedureName: WideString; ProcedureType: WideString);
var
  NewRow: TProceduresRow;
begin
  NewRow := NewProceduresRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  NewRow.ProcedureName := ProcedureName;
  NewRow.ProcedureType := ProcedureType;
  AddProceduresRow(NewRow);
end;

function TProceduresTable.NewProceduresRow: TProceduresRow;
begin
  Result := TProceduresRow(NewRow);
end;

procedure TProceduresTable.RemoveProceduresRow(Row: TProceduresRow);
begin
  Rows.Remove(Row);
end;

function TProceduresTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TProceduresRow.Create(Builder);
end;

function TProceduresTable.GetRowType: System.Type;
begin
  Result := typeof(TProceduresRow);
end;

procedure TProceduresTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXProceduresColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXProceduresColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
  FColumnProcedureName := DataColumn.Create(TDBXProceduresColumns.ProcedureName, typeof(WideString));
  FColumnProcedureName.Caption := SProcedureName;
  Columns.Add(FColumnProcedureName);
  FColumnProcedureType := DataColumn.Create(TDBXProceduresColumns.ProcedureType, typeof(WideString));
  FColumnProcedureType.Caption := SProcedureType;
  Columns.Add(FColumnProcedureType);
end;

procedure TProceduresTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXProceduresColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXProceduresColumns.SchemaName];
  FColumnProcedureName := Columns[TDBXProceduresColumns.ProcedureName];
  FColumnProcedureType := Columns[TDBXProceduresColumns.ProcedureType];
end;

constructor TProcedureSourcesRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableProcedureSources := TProcedureSourcesTable(Table);
end;

function TProcedureSourcesRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTableProcedureSources.CatalogNameColumn);
end;

procedure TProcedureSourcesRow.SetCatalogNameNull;
begin
  Item[FTableProcedureSources.CatalogNameColumn] := DBNull.Value;
end;

function TProcedureSourcesRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTableProcedureSources.SchemaNameColumn);
end;

procedure TProcedureSourcesRow.SetSchemaNameNull;
begin
  Item[FTableProcedureSources.SchemaNameColumn] := DBNull.Value;
end;

function TProcedureSourcesRow.IsProcedureNameNull: Boolean;
begin
  Result := IsNull(FTableProcedureSources.ProcedureNameColumn);
end;

procedure TProcedureSourcesRow.SetProcedureNameNull;
begin
  Item[FTableProcedureSources.ProcedureNameColumn] := DBNull.Value;
end;

function TProcedureSourcesRow.IsProcedureTypeNull: Boolean;
begin
  Result := IsNull(FTableProcedureSources.ProcedureTypeColumn);
end;

procedure TProcedureSourcesRow.SetProcedureTypeNull;
begin
  Item[FTableProcedureSources.ProcedureTypeColumn] := DBNull.Value;
end;

function TProcedureSourcesRow.IsDefinitionNull: Boolean;
begin
  Result := IsNull(FTableProcedureSources.DefinitionColumn);
end;

procedure TProcedureSourcesRow.SetDefinitionNull;
begin
  Item[FTableProcedureSources.DefinitionColumn] := DBNull.Value;
end;

function TProcedureSourcesRow.IsExternalDefinitionNull: Boolean;
begin
  Result := IsNull(FTableProcedureSources.ExternalDefinitionColumn);
end;

procedure TProcedureSourcesRow.SetExternalDefinitionNull;
begin
  Item[FTableProcedureSources.ExternalDefinitionColumn] := DBNull.Value;
end;

function TProcedureSourcesRow.GetCatalogName: WideString;
begin
  Result := Item[FTableProcedureSources.CatalogNameColumn] as WideString;
end;

procedure TProcedureSourcesRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTableProcedureSources.CatalogNameColumn] := TObject(NewValue);
end;

function TProcedureSourcesRow.GetSchemaName: WideString;
begin
  Result := Item[FTableProcedureSources.SchemaNameColumn] as WideString;
end;

procedure TProcedureSourcesRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTableProcedureSources.SchemaNameColumn] := TObject(NewValue);
end;

function TProcedureSourcesRow.GetProcedureName: WideString;
begin
  Result := Item[FTableProcedureSources.ProcedureNameColumn] as WideString;
end;

procedure TProcedureSourcesRow.SetProcedureName(NewValue: WideString);
begin
  Item[FTableProcedureSources.ProcedureNameColumn] := TObject(NewValue);
end;

function TProcedureSourcesRow.GetProcedureType: WideString;
begin
  Result := Item[FTableProcedureSources.ProcedureTypeColumn] as WideString;
end;

procedure TProcedureSourcesRow.SetProcedureType(NewValue: WideString);
begin
  Item[FTableProcedureSources.ProcedureTypeColumn] := TObject(NewValue);
end;

function TProcedureSourcesRow.GetDefinition: WideString;
begin
  Result := Item[FTableProcedureSources.DefinitionColumn] as WideString;
end;

procedure TProcedureSourcesRow.SetDefinition(NewValue: WideString);
begin
  Item[FTableProcedureSources.DefinitionColumn] := TObject(NewValue);
end;

function TProcedureSourcesRow.GetExternalDefinition: WideString;
begin
  Result := Item[FTableProcedureSources.ExternalDefinitionColumn] as WideString;
end;

procedure TProcedureSourcesRow.SetExternalDefinition(NewValue: WideString);
begin
  Item[FTableProcedureSources.ExternalDefinitionColumn] := TObject(NewValue);
end;

constructor TProcedureSourcesTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.ProcedureSources;
  BeginInit();
  InitClass();
  EndInit();
end;

function TProcedureSourcesTable.Clone: DataTable;
var
  NewClone: TProcedureSourcesTable;
begin
  NewClone := TProcedureSourcesTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TProcedureSourcesTable.CreateInstance: DataTable;
begin
  Result := TProcedureSourcesTable.Create;
end;

function TProcedureSourcesTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TProcedureSourcesTable.GetItem(Index: Integer): TProcedureSourcesRow;
begin
  Result := TProcedureSourcesRow(Rows.Item[Index]);
end;

function TProcedureSourcesTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TProcedureSourcesTable.AddProcedureSourcesRow(Row: TProcedureSourcesRow);
begin
  Rows.Add(Row);
end;

procedure TProcedureSourcesTable.AddProcedureSourcesRow(CatalogName: WideString; SchemaName: WideString; ProcedureName: WideString; ProcedureType: WideString; Definition: WideString; ExternalDefinition: WideString);
var
  NewRow: TProcedureSourcesRow;
begin
  NewRow := NewProcedureSourcesRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  NewRow.ProcedureName := ProcedureName;
  NewRow.ProcedureType := ProcedureType;
  NewRow.Definition := Definition;
  NewRow.ExternalDefinition := ExternalDefinition;
  AddProcedureSourcesRow(NewRow);
end;

function TProcedureSourcesTable.NewProcedureSourcesRow: TProcedureSourcesRow;
begin
  Result := TProcedureSourcesRow(NewRow);
end;

procedure TProcedureSourcesTable.RemoveProcedureSourcesRow(Row: TProcedureSourcesRow);
begin
  Rows.Remove(Row);
end;

function TProcedureSourcesTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TProcedureSourcesRow.Create(Builder);
end;

function TProcedureSourcesTable.GetRowType: System.Type;
begin
  Result := typeof(TProcedureSourcesRow);
end;

procedure TProcedureSourcesTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXProcedureSourcesColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXProcedureSourcesColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
  FColumnProcedureName := DataColumn.Create(TDBXProcedureSourcesColumns.ProcedureName, typeof(WideString));
  FColumnProcedureName.Caption := SProcedureName;
  Columns.Add(FColumnProcedureName);
  FColumnProcedureType := DataColumn.Create(TDBXProcedureSourcesColumns.ProcedureType, typeof(WideString));
  FColumnProcedureType.Caption := SProcedureType;
  Columns.Add(FColumnProcedureType);
  FColumnDefinition := DataColumn.Create(TDBXProcedureSourcesColumns.Definition, typeof(WideString));
  FColumnDefinition.Caption := SDefinition;
  Columns.Add(FColumnDefinition);
  FColumnExternalDefinition := DataColumn.Create(TDBXProcedureSourcesColumns.ExternalDefinition, typeof(WideString));
  FColumnExternalDefinition.Caption := SExternalDefinition;
  Columns.Add(FColumnExternalDefinition);
end;

procedure TProcedureSourcesTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXProcedureSourcesColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXProcedureSourcesColumns.SchemaName];
  FColumnProcedureName := Columns[TDBXProcedureSourcesColumns.ProcedureName];
  FColumnProcedureType := Columns[TDBXProcedureSourcesColumns.ProcedureType];
  FColumnDefinition := Columns[TDBXProcedureSourcesColumns.Definition];
  FColumnExternalDefinition := Columns[TDBXProcedureSourcesColumns.ExternalDefinition];
end;

constructor TProcedureParametersRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableProcedureParameters := TProcedureParametersTable(Table);
end;

function TProcedureParametersRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTableProcedureParameters.CatalogNameColumn);
end;

procedure TProcedureParametersRow.SetCatalogNameNull;
begin
  Item[FTableProcedureParameters.CatalogNameColumn] := DBNull.Value;
end;

function TProcedureParametersRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTableProcedureParameters.SchemaNameColumn);
end;

procedure TProcedureParametersRow.SetSchemaNameNull;
begin
  Item[FTableProcedureParameters.SchemaNameColumn] := DBNull.Value;
end;

function TProcedureParametersRow.IsProcedureNameNull: Boolean;
begin
  Result := IsNull(FTableProcedureParameters.ProcedureNameColumn);
end;

procedure TProcedureParametersRow.SetProcedureNameNull;
begin
  Item[FTableProcedureParameters.ProcedureNameColumn] := DBNull.Value;
end;

function TProcedureParametersRow.IsParameterNameNull: Boolean;
begin
  Result := IsNull(FTableProcedureParameters.ParameterNameColumn);
end;

procedure TProcedureParametersRow.SetParameterNameNull;
begin
  Item[FTableProcedureParameters.ParameterNameColumn] := DBNull.Value;
end;

function TProcedureParametersRow.IsParameterModeNull: Boolean;
begin
  Result := IsNull(FTableProcedureParameters.ParameterModeColumn);
end;

procedure TProcedureParametersRow.SetParameterModeNull;
begin
  Item[FTableProcedureParameters.ParameterModeColumn] := DBNull.Value;
end;

function TProcedureParametersRow.IsTypeNameNull: Boolean;
begin
  Result := IsNull(FTableProcedureParameters.TypeNameColumn);
end;

procedure TProcedureParametersRow.SetTypeNameNull;
begin
  Item[FTableProcedureParameters.TypeNameColumn] := DBNull.Value;
end;

function TProcedureParametersRow.IsPrecisionNull: Boolean;
begin
  Result := IsNull(FTableProcedureParameters.PrecisionColumn);
end;

procedure TProcedureParametersRow.SetPrecisionNull;
begin
  Item[FTableProcedureParameters.PrecisionColumn] := DBNull.Value;
end;

function TProcedureParametersRow.IsScaleNull: Boolean;
begin
  Result := IsNull(FTableProcedureParameters.ScaleColumn);
end;

procedure TProcedureParametersRow.SetScaleNull;
begin
  Item[FTableProcedureParameters.ScaleColumn] := DBNull.Value;
end;

function TProcedureParametersRow.IsOrdinalNull: Boolean;
begin
  Result := IsNull(FTableProcedureParameters.OrdinalColumn);
end;

procedure TProcedureParametersRow.SetOrdinalNull;
begin
  Item[FTableProcedureParameters.OrdinalColumn] := DBNull.Value;
end;

function TProcedureParametersRow.IsIsNullableNull: Boolean;
begin
  Result := IsNull(FTableProcedureParameters.IsNullableColumn);
end;

procedure TProcedureParametersRow.SetIsNullableNull;
begin
  Item[FTableProcedureParameters.IsNullableColumn] := DBNull.Value;
end;

function TProcedureParametersRow.IsDbxDataTypeNull: Boolean;
begin
  Result := IsNull(FTableProcedureParameters.DbxDataTypeColumn);
end;

procedure TProcedureParametersRow.SetDbxDataTypeNull;
begin
  Item[FTableProcedureParameters.DbxDataTypeColumn] := DBNull.Value;
end;

function TProcedureParametersRow.IsIsFixedLengthNull: Boolean;
begin
  Result := IsNull(FTableProcedureParameters.IsFixedLengthColumn);
end;

procedure TProcedureParametersRow.SetIsFixedLengthNull;
begin
  Item[FTableProcedureParameters.IsFixedLengthColumn] := DBNull.Value;
end;

function TProcedureParametersRow.IsIsUnicodeNull: Boolean;
begin
  Result := IsNull(FTableProcedureParameters.IsUnicodeColumn);
end;

procedure TProcedureParametersRow.SetIsUnicodeNull;
begin
  Item[FTableProcedureParameters.IsUnicodeColumn] := DBNull.Value;
end;

function TProcedureParametersRow.IsIsLongNull: Boolean;
begin
  Result := IsNull(FTableProcedureParameters.IsLongColumn);
end;

procedure TProcedureParametersRow.SetIsLongNull;
begin
  Item[FTableProcedureParameters.IsLongColumn] := DBNull.Value;
end;

function TProcedureParametersRow.IsIsUnsignedNull: Boolean;
begin
  Result := IsNull(FTableProcedureParameters.IsUnsignedColumn);
end;

procedure TProcedureParametersRow.SetIsUnsignedNull;
begin
  Item[FTableProcedureParameters.IsUnsignedColumn] := DBNull.Value;
end;

function TProcedureParametersRow.GetCatalogName: WideString;
begin
  Result := Item[FTableProcedureParameters.CatalogNameColumn] as WideString;
end;

procedure TProcedureParametersRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTableProcedureParameters.CatalogNameColumn] := TObject(NewValue);
end;

function TProcedureParametersRow.GetSchemaName: WideString;
begin
  Result := Item[FTableProcedureParameters.SchemaNameColumn] as WideString;
end;

procedure TProcedureParametersRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTableProcedureParameters.SchemaNameColumn] := TObject(NewValue);
end;

function TProcedureParametersRow.GetProcedureName: WideString;
begin
  Result := Item[FTableProcedureParameters.ProcedureNameColumn] as WideString;
end;

procedure TProcedureParametersRow.SetProcedureName(NewValue: WideString);
begin
  Item[FTableProcedureParameters.ProcedureNameColumn] := TObject(NewValue);
end;

function TProcedureParametersRow.GetParameterName: WideString;
begin
  Result := Item[FTableProcedureParameters.ParameterNameColumn] as WideString;
end;

procedure TProcedureParametersRow.SetParameterName(NewValue: WideString);
begin
  Item[FTableProcedureParameters.ParameterNameColumn] := TObject(NewValue);
end;

function TProcedureParametersRow.GetParameterMode: WideString;
begin
  Result := Item[FTableProcedureParameters.ParameterModeColumn] as WideString;
end;

procedure TProcedureParametersRow.SetParameterMode(NewValue: WideString);
begin
  Item[FTableProcedureParameters.ParameterModeColumn] := TObject(NewValue);
end;

function TProcedureParametersRow.GetTypeName: WideString;
begin
  Result := Item[FTableProcedureParameters.TypeNameColumn] as WideString;
end;

procedure TProcedureParametersRow.SetTypeName(NewValue: WideString);
begin
  Item[FTableProcedureParameters.TypeNameColumn] := TObject(NewValue);
end;

function TProcedureParametersRow.GetPrecision: Integer;
begin
  Result := Item[FTableProcedureParameters.PrecisionColumn] as Integer;
end;

procedure TProcedureParametersRow.SetPrecision(NewValue: Integer);
begin
  Item[FTableProcedureParameters.PrecisionColumn] := TObject(NewValue);
end;

function TProcedureParametersRow.GetScale: Integer;
begin
  Result := Item[FTableProcedureParameters.ScaleColumn] as Integer;
end;

procedure TProcedureParametersRow.SetScale(NewValue: Integer);
begin
  Item[FTableProcedureParameters.ScaleColumn] := TObject(NewValue);
end;

function TProcedureParametersRow.GetOrdinal: Integer;
begin
  Result := Item[FTableProcedureParameters.OrdinalColumn] as Integer;
end;

procedure TProcedureParametersRow.SetOrdinal(NewValue: Integer);
begin
  Item[FTableProcedureParameters.OrdinalColumn] := TObject(NewValue);
end;

function TProcedureParametersRow.GetIsNullable: Boolean;
begin
  Result := Item[FTableProcedureParameters.IsNullableColumn] as Boolean;
end;

procedure TProcedureParametersRow.SetIsNullable(NewValue: Boolean);
begin
  Item[FTableProcedureParameters.IsNullableColumn] := TObject(NewValue);
end;

function TProcedureParametersRow.GetDbxDataType: Integer;
begin
  Result := Item[FTableProcedureParameters.DbxDataTypeColumn] as Integer;
end;

procedure TProcedureParametersRow.SetDbxDataType(NewValue: Integer);
begin
  Item[FTableProcedureParameters.DbxDataTypeColumn] := TObject(NewValue);
end;

function TProcedureParametersRow.GetIsFixedLength: Boolean;
begin
  Result := Item[FTableProcedureParameters.IsFixedLengthColumn] as Boolean;
end;

procedure TProcedureParametersRow.SetIsFixedLength(NewValue: Boolean);
begin
  Item[FTableProcedureParameters.IsFixedLengthColumn] := TObject(NewValue);
end;

function TProcedureParametersRow.GetIsUnicode: Boolean;
begin
  Result := Item[FTableProcedureParameters.IsUnicodeColumn] as Boolean;
end;

procedure TProcedureParametersRow.SetIsUnicode(NewValue: Boolean);
begin
  Item[FTableProcedureParameters.IsUnicodeColumn] := TObject(NewValue);
end;

function TProcedureParametersRow.GetIsLong: Boolean;
begin
  Result := Item[FTableProcedureParameters.IsLongColumn] as Boolean;
end;

procedure TProcedureParametersRow.SetIsLong(NewValue: Boolean);
begin
  Item[FTableProcedureParameters.IsLongColumn] := TObject(NewValue);
end;

function TProcedureParametersRow.GetIsUnsigned: Boolean;
begin
  Result := Item[FTableProcedureParameters.IsUnsignedColumn] as Boolean;
end;

procedure TProcedureParametersRow.SetIsUnsigned(NewValue: Boolean);
begin
  Item[FTableProcedureParameters.IsUnsignedColumn] := TObject(NewValue);
end;

constructor TProcedureParametersTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.ProcedureParameters;
  BeginInit();
  InitClass();
  EndInit();
end;

function TProcedureParametersTable.Clone: DataTable;
var
  NewClone: TProcedureParametersTable;
begin
  NewClone := TProcedureParametersTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TProcedureParametersTable.CreateInstance: DataTable;
begin
  Result := TProcedureParametersTable.Create;
end;

function TProcedureParametersTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TProcedureParametersTable.GetItem(Index: Integer): TProcedureParametersRow;
begin
  Result := TProcedureParametersRow(Rows.Item[Index]);
end;

function TProcedureParametersTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TProcedureParametersTable.AddProcedureParametersRow(Row: TProcedureParametersRow);
begin
  Rows.Add(Row);
end;

procedure TProcedureParametersTable.AddProcedureParametersRow(CatalogName: WideString; SchemaName: WideString; ProcedureName: WideString; ParameterName: WideString; ParameterMode: WideString; TypeName: WideString; Precision: Integer; Scale: Integer; Ordinal: Integer; IsNullable: Boolean; DbxDataType: Integer; IsFixedLength: Boolean; IsUnicode: Boolean; IsLong: Boolean; IsUnsigned: Boolean);
var
  NewRow: TProcedureParametersRow;
begin
  NewRow := NewProcedureParametersRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  NewRow.ProcedureName := ProcedureName;
  NewRow.ParameterName := ParameterName;
  NewRow.ParameterMode := ParameterMode;
  NewRow.TypeName := TypeName;
  NewRow.Precision := Precision;
  NewRow.Scale := Scale;
  NewRow.Ordinal := Ordinal;
  NewRow.IsNullable := IsNullable;
  NewRow.DbxDataType := DbxDataType;
  NewRow.IsFixedLength := IsFixedLength;
  NewRow.IsUnicode := IsUnicode;
  NewRow.IsLong := IsLong;
  NewRow.IsUnsigned := IsUnsigned;
  AddProcedureParametersRow(NewRow);
end;

function TProcedureParametersTable.NewProcedureParametersRow: TProcedureParametersRow;
begin
  Result := TProcedureParametersRow(NewRow);
end;

procedure TProcedureParametersTable.RemoveProcedureParametersRow(Row: TProcedureParametersRow);
begin
  Rows.Remove(Row);
end;

function TProcedureParametersTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TProcedureParametersRow.Create(Builder);
end;

function TProcedureParametersTable.GetRowType: System.Type;
begin
  Result := typeof(TProcedureParametersRow);
end;

procedure TProcedureParametersTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXProcedureParametersColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXProcedureParametersColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
  FColumnProcedureName := DataColumn.Create(TDBXProcedureParametersColumns.ProcedureName, typeof(WideString));
  FColumnProcedureName.Caption := SProcedureName;
  Columns.Add(FColumnProcedureName);
  FColumnParameterName := DataColumn.Create(TDBXProcedureParametersColumns.ParameterName, typeof(WideString));
  FColumnParameterName.Caption := SParameterName;
  Columns.Add(FColumnParameterName);
  FColumnParameterMode := DataColumn.Create(TDBXProcedureParametersColumns.ParameterMode, typeof(WideString));
  FColumnParameterMode.Caption := SParameterMode;
  Columns.Add(FColumnParameterMode);
  FColumnTypeName := DataColumn.Create(TDBXProcedureParametersColumns.TypeName, typeof(WideString));
  FColumnTypeName.Caption := STypeName;
  Columns.Add(FColumnTypeName);
  FColumnPrecision := DataColumn.Create(TDBXProcedureParametersColumns.Precision, typeof(Integer));
  FColumnPrecision.Caption := SPrecision;
  Columns.Add(FColumnPrecision);
  FColumnScale := DataColumn.Create(TDBXProcedureParametersColumns.Scale, typeof(Integer));
  FColumnScale.Caption := SScale;
  Columns.Add(FColumnScale);
  FColumnOrdinal := DataColumn.Create(TDBXProcedureParametersColumns.Ordinal, typeof(Integer));
  FColumnOrdinal.Caption := SOrdinal;
  Columns.Add(FColumnOrdinal);
  FColumnIsNullable := DataColumn.Create(TDBXProcedureParametersColumns.IsNullable, typeof(Boolean));
  FColumnIsNullable.Caption := SIsNullable;
  Columns.Add(FColumnIsNullable);
  FColumnDbxDataType := DataColumn.Create(TDBXProcedureParametersColumns.DbxDataType, typeof(Integer));
  FColumnDbxDataType.Caption := SDbxDataType;
  Columns.Add(FColumnDbxDataType);
  FColumnIsFixedLength := DataColumn.Create(TDBXProcedureParametersColumns.IsFixedLength, typeof(Boolean));
  FColumnIsFixedLength.Caption := SIsFixedLength;
  Columns.Add(FColumnIsFixedLength);
  FColumnIsUnicode := DataColumn.Create(TDBXProcedureParametersColumns.IsUnicode, typeof(Boolean));
  FColumnIsUnicode.Caption := SIsUnicode;
  Columns.Add(FColumnIsUnicode);
  FColumnIsLong := DataColumn.Create(TDBXProcedureParametersColumns.IsLong, typeof(Boolean));
  FColumnIsLong.Caption := SIsLong;
  Columns.Add(FColumnIsLong);
  FColumnIsUnsigned := DataColumn.Create(TDBXProcedureParametersColumns.IsUnsigned, typeof(Boolean));
  FColumnIsUnsigned.Caption := SIsUnsigned;
  Columns.Add(FColumnIsUnsigned);
end;

procedure TProcedureParametersTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXProcedureParametersColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXProcedureParametersColumns.SchemaName];
  FColumnProcedureName := Columns[TDBXProcedureParametersColumns.ProcedureName];
  FColumnParameterName := Columns[TDBXProcedureParametersColumns.ParameterName];
  FColumnParameterMode := Columns[TDBXProcedureParametersColumns.ParameterMode];
  FColumnTypeName := Columns[TDBXProcedureParametersColumns.TypeName];
  FColumnPrecision := Columns[TDBXProcedureParametersColumns.Precision];
  FColumnScale := Columns[TDBXProcedureParametersColumns.Scale];
  FColumnOrdinal := Columns[TDBXProcedureParametersColumns.Ordinal];
  FColumnIsNullable := Columns[TDBXProcedureParametersColumns.IsNullable];
  FColumnDbxDataType := Columns[TDBXProcedureParametersColumns.DbxDataType];
  FColumnIsFixedLength := Columns[TDBXProcedureParametersColumns.IsFixedLength];
  FColumnIsUnicode := Columns[TDBXProcedureParametersColumns.IsUnicode];
  FColumnIsLong := Columns[TDBXProcedureParametersColumns.IsLong];
  FColumnIsUnsigned := Columns[TDBXProcedureParametersColumns.IsUnsigned];
end;

constructor TPackagesRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTablePackages := TPackagesTable(Table);
end;

function TPackagesRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTablePackages.CatalogNameColumn);
end;

procedure TPackagesRow.SetCatalogNameNull;
begin
  Item[FTablePackages.CatalogNameColumn] := DBNull.Value;
end;

function TPackagesRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTablePackages.SchemaNameColumn);
end;

procedure TPackagesRow.SetSchemaNameNull;
begin
  Item[FTablePackages.SchemaNameColumn] := DBNull.Value;
end;

function TPackagesRow.IsPackageNameNull: Boolean;
begin
  Result := IsNull(FTablePackages.PackageNameColumn);
end;

procedure TPackagesRow.SetPackageNameNull;
begin
  Item[FTablePackages.PackageNameColumn] := DBNull.Value;
end;

function TPackagesRow.GetCatalogName: WideString;
begin
  Result := Item[FTablePackages.CatalogNameColumn] as WideString;
end;

procedure TPackagesRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTablePackages.CatalogNameColumn] := TObject(NewValue);
end;

function TPackagesRow.GetSchemaName: WideString;
begin
  Result := Item[FTablePackages.SchemaNameColumn] as WideString;
end;

procedure TPackagesRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTablePackages.SchemaNameColumn] := TObject(NewValue);
end;

function TPackagesRow.GetPackageName: WideString;
begin
  Result := Item[FTablePackages.PackageNameColumn] as WideString;
end;

procedure TPackagesRow.SetPackageName(NewValue: WideString);
begin
  Item[FTablePackages.PackageNameColumn] := TObject(NewValue);
end;

constructor TPackagesTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.Packages;
  BeginInit();
  InitClass();
  EndInit();
end;

function TPackagesTable.Clone: DataTable;
var
  NewClone: TPackagesTable;
begin
  NewClone := TPackagesTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TPackagesTable.CreateInstance: DataTable;
begin
  Result := TPackagesTable.Create;
end;

function TPackagesTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TPackagesTable.GetItem(Index: Integer): TPackagesRow;
begin
  Result := TPackagesRow(Rows.Item[Index]);
end;

function TPackagesTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TPackagesTable.AddPackagesRow(Row: TPackagesRow);
begin
  Rows.Add(Row);
end;

procedure TPackagesTable.AddPackagesRow(CatalogName: WideString; SchemaName: WideString; PackageName: WideString);
var
  NewRow: TPackagesRow;
begin
  NewRow := NewPackagesRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  NewRow.PackageName := PackageName;
  AddPackagesRow(NewRow);
end;

function TPackagesTable.NewPackagesRow: TPackagesRow;
begin
  Result := TPackagesRow(NewRow);
end;

procedure TPackagesTable.RemovePackagesRow(Row: TPackagesRow);
begin
  Rows.Remove(Row);
end;

function TPackagesTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TPackagesRow.Create(Builder);
end;

function TPackagesTable.GetRowType: System.Type;
begin
  Result := typeof(TPackagesRow);
end;

procedure TPackagesTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXPackagesColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXPackagesColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
  FColumnPackageName := DataColumn.Create(TDBXPackagesColumns.PackageName, typeof(WideString));
  FColumnPackageName.Caption := SPackageName;
  Columns.Add(FColumnPackageName);
end;

procedure TPackagesTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXPackagesColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXPackagesColumns.SchemaName];
  FColumnPackageName := Columns[TDBXPackagesColumns.PackageName];
end;

constructor TPackageProceduresRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTablePackageProcedures := TPackageProceduresTable(Table);
end;

function TPackageProceduresRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedures.CatalogNameColumn);
end;

procedure TPackageProceduresRow.SetCatalogNameNull;
begin
  Item[FTablePackageProcedures.CatalogNameColumn] := DBNull.Value;
end;

function TPackageProceduresRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedures.SchemaNameColumn);
end;

procedure TPackageProceduresRow.SetSchemaNameNull;
begin
  Item[FTablePackageProcedures.SchemaNameColumn] := DBNull.Value;
end;

function TPackageProceduresRow.IsPackageNameNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedures.PackageNameColumn);
end;

procedure TPackageProceduresRow.SetPackageNameNull;
begin
  Item[FTablePackageProcedures.PackageNameColumn] := DBNull.Value;
end;

function TPackageProceduresRow.IsProcedureNameNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedures.ProcedureNameColumn);
end;

procedure TPackageProceduresRow.SetProcedureNameNull;
begin
  Item[FTablePackageProcedures.ProcedureNameColumn] := DBNull.Value;
end;

function TPackageProceduresRow.IsProcedureTypeNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedures.ProcedureTypeColumn);
end;

procedure TPackageProceduresRow.SetProcedureTypeNull;
begin
  Item[FTablePackageProcedures.ProcedureTypeColumn] := DBNull.Value;
end;

function TPackageProceduresRow.GetCatalogName: WideString;
begin
  Result := Item[FTablePackageProcedures.CatalogNameColumn] as WideString;
end;

procedure TPackageProceduresRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTablePackageProcedures.CatalogNameColumn] := TObject(NewValue);
end;

function TPackageProceduresRow.GetSchemaName: WideString;
begin
  Result := Item[FTablePackageProcedures.SchemaNameColumn] as WideString;
end;

procedure TPackageProceduresRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTablePackageProcedures.SchemaNameColumn] := TObject(NewValue);
end;

function TPackageProceduresRow.GetPackageName: WideString;
begin
  Result := Item[FTablePackageProcedures.PackageNameColumn] as WideString;
end;

procedure TPackageProceduresRow.SetPackageName(NewValue: WideString);
begin
  Item[FTablePackageProcedures.PackageNameColumn] := TObject(NewValue);
end;

function TPackageProceduresRow.GetProcedureName: WideString;
begin
  Result := Item[FTablePackageProcedures.ProcedureNameColumn] as WideString;
end;

procedure TPackageProceduresRow.SetProcedureName(NewValue: WideString);
begin
  Item[FTablePackageProcedures.ProcedureNameColumn] := TObject(NewValue);
end;

function TPackageProceduresRow.GetProcedureType: WideString;
begin
  Result := Item[FTablePackageProcedures.ProcedureTypeColumn] as WideString;
end;

procedure TPackageProceduresRow.SetProcedureType(NewValue: WideString);
begin
  Item[FTablePackageProcedures.ProcedureTypeColumn] := TObject(NewValue);
end;

constructor TPackageProceduresTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.PackageProcedures;
  BeginInit();
  InitClass();
  EndInit();
end;

function TPackageProceduresTable.Clone: DataTable;
var
  NewClone: TPackageProceduresTable;
begin
  NewClone := TPackageProceduresTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TPackageProceduresTable.CreateInstance: DataTable;
begin
  Result := TPackageProceduresTable.Create;
end;

function TPackageProceduresTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TPackageProceduresTable.GetItem(Index: Integer): TPackageProceduresRow;
begin
  Result := TPackageProceduresRow(Rows.Item[Index]);
end;

function TPackageProceduresTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TPackageProceduresTable.AddPackageProceduresRow(Row: TPackageProceduresRow);
begin
  Rows.Add(Row);
end;

procedure TPackageProceduresTable.AddPackageProceduresRow(CatalogName: WideString; SchemaName: WideString; PackageName: WideString; ProcedureName: WideString; ProcedureType: WideString);
var
  NewRow: TPackageProceduresRow;
begin
  NewRow := NewPackageProceduresRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  NewRow.PackageName := PackageName;
  NewRow.ProcedureName := ProcedureName;
  NewRow.ProcedureType := ProcedureType;
  AddPackageProceduresRow(NewRow);
end;

function TPackageProceduresTable.NewPackageProceduresRow: TPackageProceduresRow;
begin
  Result := TPackageProceduresRow(NewRow);
end;

procedure TPackageProceduresTable.RemovePackageProceduresRow(Row: TPackageProceduresRow);
begin
  Rows.Remove(Row);
end;

function TPackageProceduresTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TPackageProceduresRow.Create(Builder);
end;

function TPackageProceduresTable.GetRowType: System.Type;
begin
  Result := typeof(TPackageProceduresRow);
end;

procedure TPackageProceduresTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXPackageProceduresColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXPackageProceduresColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
  FColumnPackageName := DataColumn.Create(TDBXPackageProceduresColumns.PackageName, typeof(WideString));
  FColumnPackageName.Caption := SPackageName;
  Columns.Add(FColumnPackageName);
  FColumnProcedureName := DataColumn.Create(TDBXPackageProceduresColumns.ProcedureName, typeof(WideString));
  FColumnProcedureName.Caption := SProcedureName;
  Columns.Add(FColumnProcedureName);
  FColumnProcedureType := DataColumn.Create(TDBXPackageProceduresColumns.ProcedureType, typeof(WideString));
  FColumnProcedureType.Caption := SProcedureType;
  Columns.Add(FColumnProcedureType);
end;

procedure TPackageProceduresTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXPackageProceduresColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXPackageProceduresColumns.SchemaName];
  FColumnPackageName := Columns[TDBXPackageProceduresColumns.PackageName];
  FColumnProcedureName := Columns[TDBXPackageProceduresColumns.ProcedureName];
  FColumnProcedureType := Columns[TDBXPackageProceduresColumns.ProcedureType];
end;

constructor TPackageProcedureParametersRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTablePackageProcedureParameters := TPackageProcedureParametersTable(Table);
end;

function TPackageProcedureParametersRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedureParameters.CatalogNameColumn);
end;

procedure TPackageProcedureParametersRow.SetCatalogNameNull;
begin
  Item[FTablePackageProcedureParameters.CatalogNameColumn] := DBNull.Value;
end;

function TPackageProcedureParametersRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedureParameters.SchemaNameColumn);
end;

procedure TPackageProcedureParametersRow.SetSchemaNameNull;
begin
  Item[FTablePackageProcedureParameters.SchemaNameColumn] := DBNull.Value;
end;

function TPackageProcedureParametersRow.IsPackageNameNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedureParameters.PackageNameColumn);
end;

procedure TPackageProcedureParametersRow.SetPackageNameNull;
begin
  Item[FTablePackageProcedureParameters.PackageNameColumn] := DBNull.Value;
end;

function TPackageProcedureParametersRow.IsProcedureNameNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedureParameters.ProcedureNameColumn);
end;

procedure TPackageProcedureParametersRow.SetProcedureNameNull;
begin
  Item[FTablePackageProcedureParameters.ProcedureNameColumn] := DBNull.Value;
end;

function TPackageProcedureParametersRow.IsParameterNameNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedureParameters.ParameterNameColumn);
end;

procedure TPackageProcedureParametersRow.SetParameterNameNull;
begin
  Item[FTablePackageProcedureParameters.ParameterNameColumn] := DBNull.Value;
end;

function TPackageProcedureParametersRow.IsParameterModeNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedureParameters.ParameterModeColumn);
end;

procedure TPackageProcedureParametersRow.SetParameterModeNull;
begin
  Item[FTablePackageProcedureParameters.ParameterModeColumn] := DBNull.Value;
end;

function TPackageProcedureParametersRow.IsTypeNameNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedureParameters.TypeNameColumn);
end;

procedure TPackageProcedureParametersRow.SetTypeNameNull;
begin
  Item[FTablePackageProcedureParameters.TypeNameColumn] := DBNull.Value;
end;

function TPackageProcedureParametersRow.IsPrecisionNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedureParameters.PrecisionColumn);
end;

procedure TPackageProcedureParametersRow.SetPrecisionNull;
begin
  Item[FTablePackageProcedureParameters.PrecisionColumn] := DBNull.Value;
end;

function TPackageProcedureParametersRow.IsScaleNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedureParameters.ScaleColumn);
end;

procedure TPackageProcedureParametersRow.SetScaleNull;
begin
  Item[FTablePackageProcedureParameters.ScaleColumn] := DBNull.Value;
end;

function TPackageProcedureParametersRow.IsOrdinalNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedureParameters.OrdinalColumn);
end;

procedure TPackageProcedureParametersRow.SetOrdinalNull;
begin
  Item[FTablePackageProcedureParameters.OrdinalColumn] := DBNull.Value;
end;

function TPackageProcedureParametersRow.IsIsNullableNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedureParameters.IsNullableColumn);
end;

procedure TPackageProcedureParametersRow.SetIsNullableNull;
begin
  Item[FTablePackageProcedureParameters.IsNullableColumn] := DBNull.Value;
end;

function TPackageProcedureParametersRow.IsDbxDataTypeNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedureParameters.DbxDataTypeColumn);
end;

procedure TPackageProcedureParametersRow.SetDbxDataTypeNull;
begin
  Item[FTablePackageProcedureParameters.DbxDataTypeColumn] := DBNull.Value;
end;

function TPackageProcedureParametersRow.IsIsFixedLengthNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedureParameters.IsFixedLengthColumn);
end;

procedure TPackageProcedureParametersRow.SetIsFixedLengthNull;
begin
  Item[FTablePackageProcedureParameters.IsFixedLengthColumn] := DBNull.Value;
end;

function TPackageProcedureParametersRow.IsIsUnicodeNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedureParameters.IsUnicodeColumn);
end;

procedure TPackageProcedureParametersRow.SetIsUnicodeNull;
begin
  Item[FTablePackageProcedureParameters.IsUnicodeColumn] := DBNull.Value;
end;

function TPackageProcedureParametersRow.IsIsLongNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedureParameters.IsLongColumn);
end;

procedure TPackageProcedureParametersRow.SetIsLongNull;
begin
  Item[FTablePackageProcedureParameters.IsLongColumn] := DBNull.Value;
end;

function TPackageProcedureParametersRow.IsIsUnsignedNull: Boolean;
begin
  Result := IsNull(FTablePackageProcedureParameters.IsUnsignedColumn);
end;

procedure TPackageProcedureParametersRow.SetIsUnsignedNull;
begin
  Item[FTablePackageProcedureParameters.IsUnsignedColumn] := DBNull.Value;
end;

function TPackageProcedureParametersRow.GetCatalogName: WideString;
begin
  Result := Item[FTablePackageProcedureParameters.CatalogNameColumn] as WideString;
end;

procedure TPackageProcedureParametersRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTablePackageProcedureParameters.CatalogNameColumn] := TObject(NewValue);
end;

function TPackageProcedureParametersRow.GetSchemaName: WideString;
begin
  Result := Item[FTablePackageProcedureParameters.SchemaNameColumn] as WideString;
end;

procedure TPackageProcedureParametersRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTablePackageProcedureParameters.SchemaNameColumn] := TObject(NewValue);
end;

function TPackageProcedureParametersRow.GetPackageName: WideString;
begin
  Result := Item[FTablePackageProcedureParameters.PackageNameColumn] as WideString;
end;

procedure TPackageProcedureParametersRow.SetPackageName(NewValue: WideString);
begin
  Item[FTablePackageProcedureParameters.PackageNameColumn] := TObject(NewValue);
end;

function TPackageProcedureParametersRow.GetProcedureName: WideString;
begin
  Result := Item[FTablePackageProcedureParameters.ProcedureNameColumn] as WideString;
end;

procedure TPackageProcedureParametersRow.SetProcedureName(NewValue: WideString);
begin
  Item[FTablePackageProcedureParameters.ProcedureNameColumn] := TObject(NewValue);
end;

function TPackageProcedureParametersRow.GetParameterName: WideString;
begin
  Result := Item[FTablePackageProcedureParameters.ParameterNameColumn] as WideString;
end;

procedure TPackageProcedureParametersRow.SetParameterName(NewValue: WideString);
begin
  Item[FTablePackageProcedureParameters.ParameterNameColumn] := TObject(NewValue);
end;

function TPackageProcedureParametersRow.GetParameterMode: WideString;
begin
  Result := Item[FTablePackageProcedureParameters.ParameterModeColumn] as WideString;
end;

procedure TPackageProcedureParametersRow.SetParameterMode(NewValue: WideString);
begin
  Item[FTablePackageProcedureParameters.ParameterModeColumn] := TObject(NewValue);
end;

function TPackageProcedureParametersRow.GetTypeName: WideString;
begin
  Result := Item[FTablePackageProcedureParameters.TypeNameColumn] as WideString;
end;

procedure TPackageProcedureParametersRow.SetTypeName(NewValue: WideString);
begin
  Item[FTablePackageProcedureParameters.TypeNameColumn] := TObject(NewValue);
end;

function TPackageProcedureParametersRow.GetPrecision: Integer;
begin
  Result := Item[FTablePackageProcedureParameters.PrecisionColumn] as Integer;
end;

procedure TPackageProcedureParametersRow.SetPrecision(NewValue: Integer);
begin
  Item[FTablePackageProcedureParameters.PrecisionColumn] := TObject(NewValue);
end;

function TPackageProcedureParametersRow.GetScale: Integer;
begin
  Result := Item[FTablePackageProcedureParameters.ScaleColumn] as Integer;
end;

procedure TPackageProcedureParametersRow.SetScale(NewValue: Integer);
begin
  Item[FTablePackageProcedureParameters.ScaleColumn] := TObject(NewValue);
end;

function TPackageProcedureParametersRow.GetOrdinal: Integer;
begin
  Result := Item[FTablePackageProcedureParameters.OrdinalColumn] as Integer;
end;

procedure TPackageProcedureParametersRow.SetOrdinal(NewValue: Integer);
begin
  Item[FTablePackageProcedureParameters.OrdinalColumn] := TObject(NewValue);
end;

function TPackageProcedureParametersRow.GetIsNullable: Boolean;
begin
  Result := Item[FTablePackageProcedureParameters.IsNullableColumn] as Boolean;
end;

procedure TPackageProcedureParametersRow.SetIsNullable(NewValue: Boolean);
begin
  Item[FTablePackageProcedureParameters.IsNullableColumn] := TObject(NewValue);
end;

function TPackageProcedureParametersRow.GetDbxDataType: Integer;
begin
  Result := Item[FTablePackageProcedureParameters.DbxDataTypeColumn] as Integer;
end;

procedure TPackageProcedureParametersRow.SetDbxDataType(NewValue: Integer);
begin
  Item[FTablePackageProcedureParameters.DbxDataTypeColumn] := TObject(NewValue);
end;

function TPackageProcedureParametersRow.GetIsFixedLength: Boolean;
begin
  Result := Item[FTablePackageProcedureParameters.IsFixedLengthColumn] as Boolean;
end;

procedure TPackageProcedureParametersRow.SetIsFixedLength(NewValue: Boolean);
begin
  Item[FTablePackageProcedureParameters.IsFixedLengthColumn] := TObject(NewValue);
end;

function TPackageProcedureParametersRow.GetIsUnicode: Boolean;
begin
  Result := Item[FTablePackageProcedureParameters.IsUnicodeColumn] as Boolean;
end;

procedure TPackageProcedureParametersRow.SetIsUnicode(NewValue: Boolean);
begin
  Item[FTablePackageProcedureParameters.IsUnicodeColumn] := TObject(NewValue);
end;

function TPackageProcedureParametersRow.GetIsLong: Boolean;
begin
  Result := Item[FTablePackageProcedureParameters.IsLongColumn] as Boolean;
end;

procedure TPackageProcedureParametersRow.SetIsLong(NewValue: Boolean);
begin
  Item[FTablePackageProcedureParameters.IsLongColumn] := TObject(NewValue);
end;

function TPackageProcedureParametersRow.GetIsUnsigned: Boolean;
begin
  Result := Item[FTablePackageProcedureParameters.IsUnsignedColumn] as Boolean;
end;

procedure TPackageProcedureParametersRow.SetIsUnsigned(NewValue: Boolean);
begin
  Item[FTablePackageProcedureParameters.IsUnsignedColumn] := TObject(NewValue);
end;

constructor TPackageProcedureParametersTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.PackageProcedureParameters;
  BeginInit();
  InitClass();
  EndInit();
end;

function TPackageProcedureParametersTable.Clone: DataTable;
var
  NewClone: TPackageProcedureParametersTable;
begin
  NewClone := TPackageProcedureParametersTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TPackageProcedureParametersTable.CreateInstance: DataTable;
begin
  Result := TPackageProcedureParametersTable.Create;
end;

function TPackageProcedureParametersTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TPackageProcedureParametersTable.GetItem(Index: Integer): TPackageProcedureParametersRow;
begin
  Result := TPackageProcedureParametersRow(Rows.Item[Index]);
end;

function TPackageProcedureParametersTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TPackageProcedureParametersTable.AddPackageProcedureParametersRow(Row: TPackageProcedureParametersRow);
begin
  Rows.Add(Row);
end;

procedure TPackageProcedureParametersTable.AddPackageProcedureParametersRow(CatalogName: WideString; SchemaName: WideString; PackageName: WideString; ProcedureName: WideString; ParameterName: WideString; ParameterMode: WideString; TypeName: WideString; Precision: Integer; Scale: Integer; Ordinal: Integer; IsNullable: Boolean; DbxDataType: Integer; IsFixedLength: Boolean; IsUnicode: Boolean; IsLong: Boolean; IsUnsigned: Boolean);
var
  NewRow: TPackageProcedureParametersRow;
begin
  NewRow := NewPackageProcedureParametersRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  NewRow.PackageName := PackageName;
  NewRow.ProcedureName := ProcedureName;
  NewRow.ParameterName := ParameterName;
  NewRow.ParameterMode := ParameterMode;
  NewRow.TypeName := TypeName;
  NewRow.Precision := Precision;
  NewRow.Scale := Scale;
  NewRow.Ordinal := Ordinal;
  NewRow.IsNullable := IsNullable;
  NewRow.DbxDataType := DbxDataType;
  NewRow.IsFixedLength := IsFixedLength;
  NewRow.IsUnicode := IsUnicode;
  NewRow.IsLong := IsLong;
  NewRow.IsUnsigned := IsUnsigned;
  AddPackageProcedureParametersRow(NewRow);
end;

function TPackageProcedureParametersTable.NewPackageProcedureParametersRow: TPackageProcedureParametersRow;
begin
  Result := TPackageProcedureParametersRow(NewRow);
end;

procedure TPackageProcedureParametersTable.RemovePackageProcedureParametersRow(Row: TPackageProcedureParametersRow);
begin
  Rows.Remove(Row);
end;

function TPackageProcedureParametersTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TPackageProcedureParametersRow.Create(Builder);
end;

function TPackageProcedureParametersTable.GetRowType: System.Type;
begin
  Result := typeof(TPackageProcedureParametersRow);
end;

procedure TPackageProcedureParametersTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXPackageProcedureParametersColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXPackageProcedureParametersColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
  FColumnPackageName := DataColumn.Create(TDBXPackageProcedureParametersColumns.PackageName, typeof(WideString));
  FColumnPackageName.Caption := SPackageName;
  Columns.Add(FColumnPackageName);
  FColumnProcedureName := DataColumn.Create(TDBXPackageProcedureParametersColumns.ProcedureName, typeof(WideString));
  FColumnProcedureName.Caption := SProcedureName;
  Columns.Add(FColumnProcedureName);
  FColumnParameterName := DataColumn.Create(TDBXPackageProcedureParametersColumns.ParameterName, typeof(WideString));
  FColumnParameterName.Caption := SParameterName;
  Columns.Add(FColumnParameterName);
  FColumnParameterMode := DataColumn.Create(TDBXPackageProcedureParametersColumns.ParameterMode, typeof(WideString));
  FColumnParameterMode.Caption := SParameterMode;
  Columns.Add(FColumnParameterMode);
  FColumnTypeName := DataColumn.Create(TDBXPackageProcedureParametersColumns.TypeName, typeof(WideString));
  FColumnTypeName.Caption := STypeName;
  Columns.Add(FColumnTypeName);
  FColumnPrecision := DataColumn.Create(TDBXPackageProcedureParametersColumns.Precision, typeof(Integer));
  FColumnPrecision.Caption := SPrecision;
  Columns.Add(FColumnPrecision);
  FColumnScale := DataColumn.Create(TDBXPackageProcedureParametersColumns.Scale, typeof(Integer));
  FColumnScale.Caption := SScale;
  Columns.Add(FColumnScale);
  FColumnOrdinal := DataColumn.Create(TDBXPackageProcedureParametersColumns.Ordinal, typeof(Integer));
  FColumnOrdinal.Caption := SOrdinal;
  Columns.Add(FColumnOrdinal);
  FColumnIsNullable := DataColumn.Create(TDBXPackageProcedureParametersColumns.IsNullable, typeof(Boolean));
  FColumnIsNullable.Caption := SIsNullable;
  Columns.Add(FColumnIsNullable);
  FColumnDbxDataType := DataColumn.Create(TDBXPackageProcedureParametersColumns.DbxDataType, typeof(Integer));
  FColumnDbxDataType.Caption := SDbxDataType;
  Columns.Add(FColumnDbxDataType);
  FColumnIsFixedLength := DataColumn.Create(TDBXPackageProcedureParametersColumns.IsFixedLength, typeof(Boolean));
  FColumnIsFixedLength.Caption := SIsFixedLength;
  Columns.Add(FColumnIsFixedLength);
  FColumnIsUnicode := DataColumn.Create(TDBXPackageProcedureParametersColumns.IsUnicode, typeof(Boolean));
  FColumnIsUnicode.Caption := SIsUnicode;
  Columns.Add(FColumnIsUnicode);
  FColumnIsLong := DataColumn.Create(TDBXPackageProcedureParametersColumns.IsLong, typeof(Boolean));
  FColumnIsLong.Caption := SIsLong;
  Columns.Add(FColumnIsLong);
  FColumnIsUnsigned := DataColumn.Create(TDBXPackageProcedureParametersColumns.IsUnsigned, typeof(Boolean));
  FColumnIsUnsigned.Caption := SIsUnsigned;
  Columns.Add(FColumnIsUnsigned);
end;

procedure TPackageProcedureParametersTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXPackageProcedureParametersColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXPackageProcedureParametersColumns.SchemaName];
  FColumnPackageName := Columns[TDBXPackageProcedureParametersColumns.PackageName];
  FColumnProcedureName := Columns[TDBXPackageProcedureParametersColumns.ProcedureName];
  FColumnParameterName := Columns[TDBXPackageProcedureParametersColumns.ParameterName];
  FColumnParameterMode := Columns[TDBXPackageProcedureParametersColumns.ParameterMode];
  FColumnTypeName := Columns[TDBXPackageProcedureParametersColumns.TypeName];
  FColumnPrecision := Columns[TDBXPackageProcedureParametersColumns.Precision];
  FColumnScale := Columns[TDBXPackageProcedureParametersColumns.Scale];
  FColumnOrdinal := Columns[TDBXPackageProcedureParametersColumns.Ordinal];
  FColumnIsNullable := Columns[TDBXPackageProcedureParametersColumns.IsNullable];
  FColumnDbxDataType := Columns[TDBXPackageProcedureParametersColumns.DbxDataType];
  FColumnIsFixedLength := Columns[TDBXPackageProcedureParametersColumns.IsFixedLength];
  FColumnIsUnicode := Columns[TDBXPackageProcedureParametersColumns.IsUnicode];
  FColumnIsLong := Columns[TDBXPackageProcedureParametersColumns.IsLong];
  FColumnIsUnsigned := Columns[TDBXPackageProcedureParametersColumns.IsUnsigned];
end;

constructor TPackageSourcesRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTablePackageSources := TPackageSourcesTable(Table);
end;

function TPackageSourcesRow.IsCatalogNameNull: Boolean;
begin
  Result := IsNull(FTablePackageSources.CatalogNameColumn);
end;

procedure TPackageSourcesRow.SetCatalogNameNull;
begin
  Item[FTablePackageSources.CatalogNameColumn] := DBNull.Value;
end;

function TPackageSourcesRow.IsSchemaNameNull: Boolean;
begin
  Result := IsNull(FTablePackageSources.SchemaNameColumn);
end;

procedure TPackageSourcesRow.SetSchemaNameNull;
begin
  Item[FTablePackageSources.SchemaNameColumn] := DBNull.Value;
end;

function TPackageSourcesRow.IsPackageNameNull: Boolean;
begin
  Result := IsNull(FTablePackageSources.PackageNameColumn);
end;

procedure TPackageSourcesRow.SetPackageNameNull;
begin
  Item[FTablePackageSources.PackageNameColumn] := DBNull.Value;
end;

function TPackageSourcesRow.IsDefinitionNull: Boolean;
begin
  Result := IsNull(FTablePackageSources.DefinitionColumn);
end;

procedure TPackageSourcesRow.SetDefinitionNull;
begin
  Item[FTablePackageSources.DefinitionColumn] := DBNull.Value;
end;

function TPackageSourcesRow.GetCatalogName: WideString;
begin
  Result := Item[FTablePackageSources.CatalogNameColumn] as WideString;
end;

procedure TPackageSourcesRow.SetCatalogName(NewValue: WideString);
begin
  Item[FTablePackageSources.CatalogNameColumn] := TObject(NewValue);
end;

function TPackageSourcesRow.GetSchemaName: WideString;
begin
  Result := Item[FTablePackageSources.SchemaNameColumn] as WideString;
end;

procedure TPackageSourcesRow.SetSchemaName(NewValue: WideString);
begin
  Item[FTablePackageSources.SchemaNameColumn] := TObject(NewValue);
end;

function TPackageSourcesRow.GetPackageName: WideString;
begin
  Result := Item[FTablePackageSources.PackageNameColumn] as WideString;
end;

procedure TPackageSourcesRow.SetPackageName(NewValue: WideString);
begin
  Item[FTablePackageSources.PackageNameColumn] := TObject(NewValue);
end;

function TPackageSourcesRow.GetDefinition: WideString;
begin
  Result := Item[FTablePackageSources.DefinitionColumn] as WideString;
end;

procedure TPackageSourcesRow.SetDefinition(NewValue: WideString);
begin
  Item[FTablePackageSources.DefinitionColumn] := TObject(NewValue);
end;

constructor TPackageSourcesTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.PackageSources;
  BeginInit();
  InitClass();
  EndInit();
end;

function TPackageSourcesTable.Clone: DataTable;
var
  NewClone: TPackageSourcesTable;
begin
  NewClone := TPackageSourcesTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TPackageSourcesTable.CreateInstance: DataTable;
begin
  Result := TPackageSourcesTable.Create;
end;

function TPackageSourcesTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TPackageSourcesTable.GetItem(Index: Integer): TPackageSourcesRow;
begin
  Result := TPackageSourcesRow(Rows.Item[Index]);
end;

function TPackageSourcesTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TPackageSourcesTable.AddPackageSourcesRow(Row: TPackageSourcesRow);
begin
  Rows.Add(Row);
end;

procedure TPackageSourcesTable.AddPackageSourcesRow(CatalogName: WideString; SchemaName: WideString; PackageName: WideString; Definition: WideString);
var
  NewRow: TPackageSourcesRow;
begin
  NewRow := NewPackageSourcesRow;
  NewRow.CatalogName := CatalogName;
  NewRow.SchemaName := SchemaName;
  NewRow.PackageName := PackageName;
  NewRow.Definition := Definition;
  AddPackageSourcesRow(NewRow);
end;

function TPackageSourcesTable.NewPackageSourcesRow: TPackageSourcesRow;
begin
  Result := TPackageSourcesRow(NewRow);
end;

procedure TPackageSourcesTable.RemovePackageSourcesRow(Row: TPackageSourcesRow);
begin
  Rows.Remove(Row);
end;

function TPackageSourcesTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TPackageSourcesRow.Create(Builder);
end;

function TPackageSourcesTable.GetRowType: System.Type;
begin
  Result := typeof(TPackageSourcesRow);
end;

procedure TPackageSourcesTable.InitClass;
begin
  FColumnCatalogName := DataColumn.Create(TDBXPackageSourcesColumns.CatalogName, typeof(WideString));
  FColumnCatalogName.Caption := SCatalogName;
  Columns.Add(FColumnCatalogName);
  FColumnSchemaName := DataColumn.Create(TDBXPackageSourcesColumns.SchemaName, typeof(WideString));
  FColumnSchemaName.Caption := SSchemaName;
  Columns.Add(FColumnSchemaName);
  FColumnPackageName := DataColumn.Create(TDBXPackageSourcesColumns.PackageName, typeof(WideString));
  FColumnPackageName.Caption := SPackageName;
  Columns.Add(FColumnPackageName);
  FColumnDefinition := DataColumn.Create(TDBXPackageSourcesColumns.Definition, typeof(WideString));
  FColumnDefinition.Caption := SDefinition;
  Columns.Add(FColumnDefinition);
end;

procedure TPackageSourcesTable.InitVariables;
begin
  FColumnCatalogName := Columns[TDBXPackageSourcesColumns.CatalogName];
  FColumnSchemaName := Columns[TDBXPackageSourcesColumns.SchemaName];
  FColumnPackageName := Columns[TDBXPackageSourcesColumns.PackageName];
  FColumnDefinition := Columns[TDBXPackageSourcesColumns.Definition];
end;

constructor TUsersRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableUsers := TUsersTable(Table);
end;

function TUsersRow.IsUserNameNull: Boolean;
begin
  Result := IsNull(FTableUsers.UserNameColumn);
end;

procedure TUsersRow.SetUserNameNull;
begin
  Item[FTableUsers.UserNameColumn] := DBNull.Value;
end;

function TUsersRow.GetUserName: WideString;
begin
  Result := Item[FTableUsers.UserNameColumn] as WideString;
end;

procedure TUsersRow.SetUserName(NewValue: WideString);
begin
  Item[FTableUsers.UserNameColumn] := TObject(NewValue);
end;

constructor TUsersTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.Users;
  BeginInit();
  InitClass();
  EndInit();
end;

function TUsersTable.Clone: DataTable;
var
  NewClone: TUsersTable;
begin
  NewClone := TUsersTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TUsersTable.CreateInstance: DataTable;
begin
  Result := TUsersTable.Create;
end;

function TUsersTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TUsersTable.GetItem(Index: Integer): TUsersRow;
begin
  Result := TUsersRow(Rows.Item[Index]);
end;

function TUsersTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TUsersTable.AddUsersRow(Row: TUsersRow);
begin
  Rows.Add(Row);
end;

procedure TUsersTable.AddUsersRow(UserName: WideString);
var
  NewRow: TUsersRow;
begin
  NewRow := NewUsersRow;
  NewRow.UserName := UserName;
  AddUsersRow(NewRow);
end;

function TUsersTable.NewUsersRow: TUsersRow;
begin
  Result := TUsersRow(NewRow);
end;

procedure TUsersTable.RemoveUsersRow(Row: TUsersRow);
begin
  Rows.Remove(Row);
end;

function TUsersTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TUsersRow.Create(Builder);
end;

function TUsersTable.GetRowType: System.Type;
begin
  Result := typeof(TUsersRow);
end;

procedure TUsersTable.InitClass;
begin
  FColumnUserName := DataColumn.Create(TDBXUsersColumns.UserName, typeof(WideString));
  FColumnUserName.Caption := SUserName;
  Columns.Add(FColumnUserName);
end;

procedure TUsersTable.InitVariables;
begin
  FColumnUserName := Columns[TDBXUsersColumns.UserName];
end;

constructor TRolesRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableRoles := TRolesTable(Table);
end;

function TRolesRow.IsRoleNameNull: Boolean;
begin
  Result := IsNull(FTableRoles.RoleNameColumn);
end;

procedure TRolesRow.SetRoleNameNull;
begin
  Item[FTableRoles.RoleNameColumn] := DBNull.Value;
end;

function TRolesRow.GetRoleName: WideString;
begin
  Result := Item[FTableRoles.RoleNameColumn] as WideString;
end;

procedure TRolesRow.SetRoleName(NewValue: WideString);
begin
  Item[FTableRoles.RoleNameColumn] := TObject(NewValue);
end;

constructor TRolesTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.Roles;
  BeginInit();
  InitClass();
  EndInit();
end;

function TRolesTable.Clone: DataTable;
var
  NewClone: TRolesTable;
begin
  NewClone := TRolesTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TRolesTable.CreateInstance: DataTable;
begin
  Result := TRolesTable.Create;
end;

function TRolesTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TRolesTable.GetItem(Index: Integer): TRolesRow;
begin
  Result := TRolesRow(Rows.Item[Index]);
end;

function TRolesTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TRolesTable.AddRolesRow(Row: TRolesRow);
begin
  Rows.Add(Row);
end;

procedure TRolesTable.AddRolesRow(RoleName: WideString);
var
  NewRow: TRolesRow;
begin
  NewRow := NewRolesRow;
  NewRow.RoleName := RoleName;
  AddRolesRow(NewRow);
end;

function TRolesTable.NewRolesRow: TRolesRow;
begin
  Result := TRolesRow(NewRow);
end;

procedure TRolesTable.RemoveRolesRow(Row: TRolesRow);
begin
  Rows.Remove(Row);
end;

function TRolesTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TRolesRow.Create(Builder);
end;

function TRolesTable.GetRowType: System.Type;
begin
  Result := typeof(TRolesRow);
end;

procedure TRolesTable.InitClass;
begin
  FColumnRoleName := DataColumn.Create(TDBXRolesColumns.RoleName, typeof(WideString));
  FColumnRoleName.Caption := SRoleName;
  Columns.Add(FColumnRoleName);
end;

procedure TRolesTable.InitVariables;
begin
  FColumnRoleName := Columns[TDBXRolesColumns.RoleName];
end;

constructor TReservedWordsRow.Create(Builder: DataRowBuilder);
begin
  Inherited Create(Builder);
  FTableReservedWords := TReservedWordsTable(Table);
end;

function TReservedWordsRow.IsReservedWordNull: Boolean;
begin
  Result := IsNull(FTableReservedWords.ReservedWordColumn);
end;

procedure TReservedWordsRow.SetReservedWordNull;
begin
  Item[FTableReservedWords.ReservedWordColumn] := DBNull.Value;
end;

function TReservedWordsRow.GetReservedWord: WideString;
begin
  Result := Item[FTableReservedWords.ReservedWordColumn] as WideString;
end;

procedure TReservedWordsRow.SetReservedWord(NewValue: WideString);
begin
  Item[FTableReservedWords.ReservedWordColumn] := TObject(NewValue);
end;

constructor TReservedWordsTable.Create;
begin
  Inherited Create;
  TableName := TDBXMetaDataCollectionName.ReservedWords;
  BeginInit();
  InitClass();
  EndInit();
end;

function TReservedWordsTable.Clone: DataTable;
var
  NewClone: TReservedWordsTable;
begin
  NewClone := TReservedWordsTable(Inherited Clone);
  NewClone.InitVariables();
  Result := NewClone;
end;

function TReservedWordsTable.CreateInstance: DataTable;
begin
  Result := TReservedWordsTable.Create;
end;

function TReservedWordsTable.GetEnumerator: IEnumerator;
begin
  Result := Rows.GetEnumerator
end;

function TReservedWordsTable.GetItem(Index: Integer): TReservedWordsRow;
begin
  Result := TReservedWordsRow(Rows.Item[Index]);
end;

function TReservedWordsTable.GetCount: Integer;
begin
  Result := Rows.Count
end;

procedure TReservedWordsTable.AddReservedWordsRow(Row: TReservedWordsRow);
begin
  Rows.Add(Row);
end;

procedure TReservedWordsTable.AddReservedWordsRow(ReservedWord: WideString);
var
  NewRow: TReservedWordsRow;
begin
  NewRow := NewReservedWordsRow;
  NewRow.ReservedWord := ReservedWord;
  AddReservedWordsRow(NewRow);
end;

function TReservedWordsTable.NewReservedWordsRow: TReservedWordsRow;
begin
  Result := TReservedWordsRow(NewRow);
end;

procedure TReservedWordsTable.RemoveReservedWordsRow(Row: TReservedWordsRow);
begin
  Rows.Remove(Row);
end;

function TReservedWordsTable.NewRowFromBuilder(Builder: DataRowBuilder): DataRow;
begin
  Result := TReservedWordsRow.Create(Builder);
end;

function TReservedWordsTable.GetRowType: System.Type;
begin
  Result := typeof(TReservedWordsRow);
end;

procedure TReservedWordsTable.InitClass;
begin
  FColumnReservedWord := DataColumn.Create(TDBXReservedWordsColumns.ReservedWord, typeof(WideString));
  FColumnReservedWord.Caption := SReservedWord;
  Columns.Add(FColumnReservedWord);
end;

procedure TReservedWordsTable.InitVariables;
begin
  FColumnReservedWord := Columns[TDBXReservedWordsColumns.ReservedWord];
end;

end.
