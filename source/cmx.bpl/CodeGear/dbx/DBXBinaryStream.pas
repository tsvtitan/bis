// DO NOT EDIT THIS FILE - WARNING WARNING - Generated file
unit DBXBinaryStream;
interface
uses
  DBXPlatform,
  SysUtils;
type
  TDBXBinaryStream = class
  public
    constructor Create;
    destructor Destroy; override;
    procedure Growbuf(BytesNeeded: Integer);
    function Skip(Length: Integer): Integer;
    function ReadBoolean: Boolean;
    function ReadByte: Byte;
    function ReadInt32: Integer;
    function ReadInt16: SmallInt;
    function ReadInt64: Int64;
    function ReadSingle: Single;
    function ReadDoubleAsInt64: Int64;
    function ReadDouble: Double;
    function ReadTimestamp: Int64;
    function ReadTimestampNanos: Integer;
    procedure ReadBigDecimalBuffer;
    function BigDecimalFitsInInt64: Boolean;
  protected
    procedure SetMinBufferSize(Size: Integer);
    function SkipNullTermString: Integer;
    procedure SkipField;
    function GetBigDecimalBufferAsInt64: Int64;
    function GetBigDecimalLength: Integer;
  protected
    FTwoByteStringTerminator: Boolean;
    FBuf: TBytes;
    FBufLength: Integer;
    FOff: Integer;
    FCurrentOrdinal: Integer;
    FBigDecimalBuffer: TBytes;
    FBigDecimalLength: TDBXInt32s;
    FBigDecimalScale: Integer;
    FBigDecimalSignum: Integer;
  private
    FNanos: Integer;
  public
    property MinBufferSize: Integer write SetMinBufferSize;
    property Buffer: TBytes read FBuf;
    property BufferOffset: Integer read FOff;
    property BigDecimalBuffer: TBytes read FBigDecimalBuffer;
    property BigDecimalBufferAsInt64: Int64 read GetBigDecimalBufferAsInt64;
    property BigDecimalLength: Integer read GetBigDecimalLength;
    property BigDecimalSignum: Integer read FBigDecimalSignum;
    property BigDecimalScale: Integer read FBigDecimalScale;
    property CurrentOrdinal: Integer read FCurrentOrdinal;
  end;

implementation
uses
  DBXFieldHeader,
  DBXFieldPacker,
  DBXPlatformUtil;

constructor TDBXBinaryStream.Create;
begin
  inherited Create;
  SetLength(FBigDecimalBuffer,TDBXFieldHeader.FTinyHeaderLengthMask + TDBXFieldHeader.FTinyHeaderLength);
  SetLength(FBigDecimalLength,1);
end;

destructor TDBXBinaryStream.Destroy;
begin
  FBigDecimalBuffer := nil;
  FBigDecimalLength := nil;
  FBuf := nil;
  inherited Destroy;
end;

procedure TDBXBinaryStream.SetMinBufferSize(Size: Integer);
begin
  if FBufLength < Size then
  begin
    SetLength(FBuf,Size);
    FBufLength := Size;
  end;
end;

procedure TDBXBinaryStream.Growbuf(BytesNeeded: Integer);
var
  Newbuf: TBytes;
begin
  SetLength(Newbuf,FBufLength + BytesNeeded);
  TDBXPlatform.CopyByteArray(FBuf, 0, Newbuf, 0, FBufLength);
  FBuf := Newbuf;
  FBufLength := Length(Newbuf);
end;

function TDBXBinaryStream.SkipNullTermString: Integer;
var
  Temp: Integer;
begin
  ;
  Temp := FOff;
  if FTwoByteStringTerminator then
  begin
    while (FBuf[Incr(Temp)] <> 0) or (FBuf[Incr(Temp)] <> 0) do
    begin
    end;
    ;
  end
  else 
  begin
    while (FBuf[Incr(Temp)] <> 0) or (FBuf[Incr(Temp)] <> 0) or (FBuf[Incr(Temp)] <> 0) do
    begin
    end;
    ;
  end;
  Result := Incr(Temp) - FOff;
end;

function TDBXBinaryStream.Skip(Length: Integer): Integer;
begin
  FOff := FOff + Length;
  Result := Length;
end;

procedure TDBXBinaryStream.SkipField;
var
  Header: Byte;
  Size: Integer;
begin
  Header := FBuf[FOff];
  if (Header and TDBXFieldHeader.FNullValue) <> 0 then
    Size := 1
  else if (Header and TDBXFieldHeader.FTinyField) = TDBXFieldHeader.FTinyField then
    Size := (Header and TDBXFieldHeader.FTinyHeaderLengthMask) + TDBXFieldHeader.FTinyHeaderLength
  else if (Header and TDBXFieldHeader.FBigField) = TDBXFieldHeader.FBigField then
    Size := (((FBuf[FOff + 1] and 255) shl 8) or (FBuf[FOff + 2] and 255)) + TDBXFieldHeader.FBigHeaderLength
  else if (Header and TDBXFieldHeader.FBlobHeader) = TDBXFieldHeader.FBlobHeader then
    Size := TDBXFieldPacker.GetBlobHeaderLength(FBuf, FOff)
  else if Header = TDBXFieldHeader.FNullTermStringField then
    Size := SkipNullTermString
  else 
  begin
    ;
    Size := 0;
  end;
  FOff := FOff + Size;
  Incr(FCurrentOrdinal);
end;

function TDBXBinaryStream.ReadBoolean: Boolean;
var
  Data: Boolean;
begin
  Data := ((FBuf[IncrAfter(FOff)] and TDBXFieldHeader.FPositive) <> 0);
  Incr(FCurrentOrdinal);
  Result := Data;
end;

function TDBXBinaryStream.ReadByte: Byte;
var
  Len: Integer;
  Data: SmallInt;
begin
  Len := (FBuf[FOff] and TDBXFieldHeader.FTinyHeaderLengthMask);
  Data := TDBXFieldPacker.UnpackAsciiShort(FBuf, FOff);
  FOff := FOff + TDBXFieldHeader.FTinyHeaderLength + Len;
  Incr(FCurrentOrdinal);
  Result := Byte(Data);
end;

function TDBXBinaryStream.ReadInt32: Integer;
var
  Len: Integer;
  Data: Integer;
begin
  Len := (FBuf[FOff] and TDBXFieldHeader.FTinyHeaderLengthMask);
  Data := TDBXFieldPacker.UnpackAsciiInt(FBuf, FOff);
  FOff := FOff + TDBXFieldHeader.FTinyHeaderLength + Len;
  Incr(FCurrentOrdinal);
  Result := Data;
end;

function TDBXBinaryStream.ReadInt16: SmallInt;
var
  Len: Integer;
  Data: SmallInt;
begin
  Len := (FBuf[FOff] and TDBXFieldHeader.FTinyHeaderLengthMask);
  Data := TDBXFieldPacker.UnpackAsciiShort(FBuf, FOff);
  FOff := FOff + TDBXFieldHeader.FTinyHeaderLength + Len;
  Incr(FCurrentOrdinal);
  Result := Data;
end;

function TDBXBinaryStream.ReadInt64: Int64;
var
  Len: Integer;
  Data: Int64;
begin
  Len := (FBuf[FOff] and TDBXFieldHeader.FTinyHeaderLengthMask);
  Data := TDBXFieldPacker.UnpackAsciiLong(FBuf, FOff);
  FOff := FOff + TDBXFieldHeader.FTinyHeaderLength + Len;
  Incr(FCurrentOrdinal);
  Result := Data;
end;

function TDBXBinaryStream.ReadSingle: Single;
var
  Len: Integer;
  Data: Single;
begin
  Len := (FBuf[FOff] and TDBXFieldHeader.FTinyHeaderLengthMask);
  Data := TDBXFieldPacker.UnpackFloat(FBuf, FOff);
  FOff := FOff + TDBXFieldHeader.FTinyHeaderLength + Len;
  Incr(FCurrentOrdinal);
  Result := Data;
end;

function TDBXBinaryStream.ReadDoubleAsInt64: Int64;
var
  Len: Integer;
  Data: Int64;
begin
  Len := (FBuf[FOff] and TDBXFieldHeader.FTinyHeaderLengthMask);
  Data := TDBXFieldPacker.UnpackDoubleAsInt64(FBuf, FOff);
  FOff := FOff + TDBXFieldHeader.FTinyHeaderLength + Len;
  Incr(FCurrentOrdinal);
  Result := Data;
end;

function TDBXBinaryStream.ReadDouble: Double;
var
  Len: Integer;
  Data: Double;
begin
  Len := (FBuf[FOff] and TDBXFieldHeader.FTinyHeaderLengthMask);
  Data := TDBXFieldPacker.UnpackDouble(FBuf, FOff);
  FOff := FOff + TDBXFieldHeader.FTinyHeaderLength + Len;
  Incr(FCurrentOrdinal);
  Result := Data;
end;

function TDBXBinaryStream.ReadTimestamp: Int64;
var
  StartPos: Integer;
  Length: Integer;
  TimeValue: Int64;
  MillisLength: Integer;
begin
  StartPos := FOff;
  Length := (FBuf[IncrAfter(FOff)] and TDBXFieldHeader.FTinyHeaderLengthMask);
  MillisLength := (FBuf[FOff] and TDBXFieldHeader.FTinyHeaderLengthMask);
  TimeValue := TDBXFieldPacker.UnpackAsciiLong(FBuf, FOff);
  FOff := FOff + TDBXFieldHeader.FTinyHeaderLength + MillisLength;
  FNanos := 0;
  if StartPos + Length > FOff then
  begin
    FNanos := TDBXFieldPacker.UnpackInt(FBuf, FOff);
    FOff := FOff + 4;
  end;
  Incr(FCurrentOrdinal);
  Result := TimeValue;
end;

function TDBXBinaryStream.ReadTimestampNanos: Integer;
begin
  Result := FNanos;
end;

procedure TDBXBinaryStream.ReadBigDecimalBuffer;
var
  Header: Integer;
  Len: Integer;
begin
  Header := Integer(FBuf[FOff]);
  Len := (Header and TDBXFieldHeader.FTinyHeaderLengthMask) - 1;
  FBigDecimalScale := FBuf[FOff + 1] and 127;
  if (Header and TDBXFieldHeader.FPositive) = 0 then
    FBigDecimalSignum := -1
  else if Len > 0 then
    FBigDecimalSignum := 1
  else 
    FBigDecimalSignum := 0;
  TDBXFieldPacker.UnpackBigDecimal(FBuf, FOff, FBigDecimalBuffer, FBigDecimalLength);
  FOff := FOff + TDBXFieldHeader.FTinyHeaderLength + Len + 1;
  Incr(FCurrentOrdinal);
end;

function TDBXBinaryStream.BigDecimalFitsInInt64: Boolean;
begin
  Result := (FBigDecimalLength[0] < 8) or ((FBigDecimalLength[0] = 8) and ((FBigDecimalBuffer[0] and 128) = 0));
end;

function TDBXBinaryStream.GetBigDecimalBufferAsInt64: Int64;
var
  Value: Int64;
  ByteCount: Integer;
  Index: Integer;
begin
  if FBigDecimalLength[0] < 8 then
    ByteCount := FBigDecimalLength[0]
  else 
    ByteCount := 8;
  Value := 0;
  for index := 0 to ByteCount - 1 do
  begin
    Value := Value shl 8;
    Value := Value or FBigDecimalBuffer[Index];
  end;
  Result := Value;
end;

function TDBXBinaryStream.GetBigDecimalLength: Integer;
begin
  Result := FBigDecimalLength[0];
end;

end.
