// DO NOT EDIT THIS FILE - WARNING WARNING - Generated file
unit DBXStringDecoder;
interface
uses
  DBXCharDecoder,
  DBXPlatform,
  SysUtils;
type
  TDBXStringDecoder = class(TDBXCharDecoder)
  public
    procedure InitWideCharsDecoder(const OutBuf: TDBXWideChars);
    procedure InitByteDecoder; overload;
    procedure InitByteDecoder(ExpectedSize: Integer); overload;
    function DecodeToWideBytes(const InBuf: TBytes; InOff: Integer; const OutBuf: TBytes; MaxBytes: Integer): Boolean;
    function DecodeBytes(InBuf: TBytes; InOff: Integer; MaxBytes: Integer): Boolean;
    function ExtractDecodeByteBuffer: TBytes;
    destructor Destroy; override;
  private
    procedure GrowDecodeByteBuf;
    function DecodeCharsToBytes(InBuf: TBytes; InOff: Integer; DecodeByteBuf: TBytes; OutOff: Integer; MaxOff: Integer): Boolean;
  private
    FMaxOff: Integer;
    FDecodeByteBuf: TBytes;
    FDecodeByteOff: Integer;
    FDecodeByteLength: Integer;
  public
    property DecodeLength: Integer read FDecodeLength;
    property DecodeByteOff: Integer read FDecodeByteOff;
  end;

implementation
uses
  DBXPlatformUtil;

procedure TDBXStringDecoder.InitWideCharsDecoder(const OutBuf: TDBXWideChars);
begin
  FDecodeBuf := OutBuf;
  FDecodeLength := Length(OutBuf);
  InitDecoder;
end;

procedure TDBXStringDecoder.InitByteDecoder;
begin
  if FDecodeByteOff > FMaxOff then
    FMaxOff := FDecodeByteOff;
  FDecodeByteOff := -1;
  FHitChar := False;
  FHasHalfChar := False;
  FAddQuotes := False;
end;

procedure TDBXStringDecoder.GrowDecodeByteBuf;
var
  NewSize: Integer;
  NewDecodeByteBuf: TBytes;
begin
  NewSize := FDecodeLength * 2;
  if NewSize < 1 then
    NewSize := 16;
  if FDecodeByteLength < NewSize then
  begin
    FDecodeLength := NewSize;
    SetLength(NewDecodeByteBuf,NewSize);
    if FDecodeBuf <> nil then
      TDBXPlatform.CopyByteArray(FDecodeByteBuf, 0, NewDecodeByteBuf, 0, FDecodeOff);
    FDecodeByteBuf := NewDecodeByteBuf;
  end;
end;

procedure TDBXStringDecoder.InitByteDecoder(ExpectedSize: Integer);
begin
  SetLength(FDecodeByteBuf,ExpectedSize);
  FDecodeByteLength := ExpectedSize;
  InitByteDecoder;
end;

function TDBXStringDecoder.DecodeToWideBytes(const InBuf: TBytes; InOff: Integer; const OutBuf: TBytes; MaxBytes: Integer): Boolean;
begin
  FDecodeByteBuf := OutBuf;
  FDecodeByteLength := Length(OutBuf);
  InitByteDecoder;
  Result := DecodeBytes(InBuf, InOff, MaxBytes);
end;

function TDBXStringDecoder.DecodeBytes(InBuf: TBytes; InOff: Integer; MaxBytes: Integer): Boolean;
var
  Complete: Boolean;
  MaxOff: Integer;
  OutOff: Integer;
  B: Byte;
begin
  MaxOff := InOff + MaxBytes;
  OutOff := FDecodeByteOff;
  ;
  if FHitChar then
  begin
    Result := DecodeCharsToBytes(InBuf, InOff, FDecodeByteBuf, OutOff, MaxOff);
    exit;
  end;
  Decr(InOff);
  while Incr(InOff) < MaxOff do
  begin
    B := InBuf[InOff];
    if (B = Ord(#$0)) and FNullTerminated then
    begin
      FDecodeByteOff := OutOff;
      begin
        Result := True;
        exit;
      end;
    end
    else if B = Byte(255) then
    begin
      FHitChar := True;
      Incr(InOff);
      Complete := DecodeCharsToBytes(InBuf, InOff, FDecodeByteBuf, OutOff, MaxOff);
      begin
        Result := Complete;
        exit;
      end;
    end;
    if (OutOff + 2) >= FDecodeByteLength then
      GrowDecodeByteBuf;
    FDecodeByteBuf[Incr(OutOff)] := Byte((B and 255));
    FDecodeByteBuf[Incr(OutOff)] := Byte(0);
  end;
  if (OutOff + 2) >= FDecodeByteLength then
    GrowDecodeByteBuf;
  FDecodeByteBuf[Incr(OutOff)] := Ord(#$0);
  FDecodeByteBuf[Incr(OutOff)] := Ord(#$0);
  FDecodeByteOff := OutOff;
  Result := True;
end;

function TDBXStringDecoder.DecodeCharsToBytes(InBuf: TBytes; InOff: Integer; DecodeByteBuf: TBytes; OutOff: Integer; MaxOff: Integer): Boolean;
var
  Ch: WideChar;
begin
  ;
  DecrAfter(InOff);
  MaxOff := MaxOff - 2;
  if FHasHalfChar then
  begin
    if Incr(FDecodeByteOff) >= FDecodeByteLength then
    begin
      FDecodeByteOff := OutOff;
      begin
        Result := False;
        exit;
      end;
    end;
    if (OutOff + 2) >= FDecodeByteLength then
      GrowDecodeByteBuf;
    DecodeByteBuf[Incr(OutOff)] := Byte(FHalfChar);
    DecodeByteBuf[Incr(OutOff)] := Byte((InBuf[Incr(InOff)] and 255));
    FHasHalfChar := False;
  end;
  while InOff < MaxOff do
  begin
    Ch := WideChar(((Integer((InBuf[Incr(InOff)] and 255))) shl 8 or (Integer(InBuf[Incr(InOff)]) and 255)));
    if (Ch = #$0) and FNullTerminated then
    begin
      FDecodeByteOff := OutOff;
      begin
        Result := True;
        exit;
      end;
    end;
    if (OutOff + 2) >= FDecodeByteLength then
      GrowDecodeByteBuf;
    DecodeByteBuf[Incr(OutOff)] := Byte((Ord(Ch) and 255));
    DecodeByteBuf[Incr(OutOff)] := Byte((Ord(Ch) shr 8));
  end;
  if InOff = MaxOff then
  begin
    FHalfChar := InBuf[Incr(InOff)];
    FHasHalfChar := True;
  end;
  if (OutOff + 2) >= FDecodeByteLength then
    GrowDecodeByteBuf;
  DecodeByteBuf[Incr(OutOff)] := Ord(#$0);
  DecodeByteBuf[Incr(OutOff)] := Ord(#$0);
  FDecodeByteOff := OutOff;
  Result := True;
end;

function TDBXStringDecoder.ExtractDecodeByteBuffer: TBytes;
var
  RetBuffer: TBytes;
begin
  RetBuffer := FDecodeByteBuf;
  FDecodeBuf := nil;
  Result := RetBuffer;
end;

destructor TDBXStringDecoder.Destroy;
begin
  FDecodeBuf := nil;
  inherited Destroy;
end;

end.
