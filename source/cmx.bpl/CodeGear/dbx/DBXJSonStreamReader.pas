// DO NOT EDIT THIS FILE - WARNING WARNING - Generated file
unit DBXJSonStreamReader;
interface
uses
  DBXChannel,
  DBXErrorHandler,
  DBXPlatform,
  DBXTraceHandler,
  SysUtils;
type
  
  /// <summary> Goal is to be fast, not concise.
  /// </summary>
  /// <remarks>
  /// </remarks>
  TDBXJSonStreamReader = class
  public
    function Next: Integer; overload;
    procedure SkipToEndOfObject; virtual;
    procedure SkipToEndOfArray; virtual;
    function ReadParams: Integer;
    function Next(ExpectedToken: Integer): Integer; overload;
    function NextValueSeparator: Integer;
    function ReadIntResultObject: Integer; virtual;
    procedure NextResultObjectStart; virtual;
    procedure ReadErrorBody; virtual;
    function ReadMethod: Integer;
    procedure FillBuffer(Bytes: TBytes); overload; virtual;
    procedure ReadDataBytes(Buffer: TBytes; ReadOff: Integer; Count: Integer); virtual;
    function ReadBoolean: Boolean; virtual;
    function ReadInt: Integer; virtual;
    function GetBytes(Buffer: TBytes; Offset: Int64; Count: Int64): Int64; virtual;
    function ReadByte: Byte; virtual;
    function ReadShort: SmallInt; virtual;
    function ReadLong: Int64; virtual;
    function ReadFloat: Single; virtual;
    function ReadDouble: Double; virtual;
    procedure Open; virtual;
    procedure Close; virtual;
    function ReadString: WideString;
    function ReadStringCode: Integer;
    function GetBooleanValue: Boolean;
    destructor Destroy; override;
  protected
    function NextNumber: Integer;
    function NextString: Integer; overload;
    function GetByteLength: Int64; virtual;
    function GetStringValue: WideString;
    procedure GrowCharBuffer;
    procedure GrowByteBuffer;
    procedure CreateBuffers; virtual;
    function GetTheTraceHandler: TDBXTraceHandler; virtual;
    procedure SetTheTraceHandler(TraceHandler: TDBXTraceHandler); virtual;
  private
    procedure SkipString;
    function ReadBinaryInt: Integer;
    procedure NextDataStoreHeader;
    procedure UnexpectedByte(UnexpectedByte: Byte);
    procedure UnexpectedToken(ExpectedToken: Integer);
    function TokenToString(Token: Integer): WideString;
    procedure UnexpectedString(ExpectedString: WideString);
    function NextMethod: Integer;
    procedure ParseStringCode;
    function NextColon: Integer;
    function NextVersion: Integer;
    function NextString(ExpectedString: WideString; Offset: Integer; Count: Integer): Integer; overload;
    function HexToDecimal(Value: Byte): Integer;
    function NextString(StartPosition: Integer): Integer; overload;
    function BytesToString(Count: Integer): WideString;
    procedure TraceRead;
    procedure ReadError;
    procedure FillBuffer; overload;
  protected
    FErrorHandler: TDBXErrorHandler;
    FTraceHandler: TDBXTraceHandler;
    FToken: Integer;
    FStringCode: Integer;
    FStringValue: WideString;
    FLongValue: Int64;
    FDoubleValue: Double;
    FBooleanValue: Boolean;
    FCharBuffer: TDBXWideChars;
    FCharBufferSize: Integer;
    FCharBufferCount: Integer;
    FByteBuffer: TBytes;
    FByteBufferSize: Integer;
    FByteBufferCount: Integer;
    FReadBuffer: TBytes;
    FReadPosition: Integer;
    FReadLastPosition: Integer;
    FChannel: TDBXChannel;
  private
    FReadBufferSize: Integer;
  public
    property ByteLength: Int64 read GetByteLength;
    property DbxChannel: TDBXChannel write FChannel;
    property StringCode: Integer read FStringCode;
    property Token: Integer read FToken;
    property StringValue: WideString read GetStringValue;
    property LongValue: Int64 read FLongValue;
    property DoubleValue: Double read FDoubleValue;
    property TheReadBufferSize: Integer write FReadBufferSize;
    property ReadBufferSize: Integer read FReadBufferSize;
    property TheErrorHandler: TDBXErrorHandler write FErrorHandler;
    property ErrorHandler: TDBXErrorHandler read FErrorHandler;
    property TheTraceHandler: TDBXTraceHandler read GetTheTraceHandler write SetTheTraceHandler;
  private
    const TrueString = 'true';
    const FalseString = 'false';
    const NullString = 'null';
    const MethodString = '"method"';
    const ParamsString = '"params"';
    const ResultString = '"result"';
    const ErrorString = '"error"';
  end;

implementation
uses
  DBXPlatformUtil,
  DBXRpcErrorCodes,
  DBXStringCodes,
  DBXTokens;

//  private static final String VERSION_STRING  = "\"version\"";
function TDBXJSonStreamReader.Next: Integer;
var
  LocalBuffer: TBytes;
  ReadByte: Byte;
begin
  LocalBuffer := FReadBuffer;
  while True do
  begin
    if Incr(FReadPosition) > FReadLastPosition then
      FillBuffer;
    ReadByte := LocalBuffer[FReadPosition];
    case ReadByte of
      Ord('{'):
        begin
          FToken := TDBXTokens.ObjectStartToken;
          begin
            Result := FToken;
            exit;
          end;
        end;
      Ord('}'):
        begin
          FToken := TDBXTokens.ObjectEndToken;
          begin
            Result := FToken;
            exit;
          end;
        end;
      Ord('"'):
        begin
          FToken := TDBXTokens.StringStartToken;
          begin
            Result := FToken;
            exit;
          end;
        end;
      Ord(':'):
        begin
          FToken := TDBXTokens.NameSeparatorToken;
          begin
            Result := FToken;
            exit;
          end;
        end;
      Ord(','):
        begin
          FToken := TDBXTokens.ValueSeparatorToken;
          begin
            Result := FToken;
            exit;
          end;
        end;
      Ord('['):
        begin
          FToken := TDBXTokens.ArrayStartToken;
          begin
            Result := FToken;
            exit;
          end;
        end;
      Ord(']'):
        begin
          FToken := TDBXTokens.ArrayEndToken;
          begin
            Result := FToken;
            exit;
          end;
        end;
      Ord('t'):
        begin
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('r') then
            UnexpectedString(TrueString);
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('u') then
            UnexpectedString(TrueString);
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('e') then
            UnexpectedString(TrueString);
          FBooleanValue := True;
          FToken := TDBXTokens.TrueToken;
          begin
            Result := FToken;
            exit;
          end;
        end;
      Ord('f'):
        begin
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('a') then
            UnexpectedString(FalseString);
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('l') then
            UnexpectedString(FalseString);
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('s') then
            UnexpectedString(FalseString);
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('e') then
            UnexpectedString(FalseString);
          FBooleanValue := False;
          FToken := TDBXTokens.FalseToken;
          begin
            Result := FToken;
            exit;
          end;
        end;
      Ord('n'):
        begin
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('u') then
            UnexpectedString(NullString);
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('l') then
            UnexpectedString(NullString);
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('l') then
            UnexpectedString(NullString);
          FToken := TDBXTokens.NullToken;
          begin
            Result := FToken;
            exit;
          end;
        end;
      Ord(' '),
      Ord(#$9),
      Ord(#$a),
      Ord(#$d):;
      else
        begin
          FToken := TDBXTokens.NumberStartToken;
          begin
            Result := FToken;
            exit;
          end;
        end;
    end;
  end;
end;

procedure TDBXJSonStreamReader.SkipString;
var
  LocalBuffer: TBytes;
begin
  LocalBuffer := FReadBuffer;
  while True do
  begin
    if Incr(FReadPosition) > FReadLastPosition then
      FillBuffer;
    case LocalBuffer[FReadPosition] of
      Ord('"'):
        begin
          
          exit;
        end;
    end;
  end;
end;

procedure TDBXJSonStreamReader.SkipToEndOfObject;
var
  ObjectEndTokens: Integer;
begin
  ObjectEndTokens := 1;
  while ObjectEndTokens > 0 do
    case Next of
      TDBXTokens.StringStartToken:
        SkipString;
      TDBXTokens.ObjectEndToken:
        Decr(ObjectEndTokens);
      TDBXTokens.ObjectStartToken:
        Incr(ObjectEndTokens);
    end;
end;

procedure TDBXJSonStreamReader.SkipToEndOfArray;
var
  ArrayEndTokens: Integer;
begin
  ArrayEndTokens := 1;
  while ArrayEndTokens > 0 do
    case Next of
      TDBXTokens.StringStartToken:
        SkipString;
      TDBXTokens.ArrayEndToken:
        Decr(ArrayEndTokens);
      TDBXTokens.ArrayStartToken:
        Incr(ArrayEndTokens);
    end;
end;

function TDBXJSonStreamReader.ReadBinaryInt: Integer;
var
  Count: Integer;
begin
  Count := 0;
  if Incr(FReadPosition) > FReadLastPosition then
    FillBuffer;
  Count := Count + (Integer(FReadBuffer[FReadPosition])) shl 24;
  if Incr(FReadPosition) > FReadLastPosition then
    FillBuffer;
  Count := Count + (Integer(FReadBuffer[FReadPosition])) shl 16;
  if Incr(FReadPosition) > FReadLastPosition then
    FillBuffer;
  Count := Count + (Integer(FReadBuffer[FReadPosition])) shl 8;
  if Incr(FReadPosition) > FReadLastPosition then
    FillBuffer;
  Count := Count + Integer(FReadBuffer[FReadPosition]);
  Result := Count;
end;

procedure TDBXJSonStreamReader.NextDataStoreHeader;
var
  Count: Integer;
  MinorVersion: Integer;
begin
  Count := ReadBinaryInt;
  MinorVersion := ReadBinaryInt;
  Count := Count - 8;
  while Decr(Count) > 0 do
  begin
    if Incr(FReadPosition) > FReadLastPosition then
      FillBuffer;
  end;
  if MinorVersion = 0 then
    raise Exception.Create('Server uses unsupported streaming protocol');
end;

function TDBXJSonStreamReader.ReadParams: Integer;
var
  LocalBuffer: TBytes;
  ReadByte: Byte;
begin
  LocalBuffer := FReadBuffer;
  while True do
  begin
    if Incr(FReadPosition) > FReadLastPosition then
      FillBuffer;
    ReadByte := LocalBuffer[FReadPosition];
    case ReadByte of
      Ord('"'):
        begin
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('p') then
          begin
            Result := NextString(ParamsString, 0, 0);
            exit;
          end;
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('a') then
          begin
            Result := NextString(ParamsString, 0, 1);
            exit;
          end;
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('r') then
          begin
            Result := NextString(ParamsString, 0, 2);
            exit;
          end;
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('a') then
          begin
            Result := NextString(ParamsString, 0, 3);
            exit;
          end;
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('m') then
          begin
            Result := NextString(ParamsString, 0, 4);
            exit;
          end;
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('s') then
          begin
            Result := NextString(ParamsString, 0, 5);
            exit;
          end;
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] <> Ord('"') then
          begin
            Result := NextString(ParamsString, 0, 6);
            exit;
          end;
          if Next = TDBXTokens.NameSeparatorToken then
          begin
            Result := Next;
            exit;
          end;
          begin
            Result := FToken;
            exit;
          end;
        end;
      Ord(','):;
      Ord(' '),
      Ord(#$9),
      Ord(#$a),
      Ord(#$d):;
      else
        begin
          Result := Next;
          exit;
        end;
    end;
  end;
end;

procedure TDBXJSonStreamReader.UnexpectedByte(UnexpectedByte: Byte);
var
  Buffer: WideString;
begin
  Buffer := 'Unexpected byte at position:  ' + IntToStr(FReadPosition) + #$a + BytesToString(FReadLastPosition);
  FReadPosition := FReadLastPosition;
  FErrorHandler.HandleError(TDBXRpcErrorCodes.ParseError, Buffer, nil);
end;

procedure TDBXJSonStreamReader.UnexpectedToken(ExpectedToken: Integer);
var
  Buffer: WideString;
begin
  Buffer := 'Expected:  ''' + TokenToString(ExpectedToken) + ''' found:  ''' + TokenToString(FToken) + ''' at position:  ' + IntToStr(FReadPosition) + #$a + BytesToString(FReadLastPosition);
  FReadPosition := FReadLastPosition;
  FErrorHandler.HandleError(TDBXRpcErrorCodes.ParseError, Buffer, nil);
end;

function TDBXJSonStreamReader.TokenToString(Token: Integer): WideString;
begin
  case Token of
    TDBXTokens.ObjectStartToken:
      Result := '{';
    TDBXTokens.ObjectEndToken:
      Result := '}';
    TDBXTokens.ArrayStartToken:
      Result := '[';
    TDBXTokens.ArrayEndToken:
      Result := ']';
    TDBXTokens.TrueToken:
      Result := 'true';
    TDBXTokens.FalseToken:
      Result := 'false';
    TDBXTokens.NullToken:
      Result := 'null';
    TDBXTokens.NumberStartToken:
      Result := '-+0-9.';
    TDBXTokens.StringStartToken:
      Result := '"';
    TDBXTokens.StringEndToken:
      Result := '"';
    TDBXTokens.NameSeparatorToken:
      Result := ':';
    TDBXTokens.ValueSeparatorToken:
      Result := ',';
    else
      Result := 'Unknown';
  end;
end;

procedure TDBXJSonStreamReader.UnexpectedString(ExpectedString: WideString);
var
  Buffer: WideString;
begin
  Buffer := 'Expected:  ''' + ExpectedString + ' at position:  ' + IntToStr(FReadPosition) + #$a + BytesToString(FReadLastPosition);
  FReadPosition := FReadLastPosition;
  FErrorHandler.HandleError(TDBXRpcErrorCodes.ParseError, Buffer, nil);
end;

function TDBXJSonStreamReader.Next(ExpectedToken: Integer): Integer;
begin
  if Next <> ExpectedToken then
    UnexpectedToken(ExpectedToken);
  Result := FToken;
end;

function TDBXJSonStreamReader.NextValueSeparator: Integer;
begin
  if Next <> TDBXTokens.ValueSeparatorToken then
    UnexpectedToken(TDBXTokens.ValueSeparatorToken);
  Result := FToken;
end;

function TDBXJSonStreamReader.ReadIntResultObject: Integer;
var
  Value: Integer;
begin
  NextResultObjectStart;
  Next(TDBXTokens.ArrayStartToken);
  Value := ReadInt;
  SkipToEndOfObject;
  Result := Value;
end;

procedure TDBXJSonStreamReader.NextResultObjectStart;
var
  ResultFound: Boolean;
  LocalBuffer: TBytes;
  ReadByte: Byte;
begin
  LocalBuffer := FReadBuffer;
  ReadByte := Byte(0);
  while ReadByte <> Ord('{') do
  begin
    if Incr(FReadPosition) > FReadLastPosition then
      FillBuffer;
    ReadByte := LocalBuffer[FReadPosition];
    case ReadByte of
      Ord(' '),
      Ord(#$9),
      Ord(#$a),
      Ord(#$d):;
      Byte(183):
        NextDataStoreHeader;
      Ord('{'):;
      else
        UnexpectedToken(TDBXTokens.ObjectStartToken);
    end;
  end;
  ResultFound := False;
  while not ResultFound do
  begin
    if Incr(FReadPosition) > FReadLastPosition then
      FillBuffer;
    ReadByte := LocalBuffer[FReadPosition];
    case ReadByte of
      Ord('"'):
        begin
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          if LocalBuffer[FReadPosition] = Ord('r') then
          begin
            if Incr(FReadPosition) > FReadLastPosition then
              FillBuffer;
            if LocalBuffer[FReadPosition] <> Ord('e') then
              UnexpectedString(ResultString);
            if Incr(FReadPosition) > FReadLastPosition then
              FillBuffer;
            if LocalBuffer[FReadPosition] <> Ord('s') then
              UnexpectedString(ResultString);
            if Incr(FReadPosition) > FReadLastPosition then
              FillBuffer;
            if LocalBuffer[FReadPosition] <> Ord('u') then
              UnexpectedString(ResultString);
            if Incr(FReadPosition) > FReadLastPosition then
              FillBuffer;
            if LocalBuffer[FReadPosition] <> Ord('l') then
              UnexpectedString(ResultString);
            if Incr(FReadPosition) > FReadLastPosition then
              FillBuffer;
            if LocalBuffer[FReadPosition] <> Ord('t') then
              UnexpectedString(ResultString);
            if Incr(FReadPosition) > FReadLastPosition then
              FillBuffer;
            if LocalBuffer[FReadPosition] <> Ord('"') then
              UnexpectedString(ResultString);
            ResultFound := True;
          end
          else if LocalBuffer[FReadPosition] = Ord('e') then
          begin
            if Incr(FReadPosition) > FReadLastPosition then
              FillBuffer;
            if LocalBuffer[FReadPosition] <> Ord('r') then
              UnexpectedString(ErrorString);
            if Incr(FReadPosition) > FReadLastPosition then
              FillBuffer;
            if LocalBuffer[FReadPosition] <> Ord('r') then
              UnexpectedString(ErrorString);
            if Incr(FReadPosition) > FReadLastPosition then
              FillBuffer;
            if LocalBuffer[FReadPosition] <> Ord('o') then
              UnexpectedString(ErrorString);
            if Incr(FReadPosition) > FReadLastPosition then
              FillBuffer;
            if LocalBuffer[FReadPosition] <> Ord('r') then
              UnexpectedString(ErrorString);
            if Incr(FReadPosition) > FReadLastPosition then
              FillBuffer;
            if LocalBuffer[FReadPosition] <> Ord('"') then
              UnexpectedString(ErrorString);
            ReadErrorBody;
          end
          else 
            UnexpectedString(ResultString);
        end;
      Ord(' '),
      Ord(#$9),
      Ord(#$a),
      Ord(#$d):;
      else
        UnexpectedByte(ReadByte);
    end;
  end;
  Next(TDBXTokens.NameSeparatorToken);
end;

procedure TDBXJSonStreamReader.ReadErrorBody;
var
  Name: WideString;
  Value: WideString;
  Message: WideString;
  Code: Integer;
begin
  Message := 'unknown error';
  Code := TDBXRpcErrorCodes.ParseError;
  Next(TDBXTokens.NameSeparatorToken);
  Next(TDBXTokens.ObjectStartToken);
  Next(TDBXTokens.StringStartToken);
  while FToken <> TDBXTokens.ObjectEndToken do
  begin
    Name := ReadString;
    Next(TDBXTokens.NameSeparatorToken);
    if (Name = 'code') then
      Code := ReadInt
    else if (Name = 'error') then
    begin
      Next(TDBXTokens.ObjectStartToken);
      SkipToEndOfObject;
    end
    else 
    begin
      Value := ReadString;
      if (Name = 'message') then
        Message := Value;
    end;
    Next;
    if FToken = TDBXTokens.ObjectEndToken then
      break;
    if FToken = TDBXTokens.ValueSeparatorToken then
      Next(TDBXTokens.StringStartToken);
  end;
  FErrorHandler.HandleError(Code, Message, nil);
end;

function TDBXJSonStreamReader.ReadMethod: Integer;
var
  LocalBuffer: TBytes;
  ReadByte: Byte;
begin
  FStringCode := TDBXStringCodes.Unknown;
  Next;
  LocalBuffer := FReadBuffer;
  while True do
  begin
    if Incr(FReadPosition) > FReadLastPosition then
      FillBuffer;
    ReadByte := LocalBuffer[FReadPosition];
    case ReadByte of
      Ord('"'):
        begin
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          case LocalBuffer[FReadPosition] of
            Ord('m'):
              begin
                NextMethod;
                begin
                  Result := FStringCode;
                  exit;
                end;
              end;
            Ord('v'):
              NextVersion;
            else
              begin
                UnexpectedString(MethodString);
                begin
                  Result := TDBXStringCodes.Unknown;
                  exit;
                end;
              end;
          end;
        end;
      Ord(' '),
      Ord(#$9),
      Ord(#$a),
      Ord(#$d):;
      else
        begin
          UnexpectedString(MethodString);
          begin
            Result := TDBXStringCodes.Unknown;
            exit;
          end;
        end;
    end;
  end;
end;

function TDBXJSonStreamReader.NextMethod: Integer;
var
  LocalBuffer: TBytes;
begin
  LocalBuffer := FReadBuffer;
  if Incr(FReadPosition) > FReadLastPosition then
    FillBuffer;
  if LocalBuffer[FReadPosition] <> Ord('e') then
    UnexpectedString(MethodString);
  if Incr(FReadPosition) > FReadLastPosition then
    FillBuffer;
  if LocalBuffer[FReadPosition] <> Ord('t') then
    UnexpectedString(MethodString);
  if Incr(FReadPosition) > FReadLastPosition then
    FillBuffer;
  if LocalBuffer[FReadPosition] <> Ord('h') then
    UnexpectedString(MethodString);
  if Incr(FReadPosition) > FReadLastPosition then
    FillBuffer;
  if LocalBuffer[FReadPosition] <> Ord('o') then
    UnexpectedString(MethodString);
  if Incr(FReadPosition) > FReadLastPosition then
    FillBuffer;
  if LocalBuffer[FReadPosition] <> Ord('d') then
    UnexpectedString(MethodString);
  if Incr(FReadPosition) > FReadLastPosition then
    FillBuffer;
  if LocalBuffer[FReadPosition] <> Ord('"') then
    UnexpectedString(MethodString);
  if NextColon <> TDBXTokens.NameSeparatorToken then
  begin
    Result := FToken;
    exit;
  end;
  while True do
  begin
    if Incr(FReadPosition) > FReadLastPosition then
      FillBuffer;
    case LocalBuffer[FReadPosition] of
      Ord('"'):
        begin
          NextString(0);
          ParseStringCode;
          begin
            Result := FToken;
            exit;
          end;
        end;
      Ord(' '),
      Ord(#$9),
      Ord(#$a),
      Ord(#$d):;
      else
        UnexpectedString('"');
    end;
  end;
end;

procedure TDBXJSonStreamReader.ParseStringCode;
var
  Position: Integer;
  Count: Integer;
  Buffer: TDBXWideChars;
begin
  Position := 0;
  Count := FCharBufferCount;
  Buffer := FCharBuffer;
  FStringCode := TDBXStringCodes.Unknown;
  case Buffer[Position] of
    'c':
      begin
        if Buffer[Incr(Position)] <> 'o' then
        begin
          
          exit;
        end;
        case Buffer[Incr(Position)] of
          'l':
            begin
              if Buffer[Incr(Position)] <> 'u' then
              begin
                
                exit;
              end;
              if Buffer[Incr(Position)] <> 'm' then
              begin
                
                exit;
              end;
              if Buffer[Incr(Position)] <> 'n' then
              begin
                
                exit;
              end;
              if Buffer[Incr(Position)] <> 's' then
              begin
                
                exit;
              end;
              if Count = 7 then
                FStringCode := TDBXStringCodes.Columns;
              
            end;
          'm':
            begin
              if Buffer[Incr(Position)] <> 'm' then
              begin
                
                exit;
              end;
              if Buffer[Incr(Position)] <> 'a' then
              begin
                
                exit;
              end;
              if Buffer[Incr(Position)] <> 'n' then
              begin
                
                exit;
              end;
              if Buffer[Incr(Position)] <> 'd' then
              begin
                
                exit;
              end;
              if Buffer[Incr(Position)] <> '_' then
              begin
                
                exit;
              end;
              if Buffer[Incr(Position)] <> 'c' then
              begin
                
                exit;
              end;
              case Buffer[Incr(Position)] of
                'l':
                  begin
                    if Buffer[Incr(Position)] <> 'o' then
                    begin
                      
                      exit;
                    end;
                    if Buffer[Incr(Position)] <> 's' then
                    begin
                      
                      exit;
                    end;
                    if Buffer[Incr(Position)] <> 'e' then
                    begin
                      
                      exit;
                    end;
                    if Count = 13 then
                      FStringCode := TDBXStringCodes.CommandClose;
                    
                  end;
              end;
            end;
          'n':
            begin
              if Buffer[Incr(Position)] <> 'n' then
              begin
                
                exit;
              end;
              if Buffer[Incr(Position)] <> 'e' then
              begin
                
                exit;
              end;
              if Buffer[Incr(Position)] <> 'c' then
              begin
                
                exit;
              end;
              if Buffer[Incr(Position)] <> 't' then
              begin
                
                exit;
              end;
              if Count = 7 then
                FStringCode := TDBXStringCodes.Connect;
              
            end;
        end;
      end;
    'd':
      begin
        if Buffer[Incr(Position)] = 'a' then
        begin
          if Buffer[Incr(Position)] <> 't' then
          begin
            
            exit;
          end;
          if Buffer[Incr(Position)] <> 'a' then
          begin
            
            exit;
          end;
          if Count = 4 then
            FStringCode := TDBXStringCodes.Data;
          begin
            
            exit;
          end;
        end;
        if Buffer[Position] <> 'i' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 's' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'c' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'o' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'n' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'n' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'e' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'c' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 't' then
        begin
          
          exit;
        end;
        if Count = 10 then
          FStringCode := TDBXStringCodes.Disconnect;
        
      end;
    'e':
      begin
        if Buffer[Incr(Position)] <> 'x' then
        begin
          if Buffer[Position] <> 'r' then
          begin
            
            exit;
          end;
          if Buffer[Incr(Position)] <> 'r' then
          begin
            
            exit;
          end;
          if Buffer[Incr(Position)] <> 'o' then
          begin
            
            exit;
          end;
          if Buffer[Incr(Position)] <> 'r' then
          begin
            
            exit;
          end;
          if Count = 5 then
            FStringCode := TDBXStringCodes.Error;
        end;
        if Buffer[Incr(Position)] <> 'e' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'c' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'u' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 't' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'e' then
        begin
          
          exit;
        end;
        if Count = 7 then
          FStringCode := TDBXStringCodes.Execute;
        
      end;
    'f':
      begin
        if Buffer[Incr(Position)] <> 'i' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'e' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'l' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'd' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 's' then
        begin
          
          exit;
        end;
        if Count = 6 then
          FStringCode := TDBXStringCodes.Fields;
        
      end;
    'h':
      begin
        if Buffer[Incr(Position)] <> 'a' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'n' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'd' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'l' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'e' then
        begin
          
          exit;
        end;
        if Count = 6 then
          FStringCode := TDBXStringCodes.Handle;
        
      end;
    'm':
      begin
        if Buffer[Incr(Position)] <> 'o' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'r' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'e' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> '_' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'b' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'l' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'o' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'b' then
        begin
          
          exit;
        end;
        if Count = 9 then
          FStringCode := TDBXStringCodes.MoreBlob;
        
      end;
    'n':
      begin
        if Buffer[Incr(Position)] <> 'e' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'x' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 't' then
        begin
          
          exit;
        end;
        if Count = 4 then
          FStringCode := TDBXStringCodes.Next;
        if Buffer[Incr(Position)] <> '_' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'r' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'e' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 's' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'u' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'l' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 't' then
        begin
          
          exit;
        end;
        if Count = 11 then
          FStringCode := TDBXStringCodes.NextResult;
        
      end;
    'p':
      begin
        if Buffer[Incr(Position)] = 'r' then
        begin
          if Buffer[Incr(Position)] <> 'e' then
          begin
            
            exit;
          end;
          if Buffer[Incr(Position)] <> 'p' then
          begin
            
            exit;
          end;
          if Buffer[Incr(Position)] <> 'a' then
          begin
            
            exit;
          end;
          if Buffer[Incr(Position)] <> 'r' then
          begin
            
            exit;
          end;
          if Buffer[Incr(Position)] <> 'e' then
          begin
            
            exit;
          end;
          if Count = 7 then
            FStringCode := TDBXStringCodes.Prepare;
          begin
            
            exit;
          end;
        end;
        if Buffer[Position] <> 'a' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'r' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'a' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'm' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'e' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 't' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'e' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'r' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 's' then
        begin
          
          exit;
        end;
        if Count = 10 then
          FStringCode := TDBXStringCodes.Parameters;
        
      end;
    'r':
      begin
        if Buffer[Incr(Position)] = 'o' then
        begin
          if Buffer[Incr(Position)] <> 'w' then
          begin
            
            exit;
          end;
          if Buffer[Incr(Position)] <> 's' then
          begin
            
            exit;
          end;
          if Count = 4 then
            FStringCode := TDBXStringCodes.Rows;
          begin
            
            exit;
          end;
        end;
        if Buffer[Position] <> 'e' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'a' then
        begin
          if Buffer[Position] <> 's' then
          begin
            
            exit;
          end;
          if Buffer[Incr(Position)] <> 'u' then
          begin
            
            exit;
          end;
          if Buffer[Incr(Position)] <> 'l' then
          begin
            
            exit;
          end;
          if Buffer[Incr(Position)] <> 't' then
          begin
            
            exit;
          end;
          if Count = 6 then
            FStringCode := TDBXStringCodes.Result;
          begin
            
            exit;
          end;
        end;
        if Buffer[Incr(Position)] <> 'd' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'e' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'r' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> '_' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'c' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'l' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'o' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 's' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'e' then
        begin
          
          exit;
        end;
        if Count = 12 then
          FStringCode := TDBXStringCodes.ReaderClose;
        
      end;
    's':
      begin
        if Buffer[Incr(Position)] <> 'e' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 's' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 's' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'i' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'o' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'n' then
        begin
          
          exit;
        end;
        if Count = 7 then
          FStringCode := TDBXStringCodes.Session;
        
      end;
    't':
      begin
        if Buffer[Incr(Position)] = 'x' then
        begin
          if Buffer[Incr(Position)] = 'b' then
          begin
            if Buffer[Incr(Position)] <> 'e' then
            begin
              
              exit;
            end;
            if Buffer[Incr(Position)] <> 'g' then
            begin
              
              exit;
            end;
            if Buffer[Incr(Position)] <> 'i' then
            begin
              
              exit;
            end;
            if Buffer[Incr(Position)] <> 'n' then
            begin
              
              exit;
            end;
            if Count = 7 then
              FStringCode := TDBXStringCodes.Txbegin;
            begin
              
              exit;
            end;
          end;
          if Buffer[Position] <> 'e' then
          begin
            
            exit;
          end;
          if Buffer[Incr(Position)] <> 'n' then
          begin
            
            exit;
          end;
          if Buffer[Incr(Position)] <> 'd' then
          begin
            
            exit;
          end;
          if Count = 5 then
            FStringCode := TDBXStringCodes.Txend;
          begin
            
            exit;
          end;
        end;
        if Buffer[Position] <> 'a' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'b' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'l' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'e' then
        begin
          
          exit;
        end;
        if Count = 5 then
          FStringCode := TDBXStringCodes.Table;
        
      end;
    'v':
      begin
        if Buffer[Incr(Position)] <> 'e' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'n' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'd' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'o' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'r' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> '_' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'p' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'r' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'o' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'p' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'e' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'r' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 't' then
        begin
          
          exit;
        end;
        if Buffer[Incr(Position)] <> 'y' then
        begin
          
          exit;
        end;
        if Count = 15 then
          FStringCode := TDBXStringCodes.VendorProperty;
        
      end;
    else
      
  end;
end;

function TDBXJSonStreamReader.NextColon: Integer;
var
  LocalBuffer: TBytes;
  ReadByte: Byte;
begin
  LocalBuffer := FReadBuffer;
  while True do
  begin
    if Incr(FReadPosition) > FReadLastPosition then
      FillBuffer;
    ReadByte := LocalBuffer[FReadPosition];
    case ReadByte of
      Ord(':'):
        begin
          Result := TDBXTokens.NameSeparatorToken;
          exit;
        end;
      Ord(' '),
      Ord(#$9),
      Ord(#$a),
      Ord(#$d):;
      else
        UnexpectedString(':');
    end;
  end;
end;

function TDBXJSonStreamReader.NextVersion: Integer;
begin
  Result := TDBXTokens.ErrorToken;
end;

function TDBXJSonStreamReader.NextNumber: Integer;
var
  BytePosition: Integer;
  ReadByte: Byte;
  LocalBuffer: TBytes;
  LocalByteBuffer: TBytes;
begin
  LocalBuffer := FReadBuffer;
  LocalByteBuffer := FByteBuffer;
  BytePosition := -1;
  while True do
  begin
    if Incr(FReadPosition) > FReadLastPosition then
      FillBuffer;
    ReadByte := LocalBuffer[FReadPosition];
    case ReadByte of
      Ord('-'),
      Ord('+'),
      Ord('e'),
      Ord('E'),
      Ord('0'),
      Ord('1'),
      Ord('2'),
      Ord('3'),
      Ord('4'),
      Ord('5'),
      Ord('6'),
      Ord('7'),
      Ord('8'),
      Ord('9'),
      Ord('.'):
        begin
          Incr(BytePosition);
          if BytePosition = FByteBufferSize then
            GrowByteBuffer;
          LocalByteBuffer[BytePosition] := ReadByte;
        end;
      else
        begin
          FByteBufferCount := BytePosition + 1;
          Decr(FReadPosition);
          if FByteBufferCount < 1 then
            UnexpectedByte(ReadByte);
          begin
            Result := TDBXTokens.NumberEndToken;
            exit;
          end;
        end;
    end;
  end;
end;

function TDBXJSonStreamReader.NextString(ExpectedString: WideString; Offset: Integer; Count: Integer): Integer;
var
  Index: Integer;
begin
  Index := 0;
    while Index < Count do
  begin
    FCharBuffer[Index] := ExpectedString[1+Offset + Index];
    Incr(Index);
  end;
  Result := NextString(Index);
end;

function TDBXJSonStreamReader.HexToDecimal(Value: Byte): Integer;
begin
  if Value > Ord('9') then
  begin
    if Value > Ord('F') then
    begin
      ;
      begin
        Result := Value - Ord('a') + 10;
        exit;
      end;
    end
    else 
    begin
      ;
      begin
        Result := Value - Ord('A') + 10;
        exit;
      end;
    end;
  end;
  ;
  Result := Value - Ord('0');
end;

function TDBXJSonStreamReader.NextString(StartPosition: Integer): Integer;
var
  LocalBuffer: TBytes;
  LocalCharBuffer: TDBXWideChars;
  CharPosition: Integer;
  ReadByte: Byte;
  UnicodeValue: Integer;
begin
  LocalBuffer := FReadBuffer;
  CharPosition := StartPosition - 1;
  LocalCharBuffer := FCharBuffer;
  while True do
  begin
    if Incr(FReadPosition) > FReadLastPosition then
      FillBuffer;
    ReadByte := LocalBuffer[FReadPosition];
    case ReadByte of
      Ord('"'):
        begin
          FCharBufferCount := CharPosition + 1;
          begin
            Result := TDBXTokens.StringEndToken;
            exit;
          end;
        end;
      Ord('\'):
        begin
          Incr(CharPosition);
          if CharPosition = FCharBufferSize then
          begin
            GrowCharBuffer;
            LocalCharBuffer := FCharBuffer;
          end;
          if Incr(FReadPosition) > FReadLastPosition then
            FillBuffer;
          ReadByte := LocalBuffer[FReadPosition];
          if ReadByte = Ord('u') then
          begin
            if Incr(FReadPosition) > FReadLastPosition then
              FillBuffer;
            UnicodeValue := HexToDecimal(LocalBuffer[FReadPosition]) shl 12;
            if Incr(FReadPosition) > FReadLastPosition then
              FillBuffer;
            UnicodeValue := UnicodeValue or (HexToDecimal(LocalBuffer[FReadPosition]) shl 8);
            if Incr(FReadPosition) > FReadLastPosition then
              FillBuffer;
            UnicodeValue := UnicodeValue or (HexToDecimal(LocalBuffer[FReadPosition]) shl 4);
            if Incr(FReadPosition) > FReadLastPosition then
              FillBuffer;
            UnicodeValue := UnicodeValue or (HexToDecimal(LocalBuffer[FReadPosition]));
            LocalCharBuffer[CharPosition] := WideChar(UnicodeValue);
          end
          else 
            case ReadByte of
              Ord('"'):
                LocalCharBuffer[CharPosition] := '"';
              Ord('\'):
                LocalCharBuffer[CharPosition] := '\';
              Ord('b'):
                LocalCharBuffer[CharPosition] := #$8;
              Ord('f'):
                LocalCharBuffer[CharPosition] := #$c;
              Ord('n'):
                LocalCharBuffer[CharPosition] := #$a;
              Ord('r'):
                LocalCharBuffer[CharPosition] := #$d;
              Ord('t'):
                LocalCharBuffer[CharPosition] := #$9;
              else
                LocalCharBuffer[CharPosition] := WideChar(ReadByte);
            end;
        end;
      else
        begin
          Incr(CharPosition);
          if CharPosition = FCharBufferSize then
          begin
            GrowCharBuffer;
            LocalCharBuffer := FCharBuffer;
          end;
          LocalCharBuffer[CharPosition] := WideChar(ReadByte);
        end;
    end;
  end;
end;

function TDBXJSonStreamReader.NextString: Integer;
var
  LocalBuffer: TBytes;
begin
  if FToken = TDBXTokens.StringStartToken then
  begin
    Result := NextString(0);
    exit;
  end;
  LocalBuffer := FReadBuffer;
  while True do
  begin
    if Incr(FReadPosition) > FReadLastPosition then
      FillBuffer;
    case LocalBuffer[FReadPosition] of
      Ord('"'):
        begin
          Result := NextString(0);
          exit;
        end;
    end;
  end;
end;

procedure TDBXJSonStreamReader.FillBuffer(Bytes: TBytes);
begin
  TDBXPlatform.CopyByteArray(Bytes, 0, FReadBuffer, 0, Length(Bytes));
  FReadLastPosition := Length(Bytes) - 1;
  TDBXPlatform.WriteAsciiBytes('fillBuffer', FReadBuffer, 0, FReadLastPosition);
end;

function TDBXJSonStreamReader.BytesToString(Count: Integer): WideString;
var
  Buffer: WideString;
  CurChar: WideChar;
  Position: Integer;
begin
  Buffer := '';
  Position := 0;
  while Position < Count do
  begin
    CurChar := WideChar(FReadBuffer[Position]);
    if (CurChar < ' ') or (CurChar > '~') then
    begin
      Buffer := Buffer + '#';
      Buffer := Buffer + IntToStr(Ord(CurChar));
    end
    else 
      Buffer := Buffer + CurChar;
    Incr(Position);
  end;
  Result := Buffer;
end;

procedure TDBXJSonStreamReader.TraceRead;
var
  Buffer: WideString;
begin
  Buffer := 'read ' + IntToStr(FReadLastPosition) + ' bytes:' + BytesToString(FReadLastPosition);
  FTraceHandler.Trace(Buffer);
end;

procedure TDBXJSonStreamReader.ReadError;
begin
  FErrorHandler.HandleError(TDBXRpcErrorCodes.ServerError, 'Read error', nil);
end;

procedure TDBXJSonStreamReader.FillBuffer;
begin
  FReadLastPosition := FChannel.Read(FReadBuffer, 0, Length(FReadBuffer));
  if FTraceHandler.Tracing then
    TraceRead;
  if FReadLastPosition < 1 then
    ReadError;
  FReadLastPosition := FReadLastPosition - 1;
  FReadPosition := 0;
end;

procedure TDBXJSonStreamReader.ReadDataBytes(Buffer: TBytes; ReadOff: Integer; Count: Integer);
var
  MaxCopy: Integer;
begin
  Incr(FReadPosition);
  while Count > 0 do
  begin
    if FReadPosition <= FReadLastPosition then
    begin
      MaxCopy := FReadLastPosition - FReadPosition + 1;
      if Count < MaxCopy then
        MaxCopy := Count;
      TDBXPlatform.CopyByteArray(FReadBuffer, FReadPosition, Buffer, ReadOff, MaxCopy);
      ReadOff := ReadOff + MaxCopy;
      FReadPosition := FReadPosition + MaxCopy;
      Count := Count - MaxCopy;
    end;
    if Count > 0 then
      FillBuffer;
  end;
  Decr(FReadPosition);
end;

function TDBXJSonStreamReader.ReadBoolean: Boolean;
begin
  Next;
  if FToken = TDBXTokens.TrueToken then
  begin
    Result := True;
    exit;
  end;
  if FToken = TDBXTokens.FalseToken then
  begin
    Result := False;
    exit;
  end;
  UnexpectedToken(TDBXTokens.TrueToken);
  Result := False;
end;

function TDBXJSonStreamReader.ReadInt: Integer;
var
  Negative: Boolean;
  Position: Integer;
  Value: Integer;
begin
  Value := 0;
  NextNumber;
  if FByteBufferCount > 0 then
  begin
    Position := 0;
    Negative := False;
    if FByteBuffer[0] = Ord('-') then
    begin
      Negative := True;
      Incr(Position);
    end
    else if FByteBuffer[0] = Ord('+') then
      Incr(Position);
    while Position < FByteBufferCount do
    begin
      Value := Value * 10;
      Value := Value + FByteBuffer[Position] - Ord('0');
      Incr(Position);
    end;
    if Negative then
      Value := -Value;
  end;
  Result := Value;
end;

function TDBXJSonStreamReader.GetByteLength: Int64;
begin
  Result := 0;
end;

function TDBXJSonStreamReader.GetBytes(Buffer: TBytes; Offset: Int64; Count: Int64): Int64;
begin
  Result := 0;
end;

function TDBXJSonStreamReader.ReadByte: Byte;
begin
  Result := Byte(0);
end;

function TDBXJSonStreamReader.ReadShort: SmallInt;
begin
  Result := SmallInt(ReadInt);
end;

function TDBXJSonStreamReader.ReadLong: Int64;
var
  Negative: Boolean;
  Position: Integer;
  Value: Int64;
begin
  Value := 0;
  NextNumber;
  if FByteBufferCount > 0 then
  begin
    Position := 0;
    Negative := False;
    if FByteBuffer[0] = Ord('-') then
    begin
      Negative := True;
      Incr(Position);
    end
    else if FByteBuffer[0] = Ord('+') then
      Incr(Position);
    while Position < FByteBufferCount do
    begin
      Value := Value * 10;
      Value := Value + FByteBuffer[Position] - Ord('0');
      Incr(Position);
    end;
    if Negative then
      Value := -Value;
  end;
  Result := Value;
end;

function TDBXJSonStreamReader.ReadFloat: Single;
begin
  Result := 0.0;
end;

function TDBXJSonStreamReader.ReadDouble: Double;
begin
  Result := 0.0;
end;

procedure TDBXJSonStreamReader.Open;
begin
  CreateBuffers;
end;

procedure TDBXJSonStreamReader.Close;
begin
end;

function TDBXJSonStreamReader.ReadString: WideString;
begin
  NextString;
  FStringValue := TDBXPlatform.CreateWideString(FCharBuffer, FCharBufferCount);
  Result := FStringValue;
end;

function TDBXJSonStreamReader.ReadStringCode: Integer;
begin
  NextString;
  ParseStringCode;
  FStringValue := NullString;
  Result := FStringCode;
end;

function TDBXJSonStreamReader.GetStringValue: WideString;
begin
  if StringIsNil(FStringValue) then
    FStringValue := TDBXPlatform.CreateWideString(FCharBuffer, FCharBufferCount);
  Result := FStringValue;
end;

function TDBXJSonStreamReader.GetBooleanValue: Boolean;
begin
  Result := FBooleanValue;
end;

procedure TDBXJSonStreamReader.GrowCharBuffer;
var
  NewCharBuffer: TDBXWideChars;
  NewCharBufferSize: Integer;
begin
  NewCharBufferSize := FCharBufferSize + 128;
  SetLength(NewCharBuffer,NewCharBufferSize);
  TDBXPlatform.CopyCharArray(FCharBuffer, 0, NewCharBuffer, 0, FCharBufferSize);
  FCharBuffer := nil;
  FCharBuffer := NewCharBuffer;
  FCharBufferSize := NewCharBufferSize;
end;

procedure TDBXJSonStreamReader.GrowByteBuffer;
var
  NewByteBuffer: TBytes;
  NewByteBufferSize: Integer;
begin
  NewByteBufferSize := FByteBufferSize + 128;
  SetLength(NewByteBuffer,NewByteBufferSize);
  TDBXPlatform.CopyByteArray(FByteBuffer, 0, NewByteBuffer, 0, FByteBufferSize);
  FByteBuffer := nil;
  FByteBuffer := NewByteBuffer;
  FByteBufferSize := NewByteBufferSize;
end;

procedure TDBXJSonStreamReader.CreateBuffers;
begin
  FCharBufferSize := 128;
  SetLength(FCharBuffer,FCharBufferSize);
  FByteBufferSize := 64;
  SetLength(FByteBuffer,FByteBufferSize);
  if FReadBufferSize = 0 then
    FReadBufferSize := 1024 * 8;
  SetLength(FReadBuffer,FReadBufferSize);
  FReadPosition := -1;
  FReadLastPosition := -1;
end;

function TDBXJSonStreamReader.GetTheTraceHandler: TDBXTraceHandler;
begin
  Result := FTraceHandler;
end;

procedure TDBXJSonStreamReader.SetTheTraceHandler(TraceHandler: TDBXTraceHandler);
begin
  self.FTraceHandler := TraceHandler;
end;

destructor TDBXJSonStreamReader.Destroy;
begin
  FCharBuffer := nil;
  FByteBuffer := nil;
  FReadBuffer := nil;
  inherited Destroy;
end;

end.
