unit BisCallServerEventHandler;

interface

uses Windows, Classes, Contnrs, ZLib, mmSystem, SyncObjs,
     IdGlobal, IdSocketHandle, IdUDPServer, IdException,
     WaveAcmDrivers,
     BisEvents, BisNotifyEvents, BisCrypter, BisValues, BisConnections,
     BisAudioWave, BisThreads, BisRtp, BisRtpAcmDrivers,
     BisCallServerHandlerModules, BisCallServerHandlers,
     BisCallServerChannels, BisCallServerEventMessages;

type
  TBisCallServerEventHandler=class;

  TBisCallServerEventChannels=class;

  TBisCallServerEventChannel=class;

  TBisCallServerEventUdpServer=class(TIdUdpServer)
  protected
    function GetBinding: TIdSocketHandle; override;
  end;

  TBisCallServerEventChannel=class(TBisCallServerChannel)
  private
    FServer: TBisCallServerEventUdpServer;
    FHandler: TBisCallServerEventHandler;
    FChannels: TBisCallServerEventChannels;
    FId: String;
    FCreatorId: Variant;
    FAcceptorId: Variant;
    FCallId: Variant;
    FCallResultId: Variant;
    FCallerId, FCallerPhone: Variant;
    FAcceptor: Variant;
    FAcceptorType: TBisCallServerChannelAcceptorType;
    FDateCreate: TDateTime;
    FDirection: TBisCallServerChannelDirection;
    FRequests: TBisCallServerEventRequests;
//    FWaits: TBisCallServerEventWaitThreads;
    FOutFormat: PWaveFormatEx;
    FOutDataSize: Integer;
//    FSweepTimeout: Integer;

    FLocalIP: String;
    FLocalPort: Integer;
    FLocalUseCompressor: Boolean;
    FLocalCompressorLevel: TCompressionLevel;
    FLocalUseCrypter: Boolean;
    FLocalCrypterKey: String;
    FLocalCrypterAlgorithm: TBisCipherAlgorithm;
    FLocalCrypterMode: TBisCipherMode;
    FLocalDriverFormat: TWaveAcmDriverFormat;
    FLocalPayloadType: TBisRtpPacketPayloadType;

    FSequence: Word;
    FTimeStamp: LongWord;
    FSSRCIdentifier: LongWord;

    FRemoteSessionId: Variant;
    FRemoteIP: String;
    FRemotePort: Integer;
    FRemoteUseCompressor: Boolean;
    FRemoteCompressorLevel: TCompressionLevel;
    FRemoteUseCrypter: Boolean;
    FRemoteCrypterKey: String;
    FRemoteCrypterAlgorithm: TBisCipherAlgorithm;
    FRemoteCrypterMode: TBisCipherMode;
    FRemoteDataPort: Integer;
    FRemoteDriverFormat: TWaveAcmDriverFormat;
    FRemotePayloadType: TBisRtpPacketPayloadType;
    FRemoteDataSize: Integer;

    function EncodeString(Key, S: String; Algorithm: TBisCipherAlgorithm; Mode: TBisCipherMode): String;
    function CompressString(S: String; Level: TCompressionLevel): String;
    function SendEvent(Data: String): Boolean;
    procedure SendMessage(Message: TBisCallServerEventMessage; WithWait: Boolean);
    procedure ServerUDPException(Sender: TObject; ABinding: TIdSocketHandle; const AMessage: String; const AExceptionClass: TClass);
    procedure ServerUDPRead(Sender: TObject; AData: TIdBytes; ABinding: TIdSocketHandle);
    function DataPort: Integer;
    function TryServerActive: Boolean;
    function GetEventParams(SessionId: Variant;
                            var AccountId: Variant;
                            var IP: String; var Port: Integer;
                            var UseCompressor: Boolean; var CompressorLevel: TCompressionLevel;
                            var UseCrypter: Boolean; var CrypterKey: String;
                            var CrypterAlgorithm: TBisCipherAlgorithm; var CrypterMode: TBisCipherMode): Boolean;
    function GetRemoteEventParams(SessionId: Variant): Boolean;
    function GetLocalEventParams: Boolean;

    function DialRequest(Request: TBisCallServerEventRequest): Boolean;
    function AnswerRequest(Request: TBisCallServerEventRequest): Boolean;
    function HangupRequest(Request: TBisCallServerEventRequest): Boolean;
    function HoldRequest(Request: TBisCallServerEventRequest): Boolean;
    function UnHoldRequest(Request: TBisCallServerEventRequest): Boolean;

    function DialResponse(Response: TBisCallServerEventResponse; var FreeChannel: Boolean): Boolean;
    function AnswerResponse(Response: TBisCallServerEventResponse; var FreeChannel: Boolean): Boolean;
    function HangupResponse(Response: TBisCallServerEventResponse; var FreeChannel: Boolean): Boolean;
  protected
    function GetActive: Boolean; override;
    function GetCallId: Variant; override;
    function GetCallResultId: Variant; override;
    function GetDirection: TBisCallServerChannelDirection; override;
    function GetCallerId: Variant; override;
    function GetCallerPhone: Variant; override;
    function GetAcceptor: Variant; override;
    function GetAcceptorType: TBisCallServerChannelAcceptorType; override;
    function GetAcceptorId: Variant; override;
    function GetCreatorId: Variant; override;
    function GetDateCreate: TDateTime; override;
    function GetLocation: TBisCallServerChannelLocation; override;
    function GetInFormat: PWaveFormatEx; override;
    function GetOutFormat: PWaveFormatEx; override;
    procedure SetOutFormat(const Value: PWaveFormatEx); override;
    function GetOutDataSize: Integer; override;
    procedure SetOutDataSize(const Value: Integer); override;
    function GetVolume: Integer; override;
    function GetListenThread: TThread; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    procedure Dial(Acceptor: Variant; AcceptorType: TBisCallServerChannelAcceptorType); override;
    procedure Answer; override;
    procedure Hangup; override;
    procedure Send(const Data: Pointer; const DataSize: Cardinal); override;
  end;

  TBisCallServerEventChannels=class(TBisCallServerChannels)
  private
    FHandler: TBisCallServerEventHandler;
    FEventResult: TBisEvent;
    FEventDial: TBisEvent;
    FEventAnswer: TBisEvent;
    FEventHangup: TBisEvent;
    FEventHold: TBisEvent;
    FEventUnHold: TBisEvent;

    function GetItem(Index: Integer): TBisCallServerEventChannel;
    function ResultHandler(Event: TBisEvent; InParams, OutParams: TBisEventParams): Boolean;
    function DialHandler(Event: TBisEvent; InParams, OutParams: TBisEventParams): Boolean;
    function AnswerHandler(Event: TBisEvent; InParams, OutParams: TBisEventParams): Boolean;
    function HangupHandler(Event: TBisEvent; InParams, OutParams: TBisEventParams): Boolean;
    function HoldHandler(Event: TBisEvent; InParams, OutParams: TBisEventParams): Boolean;
    function UnHoldHandler(Event: TBisEvent; InParams, OutParams: TBisEventParams): Boolean;
  protected
    procedure DoChannelDestroy(Channel: TBisCallServerChannel); override;    
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    function Add(Id: String; Direction: TBisCallServerChannelDirection; CallId: Variant): TBisCallServerEventChannel; reintroduce;
    function AddOutgoing(CallId,CallerId,CallerPhone: Variant): TBisCallServerEventChannel;
    function LockAddOutgoing(CallId,CallerId,CallerPhone: Variant): TBisCallServerEventChannel;
    function AddIncoming(Request: TBisCallServerEventRequest): TBisCallServerEventChannel;
    function LockAddIncoming(Request: TBisCallServerEventRequest): TBisCallServerEventChannel;
    function Find(Id: String): TBisCallServerEventChannel; reintroduce;
    function LockFind(Id: String): TBisCallServerEventChannel; 

    property Items[Index: Integer]: TBisCallServerEventChannel read GetItem; default;
  end;

  TBisCallServerEventHandler=class(TBisCallServerHandler)
  private
    FDrivers: TBisRtpAcmDrivers;
    FIdleTimeOut: Integer;
    FSweepInterval: Integer;
    FWaitTimeOut: Integer;
    FWaitRetryCount: Integer;
    function GetChannels: TBisCallServerEventChannels;
  protected
    function GetChannelsClass: TBisCallServerChannelsClass; override;
    function GetConnected: Boolean; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Init; override;
    procedure Connect; override;
    procedure Disconnect; override;
    function AddOutgoingChannel(CallId,CallerId,CallerPhone: Variant): TBisCallServerChannel; override;

    property Channels: TBisCallServerEventChannels read GetChannels;
  end;

procedure InitCallServerHandlerModule(AModule: TBisCallServerHandlerModule); stdcall;

exports
  InitCallServerHandlerModule;

implementation

uses SysUtils, Variants, DB,
     IdUDPClient,
     BisCore, BisProvider, BisFilterGroups, BisUtils, BisDataParams,
     BisConfig, BisConsts, BisLogger, BisNetUtils,
     BisCallServerEventHandlerConsts;

procedure InitCallServerHandlerModule(AModule: TBisCallServerHandlerModule); stdcall;
begin
  AModule.HandlerClass:=TBisCallServerEventHandler;
end;

{ TBisCallServerEventUdpServer }

function TBisCallServerEventUdpServer.GetBinding: TIdSocketHandle;
begin
  Result:=inherited GetBinding;
  if Assigned(FListenerThread) then begin
    FListenerThread.Priority:=tpHighest;
  end;
end;

{ TBisCallServerEventChannel }

constructor TBisCallServerEventChannel.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);

  FRequests:=TBisCallServerEventRequests.Create;

  FServer:=TBisCallServerEventUdpServer.Create(nil);
  FServer.OnUDPRead:=ServerUDPRead;
  FServer.OnUDPException:=ServerUDPException;
  FServer.ThreadedEvent:=true;
  FServer.ThreadName:='CallServerEventListen';

  FCreatorId:=Core.AccountId;
  FAcceptorId:=Null;
  FDateCreate:=Core.ServerDate;
  FCallId:=Null;
  FCallResultId:=Null;
  FCallerId:=Null;
  FCallerPhone:=Null;
  FAcceptor:=Null;

  FRemoteDriverFormat:=nil;

  Randomize;
  FSequence:=Random(MaxByte);
  FSSRCIdentifier:=Random(MaxInt);
end;

destructor TBisCallServerEventChannel.Destroy;
begin
  FServer.OnUDPRead:=nil;
  FServer.Free;
//  FWaits.Free;
  FRequests.Free;
  inherited Destroy;
end;

function TBisCallServerEventChannel.GetActive: Boolean;
begin
  Result:=Assigned(FServer) and FServer.Active and (State in [csProcessing]);
end;

function TBisCallServerEventChannel.GetCallerId: Variant;
begin
  Result:=FCallerId;
end;

function TBisCallServerEventChannel.GetCallerPhone: Variant;
begin
  Result:=FCallerPhone;
end;

function TBisCallServerEventChannel.GetCallId: Variant;
begin
  Result:=FCallId;
end;

function TBisCallServerEventChannel.GetCallResultId: Variant;
begin
  Result:=FCallResultId;
end;

function TBisCallServerEventChannel.GetAcceptor: Variant;
begin
  Result:=FAcceptor;
end;

function TBisCallServerEventChannel.GetAcceptorType: TBisCallServerChannelAcceptorType;
begin
  Result:=FAcceptorType;
end;

function TBisCallServerEventChannel.GetAcceptorId: Variant;
begin
  Result:=FAcceptorId;
end;

function TBisCallServerEventChannel.GetCreatorId: Variant;
begin
  Result:=FCreatorId;
end;

function TBisCallServerEventChannel.GetDateCreate: TDateTime;
begin
  Result:=FDateCreate;
end;

function TBisCallServerEventChannel.GetDirection: TBisCallServerChannelDirection;
begin
  Result:=FDirection;
end;

function TBisCallServerEventChannel.GetInFormat: PWaveFormatEx;
begin
  Result:=nil;
  if Assigned(FRemoteDriverFormat) then
    Result:=FRemoteDriverFormat.WaveFormat;
end;

function TBisCallServerEventChannel.GetLocation: TBisCallServerChannelLocation;
begin
  Result:=inherited GetLocation;
  if Assigned(FHandler) then begin
    case FHandler.Location of
      hlInternal: Result:=clInternal;
      hlExternal: Result:=clExternal;
    end;
  end;
end;

function TBisCallServerEventChannel.GetOutDataSize: Integer;
begin
  Result:=FOutDataSize;
end;

function TBisCallServerEventChannel.GetOutFormat: PWaveFormatEx;
begin
  Result:=FOutFormat;
end;

function TBisCallServerEventChannel.GetVolume: Integer;
begin
  Result:=inherited GetVolume;
  if Assigned(FHandler) then
    Result:=FHandler.Volume;
end;

function TBisCallServerEventChannel.GetListenThread: TThread;
begin
  Result:=inherited GetListenThread;
  if Assigned(FServer) then
    Result:=FServer.FListenerThread;
end;

function TBisCallServerEventChannel.EncodeString(Key, S: String; Algorithm: TBisCipherAlgorithm; Mode: TBisCipherMode): String;
var
  Crypter: TBisCrypter;
begin
  Crypter:=TBisCrypter.Create;
  try
    Result:=Crypter.EncodeString(Key,S,Algorithm,Mode);
  finally
    Crypter.Free;
  end;
end;

function TBisCallServerEventChannel.CompressString(S: String; Level: TCompressionLevel): String;
var
  Zip: TCompressionStream;
  TempStream: TMemoryStream;
begin
  TempStream:=TMemoryStream.Create;
  try
    Zip:=TCompressionStream.Create(Level,TempStream);
    try
      Zip.Write(Pointer(S)^,Length(S));
    finally
      Zip.Free;
    end;
    TempStream.Position:=0;
    SetLength(Result,TempStream.Size);
    TempStream.Read(Pointer(Result)^,Length(Result))
  finally
    TempStream.Free;
  end;
end;

function TBisCallServerEventChannel.SendEvent(Data: String): Boolean;
var
  Udp: TIdUDPClient;
  S: String;
begin
  Result:=false;
  if Data<>'' then begin
    Udp:=TIdUDPClient.Create(nil);
    try
      S:=Data;

      if FRemoteUseCompressor then
        S:=CompressString(S,FRemoteCompressorLevel);

      if FRemoteUseCrypter then
        S:=EncodeString(FRemoteCrypterKey,S,
                        FRemoteCrypterAlgorithm,FRemoteCrypterMode);

      Udp.Host:=FRemoteIP;
      Udp.Port:=FRemotePort;
      Udp.BufferSize:=Length(S);
      Udp.Connect;
      Udp.Send(S);
      Result:=true;
    finally
      Udp.Free;
    end;
  end;
end;

{procedure TBisCallServerEventChannel.Send(const Data: Pointer; const DataSize: Cardinal);
var
  L: Integer;
  S: String;
begin
  if Assigned(FServer) and FServer.Active then begin
    L:=DataSize;
    SetLength(S,L);
    Move(Data^,Pointer(S)^,L);
    FServer.Send(FRemoteIP,FRemoteDataPort,S);
  end;
end;}

procedure TBisCallServerEventChannel.Send(const Data: Pointer; const DataSize: Cardinal);
var
  S: String;
  Packet: TBisRtpPacket;
  D: TBytes;
begin
  if (DataSize>0) then begin
    Packet:=TBisRtpPacket.Create;
    try
      Packet.Version:=vSecond;
      Packet.Padding:=false;
      Packet.Extension:=false;
      Packet.Marker:=false;
      Packet.PayloadType:=FLocalPayloadType;
      Packet.Sequence:=FSequence;
      Packet.TimeStamp:=FTimeStamp;
      Packet.SSRCIdentifier:=FSSRCIdentifier;
      Packet.ExternalHeader:=ToBytes('');

      SetLength(S,DataSize);
      Move(Data^,Pointer(S)^,DataSize);

     { if FLocalUseCrypter then
        S:=EncodeString(FRemoteCrypterKey,S,FRemoteCrypterAlgorithm,FRemoteCrypterMode);   }

      SetLength(D,Length(S));
      Move(Pointer(S)^,D,Length(S));
      Packet.Payload:=D;

      if Packet.GetData(S) then begin
        FServer.Send(FRemoteIP,FRemoteDataPort,S);
        Inc(FSequence);
        Inc(FTimeStamp,DataSize);
      end;
    finally
      Packet.Free;
    end;
  end;
end;

procedure TBisCallServerEventChannel.SendMessage(Message: TBisCallServerEventMessage; WithWait: Boolean);
begin
  if Assigned(Message) and Assigned(FHandler) then begin
    if SendEvent(Message.AsString) and (FHandler.FWaitRetryCount>0) and WithWait then
//      FWaits.Add(Message,FHandler.FWaitTimeOut).Resume;
  end;
end;

procedure TBisCallServerEventChannel.ServerUDPException(Sender: TObject; ABinding: TIdSocketHandle;
                                                        const AMessage: String; const AExceptionClass: TClass);
begin
  LoggerWrite(AMessage,ltError);
end;

{procedure TBisCallServerEventChannel.ServerUDPRead(Sender: TObject; AData: TIdBytes; ABinding: TIdSocketHandle);
var
  L: Integer;
begin
  try
    L:=Length(AData);
    if (L=FRemoteDataSize) then begin
      DoData(cddIn,AData,L);
    end;
  except
    On E: Exception do begin
      LoggerWrite(E.Message,ltError);
    end;
  end;
end;}

procedure TBisCallServerEventChannel.ServerUDPRead(Sender: TObject; AData: TIdBytes; ABinding: TIdSocketHandle);
var
  Packet: TBisRtpPacket; 
begin
  try
    if (Length(AData)>0) then begin
      Packet:=TBisRtpPacket.Create;
      try
        Packet.Parse(AData);
        if (Packet.Version=vSecond) and
           (Packet.PayloadType=FRemotePayloadType) then begin
          if Length(Packet.Payload)=FRemoteDataSize then
            DoData(cddIn,Packet.Payload,FRemoteDataSize);
        end;
      finally
        Packet.Free;
      end;
    end;
  except
    On E: Exception do begin
      LoggerWrite(E.Message,ltError);
    end;
  end;
end;

procedure TBisCallServerEventChannel.SetOutDataSize(const Value: Integer);
begin
  FOutDataSize:=Value;
end;

procedure TBisCallServerEventChannel.SetOutFormat(const Value: PWaveFormatEx);
begin
  FOutFormat:=Value;
  FLocalDriverFormat:=Value;
end;

function TBisCallServerEventChannel.DataPort: Integer;
begin
  Result:=0;
  if Assigned(FServer) and (FServer.Bindings.Count>0) then begin
    Result:=FServer.Bindings[0].Port;
  end;
end;

function TBisCallServerEventChannel.TryServerActive: Boolean;

  procedure Disable;
  begin
    if FServer.Active then begin
      FServer.OnUDPRead:=nil;
      FServer.Active:=false;
      FServer.Bindings.Clear;
    end;
  end;

  function SetPort(P: Integer): Boolean;
  var
    B: TIdSocketHandle;
  begin
    Result:=false;
    if not UDPPortExists(FLocalIP,P) then begin
      try
        B:=FServer.Bindings.Add;
        B.IP:=FLocalIP;
        B.Port:=P;
        FServer.Active:=true;
        Result:=FServer.Active;
        if Result then
          FServer.OnUDPRead:=ServerUDPRead;
      except
        FServer.Active:=false;
        FServer.OnUDPRead:=nil;
      end;
    end;
  end;

var
  First: Integer;
  MaxPort: Integer;
begin
  Result:=false;
  Disable;
  if not Active then begin
    First:=FLocalPort;
    Inc(First);
    MaxPort:=POWER_2;
    while First<MaxPort do begin
      Result:=SetPort(First);
      if not Result then
        Inc(First)
      else begin
        break;
      end;
    end;
  end;
end;


function TBisCallServerEventChannel.GetEventParams(SessionId: Variant;
                                                   var AccountId: Variant;
                                                   var IP: String; var Port: Integer;
                                                   var UseCompressor: Boolean; var CompressorLevel: TCompressionLevel;
                                                   var UseCrypter: Boolean; var CrypterKey: String;
                                                   var CrypterAlgorithm: TBisCipherAlgorithm; var CrypterMode: TBisCipherMode): Boolean;
var
  P: TBisProvider;
begin
  Result:=false;
  if not Result then begin
    P:=TBisProvider.Create(nil);
    try
      P.ProviderName:='GET_EVENT_PARAMS';
      with P.Params do begin
        AddInvisible('SESSION_ID').Value:=SessionId;
        AddInvisible('ACCOUNT_ID',ptOutput);
        AddInvisible('IP',ptOutput);
        AddInvisible('PORT',ptOutput);
        AddInvisible('USE_CRYPTER',ptOutput);
        AddInvisible('CRYPTER_KEY',ptOutput);
        AddInvisible('CRYPTER_ALGORITHM',ptOutput);
        AddInvisible('CRYPTER_MODE',ptOutput);
        AddInvisible('USE_COMPRESSOR',ptOutput);
        AddInvisible('COMPRESSOR_LEVEL',ptOutput);
      end;
      P.Execute;
      if P.Success then begin
        AccountId:=P.ParamByName('ACCOUNT_ID').Value;
        IP:=P.ParamByName('IP').AsString;
        Port:=P.ParamByName('PORT').AsInteger;
        UseCrypter:=Boolean(P.ParamByName('USE_CRYPTER').AsInteger);
        CrypterKey:=P.ParamByName('CRYPTER_KEY').AsString;
        CrypterAlgorithm:=TBisCipherAlgorithm(P.ParamByName('CRYPTER_ALGORITHM').AsInteger);
        CrypterMode:=TBisCipherMode(P.ParamByName('CRYPTER_MODE').AsInteger);
        UseCompressor:=Boolean(P.ParamByName('USE_COMPRESSOR').AsInteger);
        CompressorLevel:=TCompressionLevel(P.ParamByName('COMPRESSOR_LEVEL').AsInteger);
        Result:=true;
      end;
    finally
      P.Free;
    end;
  end;
end;

function TBisCallServerEventChannel.GetRemoteEventParams(SessionId: Variant): Boolean;
begin
  Result:=GetEventParams(SessionId,
                         FAcceptorId,
                         FRemoteIP,FRemotePort,FRemoteUseCompressor,FRemoteCompressorLevel,
                         FRemoteUseCrypter,FRemoteCrypterKey,FRemoteCrypterAlgorithm,FRemoteCrypterMode);
end;

function TBisCallServerEventChannel.GetLocalEventParams: Boolean;
begin
  Result:=GetEventParams(Core.SessionId,
                         FCreatorId,
                         FLocalIP,FLocalPort,FLocalUseCompressor,FLocalCompressorLevel,
                         FLocalUseCrypter,FLocalCrypterKey,FLocalCrypterAlgorithm,FLocalCrypterMode);
end;

function TBisCallServerEventChannel.DialRequest(Request: TBisCallServerEventRequest): Boolean;

  procedure SendResponse(AMessage: String; AResponseType: TBisCallServerEventResponseType);
  var
    Response: TBisCallServerEventResponse;
  begin
    Response:=TBisCallServerEventResponse.Create(mdOutgoing,SEventResult);
    with Response do begin
      AddSessionId(FRemoteSessionId);
      AddRemoteSessionId(Core.SessionId);
      AddChannelId(FId);
      AddRequestName(Request.Name);
      AddSequence(Request.Sequence);
      AddResponseType(AResponseType);
      AddMessage(AMessage);
    end;
    Request.Responses.Add(Response);
    SendEvent(Response.AsString);
  end;

var
  Message: String;
  ResponseType: TBisCallServerEventResponseType;
begin
  Result:=false;
  if Assigned(Request) and Assigned(Core) then begin
    Message:='';
    ResponseType:=rtUnknown;
    try
      try
        FRemoteSessionId:=Request.RemoteSessionId;
        FRemoteDataPort:=Request.DataPort;
        FRemoteDriverFormat:=FHandler.FDrivers.FindFormat('',Request.FormatTag,Request.Channels,
                                                          Request.SamplesPerSec,Request.BitsPerSample);
        FRemotePayloadType:=FHandler.FDrivers.FormatToPayloadType(FRemoteDriverFormat);
        FRemoteDataSize:=Request.DataSize;
        if GetRemoteEventParams(FRemoteSessionId) and Assigned(FRemoteDriverFormat) then begin
          ResponseType:=rtCancel;
          FAcceptor:=Request.Acceptor;
          FAcceptorType:=Request.AcceptorType;
          if DoCheck then begin
            DoRing;
            ResponseType:=rtOK;
          end;
          Result:=true;
        end;
      except
        On E: Exception do begin
          Message:=E.Message;
          ResponseType:=rtError;
        end;
      end;
    finally
      SendResponse(Message,ResponseType);
    end;
  end;
end;

function TBisCallServerEventChannel.AnswerRequest(Request: TBisCallServerEventRequest): Boolean;

  procedure SendResponse(AMessage: String; AResponseType: TBisCallServerEventResponseType);
  var
    Response: TBisCallServerEventResponse;
  begin
    Response:=TBisCallServerEventResponse.Create(mdOutgoing,SEventResult);
    with Response do begin
      AddSessionId(FRemoteSessionId);
      AddChannelId(FId);
      AddRequestName(Request.Name);
      AddSequence(Request.Sequence);
      AddResponseType(AResponseType);
      AddMessage(AMessage);
    end;
    Request.Responses.Add(Response);
    SendEvent(Response.AsString);
  end;

var
  Message: String;
  ResponseType: TBisCallServerEventResponseType;
begin
  Result:=false;
  if Assigned(Request) and Assigned(FHandler) and (State=csRinning) then begin
    Message:='';
    ResponseType:=rtUnknown;
    try
      try
        ResponseType:=rtCancel;
        FRemoteDataPort:=Request.DataPort;
        FRemoteDriverFormat:=FHandler.FDrivers.FindFormat('',Request.FormatTag,Request.Channels,
                                                   Request.SamplesPerSec,Request.BitsPerSample);
        FRemotePayloadType:=FHandler.FDrivers.FormatToPayloadType(FRemoteDriverFormat);                                                   
        FRemoteDataSize:=Request.DataSize;
        if Assigned(FRemoteDriverFormat) then begin
          DoConnect;
          ResponseType:=rtOK;
        end;
        Result:=true;
      except
        On E: Exception do begin
          Message:=E.Message;
          ResponseType:=rtError;
        end;
      end;
    finally
      SendResponse(Message,ResponseType);
    end;
  end;
end;

function TBisCallServerEventChannel.HangupRequest(Request: TBisCallServerEventRequest): Boolean;

  procedure SendResponse(AMessage: String; AResponseType: TBisCallServerEventResponseType);
  var
    Response: TBisCallServerEventResponse;
  begin
    Response:=TBisCallServerEventResponse.Create(mdOutgoing,SEventResult);
    with Response do begin
      AddSessionId(FRemoteSessionId);
      AddChannelId(FId);
      AddRequestName(Request.Name);
      AddSequence(Request.Sequence);
      AddResponseType(AResponseType);
      AddMessage(AMessage);
    end;
    Request.Responses.Add(Response);
    SendEvent(Response.AsString);
  end;

var
  Message: String;
  ResponseType: TBisCallServerEventResponseType;
begin
  Result:=false;
  if Assigned(Request) and (State in [csRinning,csProcessing,csHolding]) then begin
    Message:='';
    ResponseType:=rtUnknown;
    try
      try
        FCallResultId:=Request.CallResultId;
        DoDisconnect;
        ResponseType:=rtOK;
        Result:=true;
      except
        On E: Exception do begin
          Message:=E.Message;
          ResponseType:=rtError;
        end;
      end;
    finally
      SendResponse(Message,ResponseType);
    end;
  end;
end;

function TBisCallServerEventChannel.HoldRequest(Request: TBisCallServerEventRequest): Boolean;

  procedure SendResponse(AMessage: String; AResponseType: TBisCallServerEventResponseType);
  var
    Response: TBisCallServerEventResponse;
  begin
    Response:=TBisCallServerEventResponse.Create(mdOutgoing,SEventResult);
    with Response do begin
      AddSessionId(FRemoteSessionId);
      AddChannelId(FId);
      AddRequestName(Request.Name);
      AddSequence(Request.Sequence);
      AddResponseType(AResponseType);
      AddMessage(AMessage);
    end;
    Request.Responses.Add(Response);
    SendEvent(Response.AsString);
  end;
  
var
  Message: String;
  ResponseType: TBisCallServerEventResponseType;
begin
  Result:=false;
  if Assigned(Request) and (State in [csProcessing]) then begin
    Message:='';
    ResponseType:=rtUnknown;
    try
      try
        DoHold;
        ResponseType:=rtOK;
        Result:=true;
      except
        On E: Exception do begin
          Message:=E.Message;
          ResponseType:=rtError;
        end;
      end;
    finally
      SendResponse(Message,ResponseType);
    end;
  end;
end;

function TBisCallServerEventChannel.UnHoldRequest(Request: TBisCallServerEventRequest): Boolean;

  procedure SendResponse(AMessage: String; AResponseType: TBisCallServerEventResponseType);
  var
    Response: TBisCallServerEventResponse;
  begin
    Response:=TBisCallServerEventResponse.Create(mdOutgoing,SEventResult);
    with Response do begin
      AddSessionId(FRemoteSessionId);
      AddChannelId(FId);
      AddRequestName(Request.Name);
      AddSequence(Request.Sequence);
      AddResponseType(AResponseType);
      AddMessage(AMessage);
    end;
    Request.Responses.Add(Response);
    SendEvent(Response.AsString);
  end;
  
var
  Message: String;
  ResponseType: TBisCallServerEventResponseType;
begin
  Result:=false;
  if Assigned(Request) and (State in [csHolding]) then begin
    Message:='';
    ResponseType:=rtUnknown;
    try
      try
        DoUnHold;
        ResponseType:=rtOK;
        Result:=true;
      except
        On E: Exception do begin
          Message:=E.Message;
          ResponseType:=rtError;
        end;
      end;
    finally
      SendResponse(Message,ResponseType);
    end;
  end;
end;

function TBisCallServerEventChannel.DialResponse(Response: TBisCallServerEventResponse; var FreeChannel: Boolean): Boolean;
begin
  Result:=false;
  if Assigned(Response) then begin
    case Response.ResponseType of
      rtUnknown: ;
      rtOK: begin
        if DoCheck then begin
          DoRing;
          Result:=true;
        end;
      end;
      rtCancel: begin
        DoCancel;
        Result:=true;
        FreeChannel:=true;
      end;
      rtError: begin
        DoError(Response.Message);
        Result:=true;
        FreeChannel:=true;
      end;
    end;
  end;
end;

function TBisCallServerEventChannel.AnswerResponse(Response: TBisCallServerEventResponse; var FreeChannel: Boolean): Boolean;
begin
  Result:=false;
  if Assigned(Response) then begin
    case Response.ResponseType of
      rtUnknown: ;
      rtOK: begin
        DoConnect;
        Result:=true;
      end;
      rtCancel: ;
      rtError: begin
        DoError(Response.Message);
        Result:=true;
      end;
    end;
  end;
end;

function TBisCallServerEventChannel.HangupResponse(Response: TBisCallServerEventResponse; var FreeChannel: Boolean): Boolean;
begin
  Result:=false;
  if Assigned(Response) then begin
    case Response.ResponseType of
      rtUnknown: ;
      rtOK: begin
        DoDisconnect;
        FreeChannel:=true;
        Result:=true;
      end;
      rtCancel: ;
      rtError: begin
        DoError(Response.Message);
        Result:=true;
      end;
    end;
  end;
end;

procedure TBisCallServerEventChannel.Dial(Acceptor: Variant; AcceptorType: TBisCallServerChannelAcceptorType);
var
  Request: TBisCallServerEventRequest;
begin
  inherited Dial(Acceptor,AcceptorType);
  if Assigned(FHandler) and Assigned(Core) and Assigned(FOutFormat) then begin
    if not VarIsNull(Acceptor) and (AcceptorType=catSession) then begin
      if GetRemoteEventParams(Acceptor) and GetLocalEventParams and TryServerActive then begin
        FRemoteSessionId:=Acceptor;
        Request:=TBisCallServerEventRequest.Create(mdOutgoing,SEventDial);
        with Request do begin
          AddSessionId(FRemoteSessionId);
          AddRemoteSessionId(Core.SessionId);
          AddChannelId(Self.FId);
          AddSequence(FRequests.NextSequence);
          AddDataPort(Self.DataPort);
          with FOutFormat^ do begin
            AddFormatTag(wFormatTag);
            AddChannels(nChannels);
            AddSamplesPerSec(nSamplesPerSec);
            AddBitsPerSample(wBitsPerSample);
          end;
          AddDataSize(FOutDataSize);
          AddCallId(Self.FCallId);
          AddCallerId(Self.FCallerId);
          AddCallerPhone(Self.FCallerPhone);
        end;
        FRequests.Add(Request);
        SendMessage(Request,true);
      end;
    end;
  end;
end;

procedure TBisCallServerEventChannel.Answer;
var
  Request: TBisCallServerEventRequest;
begin
  inherited Answer;
  if Assigned(FHandler) and Assigned(FOutFormat) and GetLocalEventParams and TryServerActive then begin
    Request:=TBisCallServerEventRequest.Create(mdOutgoing,SEventAnswer);
    with Request do begin
      AddSessionId(FRemoteSessionId);
      AddChannelId(Self.FId);
      AddSequence(FRequests.NextSequence);
      AddDataPort(Self.DataPort);
      with FOutFormat^ do begin
        AddFormatTag(wFormatTag);
        AddChannels(nChannels);
        AddSamplesPerSec(nSamplesPerSec);
        AddBitsPerSample(wBitsPerSample);
      end;
      AddDataSize(FOutDataSize);
    end;
    FRequests.Add(Request);
    SendMessage(Request,true);
  end;
end;

procedure TBisCallServerEventChannel.Hangup;
var
  Request: TBisCallServerEventRequest;
begin
  inherited Hangup;
  if Assigned(FHandler) then begin
    Request:=TBisCallServerEventRequest.Create(mdOutgoing,SEventHangup);
    with Request do begin
      AddSessionId(FRemoteSessionId);
      AddChannelId(Self.FId);
      AddSequence(FRequests.NextSequence);
    end;
    FRequests.Add(Request);
    SendMessage(Request,true);
  end;
end;

{ TBisCallServerEventChannels }

constructor TBisCallServerEventChannels.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  with Core.Events do begin
    FEventResult:=Add(SEventResult,ResultHandler,true);
    FEventDial:=Add(SEventDial,DialHandler,true);
    FEventAnswer:=Add(SEventAnswer,AnswerHandler,true);
    FEventHangup:=Add(SEventHangup,HangupHandler,true);
    FEventHold:=Add(SEventHold,HoldHandler,true);
    FEventUnHold:=Add(SEventUnHold,UnHoldHandler,true);
  end;
end;

destructor TBisCallServerEventChannels.Destroy;
begin
  with Core.Events do begin
    Remove(FEventUnHold);
    Remove(FEventHold);
    Remove(FEventHangup);
    Remove(FEventAnswer);
    Remove(FEventDial);
    Remove(FEventResult);
  end;
  inherited Destroy;
end;

procedure TBisCallServerEventChannels.DoChannelDestroy(Channel: TBisCallServerChannel);
begin
  if Assigned(Channel) then
    Channel.Hangup;
  inherited DoChannelDestroy(Channel);
end;

function TBisCallServerEventChannels.Find(Id: String): TBisCallServerEventChannel;
var
  i: Integer;
  Item: TBisCallServerEventChannel;
begin
  Result:=nil;
  for i:=0 to Count-1 do begin
    Item:=Items[i];
    if AnsiSameText(Item.FId,Id) then begin
      Result:=Item;
      exit;
    end;
  end;
end;

function TBisCallServerEventChannels.LockFind(Id: String): TBisCallServerEventChannel;
begin
  Lock;
  try
    Result:=Find(Id);
  finally
    UnLock;
  end;
end;

function TBisCallServerEventChannels.Add(Id: String; Direction: TBisCallServerChannelDirection; CallId: Variant): TBisCallServerEventChannel;
begin
  Result:=Find(Id);
  if not Assigned(Result) then begin
    Result:=TBisCallServerEventChannel(inherited AddClass(TBisCallServerEventChannel,false));
    if Assigned(Result) then begin
      Result.FId:=Id;
      Result.FCallId:=CallId;
      Result.FChannels:=Self;
      Result.FHandler:=FHandler;
      Result.FDirection:=Direction;
    end;
  end;
end;

function TBisCallServerEventChannels.AddOutgoing(CallId, CallerId, CallerPhone: Variant): TBisCallServerEventChannel;
begin
  Result:=Add(GetUniqueID,cdOutgoing,CallId);
  if Assigned(Result) then begin
    Result.FCallerId:=CallerId;
    Result.FCallerPhone:=CallerPhone;
    DoChannelCreate(Result);
  end;
end;

function TBisCallServerEventChannels.LockAddOutgoing(CallId, CallerId, CallerPhone: Variant): TBisCallServerEventChannel;
begin
  Lock;
  try
    Result:=AddOutgoing(CallId,CallerId,CallerPhone);
  finally
    Unlock;
  end;
end;

function TBisCallServerEventChannels.AddIncoming(Request: TBisCallServerEventRequest): TBisCallServerEventChannel;
begin
  Result:=nil;
  if Assigned(Request) then begin
    Result:=Add(Request.ChannelId,cdIncoming,Request.CallId);
    if Assigned(Result) then begin
      Result.FCallerId:=Request.CallerId;
      Result.FCallerPhone:=Request.CallerPhone;
      Result.FRequests.Add(Request);
      DoChannelCreate(Result);
    end;
  end;
end;

function TBisCallServerEventChannels.LockAddIncoming(Request: TBisCallServerEventRequest): TBisCallServerEventChannel;
begin
  Lock;
  try
    Result:=AddIncoming(Request);
  finally
    Unlock;
  end;
end;

function TBisCallServerEventChannels.GetItem(Index: Integer): TBisCallServerEventChannel;
begin
  Result:=TBisCallServerEventChannel(inherited Items[Index]);
end;

function TBisCallServerEventChannels.ResultHandler(Event: TBisEvent; InParams, OutParams: TBisEventParams): Boolean;
var
  Channel: TBisCallServerEventChannel;
  Response: TBisCallServerEventResponse;
  Request: TBisCallServerEventRequest;
  FreeChannel: Boolean;
begin
  Result:=false;
  Response:=TBisCallServerEventResponse.Create(mdIncoming,Event.Name,InParams);
  if Assigned(Response) then begin
    Channel:=LockFind(Response.ChannelId);
    if Assigned(Channel) then begin
      FreeChannel:=false;
      Channel.Lock;
      try
        Request:=Channel.FRequests.Find(Response);
        if Assigned(Request) then begin

          Request.Responses.Add(Response);

          if AnsiSameText(Response.RequestName,SEventDial) then
            Result:=Channel.DialResponse(Response,FreeChannel);

          if AnsiSameText(Response.RequestName,SEventAnswer) then
            Result:=Channel.AnswerResponse(Response,FreeChannel);

          if AnsiSameText(Response.RequestName,SEventHangup) then
            Result:=Channel.HangupResponse(Response,FreeChannel);

          if not Result then
            Request.Responses.Remove(Response);

        end else
          Response.Free;
      finally
        Channel.Unlock;
        if FreeChannel then
          LockRemove(Channel);
      end;
    end else
      Response.Free;
  end;
end;

function TBisCallServerEventChannels.DialHandler(Event: TBisEvent; InParams, OutParams: TBisEventParams): Boolean;
var
  Request: TBisCallServerEventRequest;
  Channel: TBisCallServerEventChannel;
begin
  Result:=false;
  Request:=TBisCallServerEventRequest.Create(mdIncoming,Event.Name,InParams);
  if Assigned(Request) then begin
    Channel:=LockAddIncoming(Request);
    if Assigned(Channel) then begin
      Channel.Lock;
      try
        Result:=Channel.DialRequest(Request);
      finally
        Channel.Unlock;
      end;
      if not Result then
        LockRemove(Channel);
    end else
      Request.Free;
  end;
end;

function TBisCallServerEventChannels.AnswerHandler(Event: TBisEvent; InParams, OutParams: TBisEventParams): Boolean;
var
  Request: TBisCallServerEventRequest;
  Channel: TBisCallServerEventChannel;
begin
  Result:=false;
  Request:=TBisCallServerEventRequest.Create(mdIncoming,Event.Name,InParams);
  if Assigned(Request) then begin
    Channel:=LockFind(Request.ChannelId);
    if Assigned(Channel) then begin
      Channel.Lock;
      try
        Channel.FRequests.Add(Request);
        Result:=Channel.AnswerRequest(Request);
      finally
        Channel.Unlock;
      end;
    end else
      Request.Free;
  end;
end;

function TBisCallServerEventChannels.HangupHandler(Event: TBisEvent; InParams, OutParams: TBisEventParams): Boolean;
var
  Request: TBisCallServerEventRequest;
  Channel: TBisCallServerEventChannel;
begin
  Result:=false;
  Request:=TBisCallServerEventRequest.Create(mdIncoming,Event.Name,InParams);
  if Assigned(Request) then begin
    Channel:=LockFind(Request.ChannelId);
    if Assigned(Channel) then begin
      Channel.Lock;
      try
        Channel.FRequests.Add(Request);
        Result:=Channel.HangupRequest(Request);
      finally
        Channel.Unlock;
        LockRemove(Channel);
      end;
    end else
      Request.Free;
  end;
end;

function TBisCallServerEventChannels.HoldHandler(Event: TBisEvent; InParams, OutParams: TBisEventParams): Boolean;
var
  Request: TBisCallServerEventRequest;
  Channel: TBisCallServerEventChannel;
begin
  Result:=false;
  Request:=TBisCallServerEventRequest.Create(mdIncoming,Event.Name,InParams);
  if Assigned(Request) then begin
    Channel:=LockFind(Request.ChannelId);
    if Assigned(Channel) then begin
      Channel.Lock;
      try
        Channel.FRequests.Add(Request);
        Result:=Channel.HoldRequest(Request);
      finally
        Channel.Unlock;
      end;
    end else
      Request.Free;
  end;
end;

function TBisCallServerEventChannels.UnHoldHandler(Event: TBisEvent; InParams, OutParams: TBisEventParams): Boolean;
var
  Request: TBisCallServerEventRequest;
  Channel: TBisCallServerEventChannel;
begin
  Result:=false;
  Request:=TBisCallServerEventRequest.Create(mdIncoming,Event.Name,InParams);
  if Assigned(Request) then begin
    Channel:=LockFind(Request.ChannelId);
    if Assigned(Channel) then begin
      Channel.Lock;
      try
        Channel.FRequests.Add(Request);
        Result:=Channel.UnHoldRequest(Request);
      finally
        Channel.Unlock;
      end;
    end else
      Request.Free;
  end;
end;

{ TBisCallServerEventHandler }

constructor TBisCallServerEventHandler.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  Channels.FHandler:=Self;

  FDrivers:=TBisRtpAcmDrivers.Create;

  FIdleTimeOut:=60000;
  FSweepInterval:=1000;

  FWaitRetryCount:=3;
  FWaitTimeOut:=1000;
end;

destructor TBisCallServerEventHandler.Destroy;
begin
  FDrivers.Free;
  inherited Destroy;
end;

procedure TBisCallServerEventHandler.Init;
begin
  inherited Init;
  with Params do begin
    FWaitRetryCount:=AsInteger(SParamRequestRetryCount,FWaitRetryCount);
    FWaitTimeOut:=AsInteger(SParamRequestTimeOut,FWaitTimeOut);
    FIdleTimeOut:=AsInteger(SParamIdleTimeOut,FIdleTimeOut);
    FSweepInterval:=AsInteger(SParamIdleTimeOut,FSweepInterval);
  end;
end;

function TBisCallServerEventHandler.AddOutgoingChannel(CallId,CallerId,CallerPhone: Variant): TBisCallServerChannel;
begin
  Result:=Channels.LockAddOutgoing(CallId,CallerId,CallerPhone);
end;

function TBisCallServerEventHandler.GetChannels: TBisCallServerEventChannels;
begin
  Result:=TBisCallServerEventChannels(inherited Channels);
end;

function TBisCallServerEventHandler.GetChannelsClass: TBisCallServerChannelsClass;
begin
  Result:=TBisCallServerEventChannels;
end;

function TBisCallServerEventHandler.GetConnected: Boolean;
begin
  Result:=inherited GetConnected;
  if Assigned(Core) then
    Result:=true;
end;

procedure TBisCallServerEventHandler.Connect;
begin
  inherited Connect;
end;

procedure TBisCallServerEventHandler.Disconnect;
begin
  inherited Disconnect;
end;

end.
