// DO NOT EDIT THIS FILE - WARNING WARNING - Generated file

{$HINTS OFF}
unit DBXRowBuffer;
interface
uses
  DBXBinaryStream,
  DBXCommon,
  DBXErrorHandler,
  DBXJSonStreamReader,
  DBXJSonStreamWriter,
  DBXPlatform,
  DBXRowBlobStreamReader,
  DBXStringDecoder,
  DBXStringEncoder,
  SysUtils;
type
  TDBXRowBuffer = class(TDBXBinaryStream)
  public
    constructor Create;
    function NextRow: Boolean;
    function GoToRow(Row: Integer): Boolean;
    procedure GoToField(Ordinal: Integer);
    function ReadParameterBlobSize: Integer;
    function ReadReaderBlobSize: Integer;
    procedure ReadBytes(DestBuf: TBytes; DestOff: Integer; Count: Integer);
    function ReadNull: Boolean;
    function ReadEncodedStringLength: Integer;
    function ReadChars(const CharBuf: TDBXWideChars; MaxChars: Integer): Integer;
    function ReadString: WideString;
    function ReadStringBytes(const ByteBuf: TBytes; Offset: Integer): Integer; overload;
    function ReadStringBytes: TBytes; overload;
    procedure WriteBoolean(Data: Boolean);
    procedure WriteByte(Data: Byte);
    procedure WriteShort(Data: SmallInt);
    procedure WriteInt32(Data: Integer);
    procedure WriteNull;
    function WriteBytes(Reader: TDBXStreamReader): Integer; virtual;
    procedure WriteInt64(Data: Int64);
    procedure WriteDouble(Data: Double);
    procedure WriteSingle(Data: Single);
    procedure WriteTimestamp(TimeValue: Int64; Nanos: Integer);
    procedure WriteBcd(Value: TBytes; SignNum: Integer; Scale: Integer);
    function WriteString(Data: WideString): Boolean;
    procedure Post;
    procedure Cancel;
    procedure ReadDataBytes; virtual;
    function ReadBlobStreamReader: TDBXStreamReader;
    destructor Destroy; override;
  protected
    procedure SetPreventDecoderGrowth(PreventGrowth: Boolean); virtual;
    function IsNull: Boolean;
    function IsLastParameterBlobSegment: Boolean;
    function IsBlobHeader: Boolean;
    function GetEncodedStringLength: Integer;
    function GetStringBytesLength: Integer;
    function GetOverflowStringBytes: TBytes;
    procedure SetReadSize(Size: Integer);
    procedure SetClient(Client: Boolean); virtual;
    function GetRowBlobStreamReader: TDBXRowBlobStreamReader;
    procedure SetDbxStreamReader(DbxStreamReader: TDBXJSonStreamReader); virtual;
    procedure SetDbxStreamWriter(DbxStreamWriter: TDBXJSonStreamWriter); virtual;
    function GetEncoder: TDBXStringEncoder; virtual;
    function GetMaxInline: Integer; virtual;
    function IsParameterBuffer: Boolean; virtual;
    procedure SetParameterBuffer(ParameterBuffer: Boolean); virtual;
  private
    procedure GrowRowOffsets;
    procedure InitRowBlobStreamReader(Reader: TDBXRowBlobStreamReader);
  private
    FBlobStreamReader: TDBXRowBlobStreamReader;
    FClient: Boolean;
    FHandle: Integer;
    FBlobId: Integer;
    FDbxStreamReader: TDBXJSonStreamReader;
    FDbxStreamWriter: TDBXJSonStreamWriter;
    FBlobStringBuffer: TBytes;
    FEncoder: TDBXStringEncoder;
    FDecoder: TDBXStringDecoder;
    FErrorHandler: TDBXErrorHandler;
    FCurrentTotalRow: Int64;
    FCurrentRow: Integer;
    FColumnCount: Integer;
    FRowCount: Integer;
    FRowOffsets: TDBXInt32s;
    FReadSize: Integer;
    FMaxInline: Integer;
    FParameterBuffer: Boolean;
  public
    property PreventDecoderGrowth: Boolean write SetPreventDecoderGrowth;
    property ErrorHandler: TDBXErrorHandler write FErrorHandler;
    property Null: Boolean read IsNull;
    property LastParameterBlobSegment: Boolean read IsLastParameterBlobSegment;
    property BlobHeader: Boolean read IsBlobHeader;
    property EncodedStringLength: Integer read GetEncodedStringLength;
    property StringBytesLength: Integer read GetStringBytesLength;
    property BcdBuffer: TBytes read FBigDecimalBuffer;
    property OverflowStringBytes: TBytes read GetOverflowStringBytes;
    property buf: TBytes read FBuf;
    property offset: Integer read FOff;
    property ReadSize: Integer read FReadSize write SetReadSize;
    property ColumnCount: Integer write FColumnCount;
    property Client: Boolean write SetClient;
    property Handle: Integer write FHandle;
    property DbxStreamReader: TDBXJSonStreamReader write SetDbxStreamReader;
    property DbxStreamWriter: TDBXJSonStreamWriter write SetDbxStreamWriter;
    property Encoder: TDBXStringEncoder read GetEncoder;
    property MaxInline: Integer read GetMaxInline;
    property Decoder: TDBXStringDecoder read FDecoder;
    property ParameterBuffer: Boolean read IsParameterBuffer write SetParameterBuffer;
  private
    property RowBlobStreamReader: TDBXRowBlobStreamReader read GetRowBlobStreamReader;
  end;

implementation
uses
  DBXFieldHeader,
  DBXFieldPacker,
  DBXPlatformUtil;

constructor TDBXRowBuffer.Create;
begin
  inherited Create;
  SetLength(FRowOffsets,16);
  FDecoder := TDBXStringDecoder.Create;
  FEncoder := TDBXStringEncoder.Create;
  FMaxInline := 1024;
end;

procedure TDBXRowBuffer.SetPreventDecoderGrowth(PreventGrowth: Boolean);
begin
  FDecoder.PreventGrowth := PreventGrowth;
end;

procedure TDBXRowBuffer.GrowRowOffsets;
var
  Temp: TDBXInt32s;
begin
  SetLength(Temp,FRowCount + 16);
  TDBXPlatform.CopyInt32Array(FRowOffsets, 0, Temp, 0, Length(FRowOffsets));
  FRowOffsets := Temp;
end;

function TDBXRowBuffer.NextRow: Boolean;
var
  Index: Integer;
begin
  if FOff < FReadSize then
  begin
//      off = rowOffsets[currentRow];
//      for (int index = 0; index < columnCount; ++index) {
    for index := FCurrentOrdinal to FColumnCount - 1 do
      SkipField;
    FCurrentOrdinal := 0;
    if FOff < FReadSize then
    begin
      FCurrentTotalRow := FCurrentTotalRow + 1;
      if Incr(FCurrentRow) > FRowCount then
      begin
        FRowCount := FCurrentRow;
        if FRowCount >= Length(FRowOffsets) then
          GrowRowOffsets;
        FRowOffsets[FCurrentRow] := FOff;
      end;
      begin
        Result := True;
        exit;
      end;
    end;
    Result := False;
  end
  else 
    Result := False;
end;

function TDBXRowBuffer.GoToRow(Row: Integer): Boolean;
begin
  if Row > FRowCount then
    while NextRow do
    begin
      if FCurrentRow = Row then
      begin
        Result := True;
        exit;
      end;
    end;
  Result := False;
end;

procedure TDBXRowBuffer.GoToField(Ordinal: Integer);
begin
  if FCurrentOrdinal > Ordinal then
  begin
    FCurrentOrdinal := 0;
    FOff := FRowOffsets[FCurrentRow];
  end;
  while Ordinal > FCurrentOrdinal do
    SkipField;
end;

function TDBXRowBuffer.IsNull: Boolean;
begin
  Result := ((Integer(FBuf[FOff])) and TDBXFieldHeader.FNullValue) <> 0;
end;

function TDBXRowBuffer.IsLastParameterBlobSegment: Boolean;
var
  Header: Integer;
begin
  Header := (Integer(FBuf[FOff]));
//    return ((header & FieldHeader.Positive) == 0) && (header != FieldHeader.BlobHeader);
//    return (header & FieldHeader.BlobMask) != FieldHeader.BlobHeader;
  Result := ((Header and TDBXFieldHeader.FPositive) = 0) and (Header <> TDBXFieldHeader.FBlobHeader) and (Header <> TDBXFieldHeader.FBlobRefHeader);
end;

function TDBXRowBuffer.ReadParameterBlobSize: Integer;
var
  Size: Integer;
begin
  Size := ((FBuf[Incr(FOff)] and 255) shl 8) or (FBuf[Incr(FOff)] and 255);
  Incr(FOff);
  Result := Size;
end;

function TDBXRowBuffer.ReadReaderBlobSize: Integer;
var
  Size: Integer;
  Header: Integer;
begin
  Size := 0;
  Header := Integer(FBuf[IncrAfter(FOff)]);
  if (Header and TDBXFieldHeader.FTinyField) <> 0 then
    Size := Header and TDBXFieldHeader.FTinyHeaderLengthMask
  else if (Header and TDBXFieldHeader.FBigField) = TDBXFieldHeader.FBigField then
    Size := ((FBuf[IncrAfter(FOff)] and 255) shl 8) or (FBuf[IncrAfter(FOff)] and 255)
  else if (Header and TDBXFieldHeader.FBlobHeader) <> 0 then
  begin
    Decr(FOff);
    Size := TDBXFieldPacker.GetBlobLength(FBuf, FOff);
    FOff := FOff + TDBXFieldPacker.GetBlobHeaderLength(FBuf, FOff);
  end
  else 
    ;
  Incr(FCurrentOrdinal);
  Result := Size;
end;

function TDBXRowBuffer.IsBlobHeader: Boolean;
begin
  Result := (((Integer(FBuf[FOff])) and TDBXFieldHeader.FBlobMask) or TDBXFieldHeader.FPositive) = (TDBXFieldHeader.FBlobHeader or TDBXFieldHeader.FPositive);
end;

procedure TDBXRowBuffer.ReadBytes(DestBuf: TBytes; DestOff: Integer; Count: Integer);
begin
  TDBXPlatform.CopyByteArray(FBuf, FOff, DestBuf, DestOff, Count);
  FOff := FOff + Count;
end;

function TDBXRowBuffer.ReadNull: Boolean;
begin
  Incr(FOff);
  Incr(FCurrentOrdinal);
  if (FBuf[FOff - 1] and TDBXFieldHeader.FAssignedNull) <> 0 then
  begin
    Result := True;
    exit;
  end;
  Result := False;
end;

function TDBXRowBuffer.GetEncodedStringLength: Integer;
var
  SaveOff: Integer;
  Size: Integer;
begin
  SaveOff := FOff;
  Size := ReadEncodedStringLength;
  FOff := SaveOff;
  Result := Size;
end;

function TDBXRowBuffer.ReadEncodedStringLength: Integer;
var
  Size: Integer;
  Header: Integer;
begin
  Header := Integer(FBuf[IncrAfter(FOff)]);
  if (Header and TDBXFieldHeader.FTinyField) <> 0 then
    Size := Header and TDBXFieldHeader.FTinyHeaderLengthMask
  else if (Header and TDBXFieldHeader.FBigField) = TDBXFieldHeader.FBigField then
    Size := ((FBuf[IncrAfter(FOff)] and 255) shl 8) or (FBuf[IncrAfter(FOff)] and 255)
  else if Header = TDBXFieldHeader.FNullTermStringField then
  begin
    Decr(FOff);
    if FTwoByteStringTerminator then
      Size := SkipNullTermString - TDBXFieldHeader.FTinyHeaderLength - TDBXFieldHeader.FOldNullTermLength
    else 
      Size := SkipNullTermString - TDBXFieldHeader.FTinyHeaderLength - TDBXFieldHeader.FNullTermLength;
    Incr(FOff);
  end
  else if (Header and TDBXFieldHeader.FBlobHeader) <> 0 then
  begin
    Decr(FOff);
    Size := TDBXFieldPacker.GetBlobLength(FBuf, FOff);
    FOff := FOff + TDBXFieldPacker.GetBlobHeaderLength(FBuf, FOff);
  end
  else 
  begin
    FErrorHandler.HandleError(0, 'Unexpected header', nil);
    Size := 0;
  end;
  Result := Size;
end;

function TDBXRowBuffer.ReadChars(const CharBuf: TDBXWideChars; MaxChars: Integer): Integer;
var
  EncodedSize: Integer;
  Size: Integer;
  Reader: TDBXStreamReader;
  FreeReader: Boolean;
  Count: Integer;
begin
  FreeReader := False;
  FDecoder.InitWideCharsDecoder(CharBuf);
  if LastParameterBlobSegment then
  begin
    EncodedSize := ReadEncodedStringLength;
    FDecoder.Decode(FBuf, FOff, MaxChars);
    FOff := FOff + EncodedSize;
    Incr(FCurrentOrdinal);
  end
  else 
  begin
    if FClient or BlobHeader then
    begin
      Reader := RowBlobStreamReader;
      FreeReader := False;
    end
    else 
    begin
      Reader := ReadBlobStreamReader;
      FreeReader := True;
    end;
    try
      if FBlobStringBuffer = nil then
        SetLength(FBlobStringBuffer,256);
      while not Reader.Eos do
      begin
        Count := Reader.Read(FBlobStringBuffer, 0, Length(FBlobStringBuffer));
        FDecoder.Decode(FBlobStringBuffer, 0, Count);
      end;
    finally
      if FreeReader then
        FreeAndNil(Reader);
    end;
  end;
  Size := FDecoder.DecodeOff + 1;
  FDecoder.AddNullChar;
  Result := Size;
end;

function TDBXRowBuffer.ReadString: WideString;
var
  Size: Integer;
  Reader: TDBXStreamReader;
  Count: Integer;
begin
  FDecoder.InitDecoder;
  if LastParameterBlobSegment then
  begin
    Size := ReadEncodedStringLength;
    FDecoder.Decode(FBuf, FOff, Size);
    Incr(FCurrentOrdinal);
    FOff := FOff + Size;
  end
  else 
  begin
    if BlobHeader then
      Reader := RowBlobStreamReader
    else 
      Reader := ReadBlobStreamReader;
    if FBlobStringBuffer = nil then
      SetLength(FBlobStringBuffer,256);
    while not Reader.Eos do
    begin
      Count := Reader.Read(FBlobStringBuffer, 0, Length(FBlobStringBuffer));
      FDecoder.Decode(FBlobStringBuffer, 0, Count);
    end;
  end;
  Result := TDBXPlatform.CreateWideString(FDecoder.DecodeBuf, FDecoder.DecodeOff + 1);
end;

function TDBXRowBuffer.ReadStringBytes(const ByteBuf: TBytes; Offset: Integer): Integer;
var
  Reader: TDBXRowBlobStreamReader;
  Size: Integer;
  EncodedSize: Integer;
  Count: Integer;
begin
  if BlobHeader then
  begin
    Reader := RowBlobStreamReader;
    if FBlobStringBuffer = nil then
      SetLength(FBlobStringBuffer,256);
    Count := 0;
    if not Reader.Eos then
    begin
      Count := Reader.Read(FBlobStringBuffer, 0, Length(FBlobStringBuffer));
      FDecoder.DecodeToWideBytes(FBlobStringBuffer, 0, ByteBuf, Count);
      while not Reader.Eos do
      begin
        Count := Reader.Read(FBlobStringBuffer, 0, Length(FBlobStringBuffer));
        FDecoder.DecodeBytes(FBlobStringBuffer, 0, Count);
      end;
    end;
  end
  else 
  begin
    Incr(FCurrentOrdinal);
    EncodedSize := ReadEncodedStringLength;
    FDecoder.DecodeToWideBytes(FBuf, FOff, ByteBuf, EncodedSize);
    FOff := FOff + EncodedSize;
  end;
  Size := FDecoder.DecodeByteOff - Offset;
  ByteBuf[Size + 1] := Ord(#$0);
  ByteBuf[Size + 2] := Ord(#$0);
  Result := Size + 2;
end;

function TDBXRowBuffer.ReadStringBytes: TBytes;
var
  Size: Integer;
  Count: Integer;
  Reader: TDBXRowBlobStreamReader;
begin
  if BlobHeader then
  begin
    Size := ReadReaderBlobSize;
    Reader := RowBlobStreamReader;
    if FBlobStringBuffer = nil then
      SetLength(FBlobStringBuffer,256);
    FDecoder.InitByteDecoder((Size + 1) * 2);
    while not Reader.Eos do
    begin
      Count := Reader.Read(FBlobStringBuffer, 0, Length(FBlobStringBuffer));
      FDecoder.DecodeBytes(FBlobStringBuffer, 0, Count);
    end;
    FOff := FOff + Size;
  end
  else 
  begin
    Size := ReadEncodedStringLength;
    FDecoder.InitByteDecoder((Size + 1) * 2);
    FDecoder.DecodeBytes(FBuf, FOff, Size);
    Incr(FCurrentOrdinal);
    FOff := FOff + Size;
  end;
  Result := FDecoder.ExtractDecodeByteBuffer;
end;

function TDBXRowBuffer.GetStringBytesLength: Integer;
begin
  Result := FDecoder.DecodeByteOff + 1;
end;

procedure TDBXRowBuffer.WriteBoolean(Data: Boolean);
begin
  if FOff >= FBufLength then
    Growbuf(1);
  if Data then
    FBuf[IncrAfter(FOff)] := Byte((TDBXFieldHeader.FTinyField + TDBXFieldHeader.FPositive))
  else 
    FBuf[IncrAfter(FOff)] := Byte((TDBXFieldHeader.FTinyField));
end;

procedure TDBXRowBuffer.WriteByte(Data: Byte);
begin
  WriteShort(Data);
end;

procedure TDBXRowBuffer.WriteShort(Data: SmallInt);
begin
  if FOff + 3 > FBufLength then
    Growbuf(3);
  FOff := FOff + TDBXFieldPacker.PackAsciiShort(FBuf, FOff, Data, True);
end;

procedure TDBXRowBuffer.WriteInt32(Data: Integer);
begin
  if FOff + 5 > FBufLength then
    Growbuf(5);
  FOff := FOff + TDBXFieldPacker.PackAsciiInt(FBuf, FOff, Data, True);
end;

procedure TDBXRowBuffer.WriteNull;
begin
  if FOff + 1 > FBufLength then
    Growbuf(1);
  FBuf[IncrAfter(FOff)] := Byte(TDBXFieldHeader.FAssignedNull);
end;

function TDBXRowBuffer.WriteBytes(Reader: TDBXStreamReader): Integer;
var
  Count: Integer;
begin
  if FOff + FMaxInline > FBufLength then
    Growbuf(FMaxInline);
  Count := Reader.Read(FBuf, FOff + TDBXFieldHeader.FBigHeaderLength, FMaxInline);
  if Count < 1 then
    FBuf[IncrAfter(FOff)] := Byte((TDBXFieldHeader.FTinyField))
  else 
  begin
    if Reader.Eos then
      FBuf[FOff] := Byte((TDBXFieldHeader.FBigField))
    else 
      FBuf[FOff] := Byte((TDBXFieldHeader.FBigField + TDBXFieldHeader.FPositive));
    FBuf[FOff + 1] := Byte(((Count shr 8) and 255));
    FBuf[FOff + 2] := Byte(((Count) and 255));
    FOff := FOff + Count + TDBXFieldHeader.FBigHeaderLength;
  end;
  Result := Count;
end;

procedure TDBXRowBuffer.WriteInt64(Data: Int64);
begin
  if FOff + 9 > FBufLength then
    Growbuf(9);
  FOff := FOff + TDBXFieldPacker.PackAsciiLong(FBuf, FOff, Data, True);
end;

procedure TDBXRowBuffer.WriteDouble(Data: Double);
begin
  if FOff + 9 > FBufLength then
    Growbuf(9);
  FOff := FOff + TDBXFieldPacker.PackDouble(FBuf, FOff, Data, False);
end;

procedure TDBXRowBuffer.WriteSingle(Data: Single);
begin
  if FOff + 5 > FBufLength then
    Growbuf(5);
  FOff := FOff + TDBXFieldPacker.PackFloat(FBuf, FOff, Data, False);
end;

procedure TDBXRowBuffer.WriteTimestamp(TimeValue: Int64; Nanos: Integer);
var
  StartPos: Integer;
begin
  if FOff + 14 > FBufLength then
    Growbuf(14);
  StartPos := IncrAfter(FOff);
  WriteInt64(TimeValue);
  if Nanos <> 0 then
  begin
    TDBXFieldPacker.PackInt(FBuf, FOff, Nanos);
    FOff := FOff + 4;
  end;
  FBuf[StartPos] := Byte((TDBXFieldHeader.FTinyField + (FOff - StartPos)));
end;

procedure TDBXRowBuffer.WriteBcd(Value: TBytes; SignNum: Integer; Scale: Integer);
begin
end;

function TDBXRowBuffer.WriteString(Data: WideString): Boolean;
var
  EncodeStartOff: Integer;
  Fits: Boolean;
  EncodeEndOff: Integer;
  EncodeLength: Integer;
  DataLength: Integer;
  SaveOff: Integer;
begin
  DataLength := Length(Data);
  if (FOff + FMaxInline + TDBXFieldHeader.FMaxHeaderLength) > FBufLength then
    Growbuf(TDBXFieldHeader.FMaxHeaderLength + FMaxInline);
  if DataLength <= TDBXFieldHeader.FTinyHeaderLengthMask then
    EncodeStartOff := FOff + TDBXFieldHeader.FTinyHeaderLength
  else 
    EncodeStartOff := FOff + TDBXFieldHeader.FBigHeaderLength;
  Fits := not FEncoder.Encode(Data, FBuf, EncodeStartOff, FMaxInline, False);
  EncodeEndOff := FEncoder.EncodeOff;
  EncodeLength := EncodeEndOff - EncodeStartOff;
  if Fits then
  begin
    if (EncodeLength > TDBXFieldHeader.FTinyHeaderLengthMask) and (EncodeStartOff = (FOff + TDBXFieldHeader.FTinyHeaderLength)) then
    begin
      TDBXPlatform.CopyByteArray(FBuf, EncodeStartOff, FBuf, EncodeStartOff + (TDBXFieldHeader.FBigHeaderLength - TDBXFieldHeader.FTinyHeaderLength), EncodeLength);
      EncodeEndOff := EncodeEndOff + (TDBXFieldHeader.FBigHeaderLength - TDBXFieldHeader.FTinyHeaderLength);
    end;
    TDBXFieldPacker.PackStringHeader(FBuf, FOff, EncodeLength);
    FOff := EncodeEndOff;
  end
  else 
  begin
    TDBXPlatform.CopyByteArray(FEncoder.EncodeBuf, 0, FBuf, EncodeStartOff, FMaxInline);
    SaveOff := FOff;
    FOff := FOff + TDBXFieldPacker.PackStringHeader(FBuf, FOff, FMaxInline);
    FBuf[SaveOff] := FBuf[SaveOff] or TDBXFieldHeader.FPositive;
    FOff := FOff + FMaxInline;
  end;
  Result := Fits;
end;

function TDBXRowBuffer.GetOverflowStringBytes: TBytes;
var
  Overflow: TBytes;
begin
  SetLength(Overflow,FEncoder.EncodeOff - FMaxInline);
  TDBXPlatform.CopyByteArray(FEncoder.EncodeBuf, FMaxInline, Overflow, 0, FEncoder.EncodeOff - FMaxInline);
  Result := Overflow;
end;

procedure TDBXRowBuffer.Post;
begin
  FOff := 0;
end;

procedure TDBXRowBuffer.Cancel;
begin
  FOff := 0;
end;

procedure TDBXRowBuffer.SetReadSize(Size: Integer);
begin
  FReadSize := Size;
  FCurrentOrdinal := 0;
  FCurrentRow := 0;
  FOff := 0;
  FRowCount := 0;
end;

procedure TDBXRowBuffer.SetClient(Client: Boolean);
begin
  self.FClient := Client;
end;

procedure TDBXRowBuffer.InitRowBlobStreamReader(Reader: TDBXRowBlobStreamReader);
var
  IsBlobHeader: Boolean;
  Size: Integer;
  BufferSize: Integer;
begin
  Reader.Row := FCurrentTotalRow;
  Reader.Ordinal := FCurrentOrdinal;
  Reader.Id := Incr(FBlobId);
  Reader.ParameterBuffer := FParameterBuffer;
  IsBlobHeader := BlobHeader;
  Size := ReadReaderBlobSize;
  BufferSize := 1 * 1024;
  if BufferSize < Size then
    BufferSize := Size;
  Reader.Init(IsBlobHeader, Size, BufferSize);
  if not IsBlobHeader then
  begin
    Reader.Store(FBuf, FOff, Size);
    FOff := FOff + Size;
  end;
end;

procedure TDBXRowBuffer.ReadDataBytes;
var
  ParameterBytes: Integer;
begin
  ParameterBytes := FDbxStreamReader.ReadInt;
  MinBufferSize := ParameterBytes;
  FDbxStreamReader.NextValueSeparator;
  ReadSize := 0;
  FDbxStreamReader.ReadDataBytes(Buffer, 0, ParameterBytes);
end;

function TDBXRowBuffer.ReadBlobStreamReader: TDBXStreamReader;
var
  Reader: TDBXRowBlobStreamReader;
begin
  Reader := TDBXRowBlobStreamReader.Create;
  Reader.Client := FClient;
  Reader.Handle := FHandle;
  Reader.StreamReader := FDbxStreamReader;
  Reader.StreamWriter := FDbxStreamWriter;
  InitRowBlobStreamReader(Reader);
  Result := Reader;
end;

function TDBXRowBuffer.GetRowBlobStreamReader: TDBXRowBlobStreamReader;
begin
  if FBlobStreamReader = nil then
  begin
    FBlobStreamReader := TDBXRowBlobStreamReader.Create;
    FBlobStreamReader.Client := FClient;
    FBlobStreamReader.Handle := FHandle;
    FBlobStreamReader.StreamReader := FDbxStreamReader;
    FBlobStreamReader.StreamWriter := FDbxStreamWriter;
  end;
  InitRowBlobStreamReader(FBlobStreamReader);
  Result := FBlobStreamReader;
end;

procedure TDBXRowBuffer.SetDbxStreamReader(DbxStreamReader: TDBXJSonStreamReader);
begin
  self.FDbxStreamReader := DbxStreamReader;
end;

procedure TDBXRowBuffer.SetDbxStreamWriter(DbxStreamWriter: TDBXJSonStreamWriter);
begin
  self.FDbxStreamWriter := DbxStreamWriter;
end;

destructor TDBXRowBuffer.Destroy;
begin
  FreeAndNil(FDecoder);
  FreeAndNil(FEncoder);
  FreeAndNil(FBlobStreamReader);
  inherited Destroy;
end;

function TDBXRowBuffer.GetEncoder: TDBXStringEncoder;
begin
  Result := FEncoder;
end;

function TDBXRowBuffer.GetMaxInline: Integer;
begin
  Result := FMaxInline;
end;

function TDBXRowBuffer.IsParameterBuffer: Boolean;
begin
  Result := FParameterBuffer;
end;

procedure TDBXRowBuffer.SetParameterBuffer(ParameterBuffer: Boolean);
begin
  self.FParameterBuffer := ParameterBuffer;
end;

end.
