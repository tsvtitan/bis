// DO NOT EDIT THIS FILE - WARNING WARNING - Generated file
unit DBXFieldPacker;
interface
uses
  DBXPlatform,
  SysUtils;
type
  TDBXFieldPacker = class
  public
    class function UnpackInt(Buf: TBytes; Offset: Integer): Integer; static;
    class procedure PackInt(Buf: TBytes; Offset: Integer; IVal: Integer); static;
    class function RepackRealForIndex(SourceBuf: TBytes; SourceOff: Integer; DestBuf: TBytes; DestOff: Integer; &Type: Integer): Integer; static;
    class function UnpackDoubleAsInt64(Buf: TBytes; Offset: Integer): Int64; static;
    class function UnpackDouble(Buf: TBytes; Offset: Integer): Double; static;
    class function PackDouble(Buf: TBytes; Offset: Integer; DValue: Double; ForIndex: Boolean): Integer; static;
    class function UnpackFloat(Buf: TBytes; Offset: Integer): Single; static;
    class function PackFloat(Buf: TBytes; Offset: Integer; FValue: Single; ForIndex: Boolean): Integer; static;
    class function PackAsciiShort(Buf: TBytes; Offset: Integer; SVal: Integer; Compact: Boolean): Integer; static;
    class function PackAsciiInt(Buf: TBytes; Offset: Integer; IVal: Integer; Compact: Boolean): Integer; static;
    class function PackAsciiLong(Buf: TBytes; Offset: Integer; LVal: Int64; Compact: Boolean): Integer; static;
    class function PackStringHeader(Buffer: TBytes; Off: Integer; Count: Integer): Integer; static;
    class function UnpackAsciiShort(Buf: TBytes; Offset: Integer): SmallInt; static;
    class function UnpackAsciiInt(Buf: TBytes; Offset: Integer): Integer; static;
    class function UnpackAsciiLong(Buf: TBytes; Offset: Integer): Int64; static;
    class function GetBlobHeaderLength(Buffer: TBytes; Off: Integer): Integer; static;
    class function GetBlobLength(Buffer: TBytes; Off: Integer): Integer; static;
    class function PackBigDecimal(Buf: TBytes; Offset: Integer; Bytes: TBytes; Scale: Integer; Signum: Integer; MaxWidth: Integer; Precision: Integer; Compact: Boolean): Integer; static;
    class function UnpackBigDecimal(Buf: TBytes; Offset: Integer; Dest: TBytes; ReturnLength: TDBXInt32s): TBytes; static;
  protected
    class procedure ComplementIntValue(Buf: TBytes); static;
  end;

implementation
uses
  DBXFieldHeader,
  DBXPlatformUtil;

class function TDBXFieldPacker.UnpackInt(Buf: TBytes; Offset: Integer): Integer;
var
  IVal: Integer;
begin
  IVal := Buf[Offset] shl 24;
  IVal := IVal or (Buf[Incr(Offset)] and 255) shl 16;
  IVal := IVal or (Buf[Incr(Offset)] and 255) shl 8;
  IVal := IVal or (Buf[Incr(Offset)] and 255);
  Result := IVal;
end;

class procedure TDBXFieldPacker.PackInt(Buf: TBytes; Offset: Integer; IVal: Integer);
begin
  ;
  Buf[Offset] := Byte((IVal shr 24));
  Buf[Incr(Offset)] := Byte((IVal shr 16));
  Buf[Incr(Offset)] := Byte((IVal shr 8));
  Buf[Incr(Offset)] := Byte((IVal));
end;

class function TDBXFieldPacker.RepackRealForIndex(SourceBuf: TBytes; SourceOff: Integer; DestBuf: TBytes; DestOff: Integer; &Type: Integer): Integer;
var
  Header: Integer;
  Len: Integer;
  I: Integer;
begin
  Header := Integer(SourceBuf[SourceOff]);
  Len := Header and TDBXFieldHeader.FTinyHeaderLengthMask;
  ;
  if (Header and TDBXFieldHeader.FNullValue) <> 0 then
  begin
    DestBuf[DestOff] := Byte(Header);
    begin
      Result := TDBXFieldHeader.FTinyHeaderLength;
      exit;
    end;
  end;
  DestBuf[DestOff] := Byte((Header + (&Type - Len)));
  if (Header and TDBXFieldHeader.FPositive) <> 0 then
  begin
    for i := 0 to Len - 1 do
      DestBuf[Incr(DestOff)] := SourceBuf[Incr(SourceOff)];
        while I < &Type do
    begin
DestBuf[Incr(DestOff)] := Byte(0);      IncrAfter(I);
    end;
  end
  else 
  begin
    for i := 0 to Len - 1 do
      DestBuf[Incr(DestOff)] := Byte(not SourceBuf[Incr(SourceOff)]);
        while I < &Type do
    begin
DestBuf[Incr(DestOff)] := 255;      IncrAfter(I);
    end;
  end;
  Result := TDBXFieldHeader.FTinyHeaderLength + &Type;
end;

class function TDBXFieldPacker.UnpackDoubleAsInt64(Buf: TBytes; Offset: Integer): Int64;
var
  Header: Integer;
  Len: Integer;
  LValue: Int64;
  I: Integer;
begin
  Header := Integer(Buf[Offset]);
  Len := Header and TDBXFieldHeader.FTinyHeaderLengthMask;
  LValue := 0;
  for i := 0 to Len - 1 do
  begin
    LValue := LValue shl 8;
    LValue := LValue or (Buf[Incr(Offset)] and 255);
  end;
    while I < 8 do
  begin
LValue := LValue shl 8;    IncrAfter(I);
  end;
  if ((Header and TDBXFieldHeader.FPositive) = 0) and (LValue >= 0) then
    LValue := not LValue;
  Result := LValue;
end;

class function TDBXFieldPacker.UnpackDouble(Buf: TBytes; Offset: Integer): Double;
begin
  Result := TDBXPlatform.Int64BitsToDouble(UnpackDoubleAsInt64(Buf, Offset));
end;

class function TDBXFieldPacker.PackDouble(Buf: TBytes; Offset: Integer; DValue: Double; ForIndex: Boolean): Integer;
var
  LValue: Int64;
  LInt: Integer;
  RInt: Integer;
  StartOffset: Integer;
begin
  LValue := TDBXPlatform.DoubleToInt64Bits(DValue);
  LInt := Integer((LValue shr 32));
  RInt := Integer((LValue));
  StartOffset := Offset;
  if LInt < 0 then
    Buf[Offset] := TDBXFieldHeader.FTinyField
  else 
    Buf[Offset] := Byte((TDBXFieldHeader.FTinyField or TDBXFieldHeader.FPositive));
  if RInt = 0 then
  begin
    ;
    while LInt <> 0 do
    begin
      Buf[Incr(Offset)] := Byte((LInt shr 24));
      LInt := LInt shl 8;
    end;
  end
  else 
  begin
    Buf[Incr(Offset)] := Byte((LInt shr 24));
    Buf[Incr(Offset)] := Byte((LInt shr 16));
    Buf[Incr(Offset)] := Byte((LInt shr 8));
    Buf[Incr(Offset)] := Byte(LInt);
    while RInt <> 0 do
    begin
      Buf[Incr(Offset)] := Byte((RInt shr 24));
      RInt := RInt shl 8;
    end;
  end;
  Buf[StartOffset] := Buf[StartOffset] or Byte((Offset - StartOffset));
  if ForIndex then
    Result := RepackRealForIndex(Buf, StartOffset, Buf, StartOffset, 8)
  else 
    Result := Offset - StartOffset + TDBXFieldHeader.FTinyHeaderLength;
end;

class function TDBXFieldPacker.UnpackFloat(Buf: TBytes; Offset: Integer): Single;
var
  Header: Integer;
  Len: Integer;
  IValue: Integer;
  I: Integer;
begin
  Header := Integer(Buf[Offset]);
  Len := Header and TDBXFieldHeader.FTinyHeaderLengthMask;
  IValue := 0;
  for i := 0 to Len - 1 do
  begin
    IValue := IValue shl 8;
    IValue := IValue or (Buf[Incr(Offset)] and 255);
  end;
    while I < 4 do
  begin
IValue := IValue shl 8;    IncrAfter(I);
  end;
  if ((Header and TDBXFieldHeader.FPositive) = 0) and (IValue >= 0) then
    IValue := not IValue;
  Result := TDBXPlatform.Int32BitsToSingle(IValue);
end;

class function TDBXFieldPacker.PackFloat(Buf: TBytes; Offset: Integer; FValue: Single; ForIndex: Boolean): Integer;
var
  IValue: Integer;
  StartOffset: Integer;
begin
  IValue := TDBXPlatform.SingleToInt32Bits(FValue);
  if IValue < 0 then
    Buf[Offset] := TDBXFieldHeader.FTinyField
  else 
    Buf[Offset] := Byte((TDBXFieldHeader.FTinyField or TDBXFieldHeader.FPositive));
  StartOffset := Offset;
  while IValue <> 0 do
  begin
    Buf[Incr(Offset)] := Byte((IValue shr 24));
    IValue := IValue shl 8;
  end;
  Buf[StartOffset] := Buf[StartOffset] or Byte((Offset - StartOffset));
  if ForIndex then
    Result := RepackRealForIndex(Buf, StartOffset, Buf, StartOffset, 4)
  else 
    Result := Offset - StartOffset + TDBXFieldHeader.FTinyHeaderLength;
end;

class function TDBXFieldPacker.PackAsciiShort(Buf: TBytes; Offset: Integer; SVal: Integer; Compact: Boolean): Integer;
var
  StartOffset: Integer;
  Digit: Byte;
begin
  StartOffset := Offset;
  if SVal < 0 then
  begin
    Buf[Offset] := TDBXFieldHeader.FTinyField;
    if Compact then
      SVal := -SVal;
  end
  else 
    Buf[Offset] := Byte((TDBXFieldHeader.FPositive or TDBXFieldHeader.FTinyField));
  if SVal <> 0 then
  begin
    Digit := Byte((SVal shr 8));
    if Digit <> 0 then
      Buf[Incr(Offset)] := Digit;
    Buf[Incr(Offset)] := Byte(SVal);
    Buf[StartOffset] := Buf[StartOffset] or Byte((Offset - StartOffset));
  end;
  Result := Offset - StartOffset + TDBXFieldHeader.FTinyHeaderLength;
end;

class function TDBXFieldPacker.PackAsciiInt(Buf: TBytes; Offset: Integer; IVal: Integer; Compact: Boolean): Integer;
var
  StartOffset: Integer;
  Digit: Byte;
begin
  StartOffset := Offset;
  if IVal < 0 then
  begin
    Buf[Offset] := TDBXFieldHeader.FTinyField;
    if Compact then
      IVal := -IVal;
  end
  else 
    Buf[Offset] := Byte((TDBXFieldHeader.FPositive or TDBXFieldHeader.FTinyField));
  if IVal <> 0 then
  begin
    Digit := Byte((IVal shr 24));
    if Digit <> 0 then
      Buf[Incr(Offset)] := Digit;
    Digit := Byte((IVal shr 16));
    if (Digit <> 0) or (Offset > StartOffset) then
      Buf[Incr(Offset)] := Digit;
    Digit := Byte((IVal shr 8));
    if (Digit <> 0) or (Offset > StartOffset) then
      Buf[Incr(Offset)] := Digit;
    Buf[Incr(Offset)] := Byte(IVal);
    Buf[StartOffset] := Buf[StartOffset] or Byte((Offset - StartOffset));
  end;
//Diagnostic.println("Packing "+iVal);
//if (Diag.CHECK) BlockLog.dump("packAsciiInt ", buf, startOffset, asciiNumberLength(buf[startOffset]));
  Result := Offset - StartOffset + TDBXFieldHeader.FTinyHeaderLength;
end;

class function TDBXFieldPacker.PackAsciiLong(Buf: TBytes; Offset: Integer; LVal: Int64; Compact: Boolean): Integer;
var
  StartOffset: Integer;
  Digit: Integer;
  IVal: Integer;
begin
  StartOffset := Offset;
  if LVal < 0 then
  begin
    Buf[Offset] := TDBXFieldHeader.FTinyField;
    if Compact then
      LVal := -LVal;
  end
  else 
    Buf[Offset] := Byte((TDBXFieldHeader.FPositive or TDBXFieldHeader.FTinyField));
  if LVal <> 0 then
  begin
    IVal := Integer((LVal shr 32));
    if IVal <> 0 then
    begin
      Digit := (IVal shr 24);
      if Digit <> 0 then
        Buf[Incr(Offset)] := Byte(Digit);
      Digit := (IVal shr 16);
      if (Digit <> 0) or (Offset > StartOffset) then
        Buf[Incr(Offset)] := Byte(Digit);
      Digit := (IVal shr 8) and 255;
      if (Digit <> 0) or (Offset > StartOffset) then
        Buf[Incr(Offset)] := Byte(Digit);
      Buf[Incr(Offset)] := Byte(IVal);
    end;
    IVal := Integer((LVal and 4294967295));
    Digit := (IVal shr 24);
    if (Digit <> 0) or (Offset > StartOffset) then
      Buf[Incr(Offset)] := Byte(Digit);
    Digit := (IVal shr 16);
    if (Digit <> 0) or (Offset > StartOffset) then
      Buf[Incr(Offset)] := Byte(Digit);
    Digit := (IVal shr 8);
    if (Digit <> 0) or (Offset > StartOffset) then
      Buf[Incr(Offset)] := Byte(Digit);
    Buf[Incr(Offset)] := Byte(IVal);
    Buf[StartOffset] := Buf[StartOffset] or Byte((Offset - StartOffset));
  end;
//Diagnostic.println("Packing "+iVal);
//if (Diag.CHECK) BlockLog.dump("packAsciiLong ", buf, startOffset, asciiNumberLength(buf[startOffset]));
  Result := Offset - StartOffset + TDBXFieldHeader.FTinyHeaderLength;
end;

class function TDBXFieldPacker.PackStringHeader(Buffer: TBytes; Off: Integer; Count: Integer): Integer;
begin
  if TDBXFieldHeader.FTinyHeaderLengthMask >= Count then
    Buffer[IncrAfter(Off)] := Byte((TDBXFieldHeader.FTinyField + Count))
  else 
  begin
    Buffer[IncrAfter(Off)] := TDBXFieldHeader.FBigField;
    Buffer[IncrAfter(Off)] := Byte(((Count shr 8) and 255));
    Buffer[IncrAfter(Off)] := Byte(((Count) and 255));
  end;
  Result := Off;
end;

class function TDBXFieldPacker.UnpackAsciiShort(Buf: TBytes; Offset: Integer): SmallInt;
var
  Flags: Byte;
  ShortValue: SmallInt;
  IDigit: Integer;
begin
  Flags := Buf[Offset];
  ShortValue := SmallInt(0);
//if (Diag.CHECK) BlockLog.dump("unpackAsciiInt ", buf, offset, 16);
//Diagnostic.println("Mask "+flags);
  for iDigit := Flags and TDBXFieldHeader.FTinyHeaderLengthMask downto 1 do
  begin
    ShortValue := ShortValue shl 8;
    ShortValue := ShortValue or (Buf[Incr(Offset)] and 255);
  end;
  if ((Flags and TDBXFieldHeader.FPositive) = 0) and (ShortValue > 0) then
    ShortValue := SmallInt(-ShortValue);
  Result := ShortValue;
end;

class function TDBXFieldPacker.UnpackAsciiInt(Buf: TBytes; Offset: Integer): Integer;
var
  Flags: Byte;
  IntValue: Integer;
  IDigit: Integer;
begin
  Flags := Buf[Offset];
  IntValue := 0;
//if (Diag.CHECK) BlockLog.dump("unpackAsciiInt ", buf, offset, 16);
//Diagnostic.println("Mask "+flags);
  for iDigit := Flags and TDBXFieldHeader.FTinyHeaderLengthMask downto 1 do
  begin
    IntValue := IntValue shl 8;
    IntValue := IntValue or (Buf[Incr(Offset)] and 255);
  end;
  if ((Flags and TDBXFieldHeader.FPositive) = 0) and (IntValue > 0) then
    IntValue := -IntValue;
  Result := IntValue;
end;

class function TDBXFieldPacker.UnpackAsciiLong(Buf: TBytes; Offset: Integer): Int64;
var
  Flags: Byte;
  LongValue: Int64;
  IDigit: Integer;
begin
  Flags := Buf[Offset];
  LongValue := 0;
//if (Diag.CHECK) BlockLog.dump("unpackAsciiLong ", buf, offset, 16);
//Diagnostic.println("Mask "+flags);
  for iDigit := Flags and TDBXFieldHeader.FTinyHeaderLengthMask downto 1 do
  begin
    LongValue := LongValue shl 8;
    LongValue := LongValue or (Buf[Incr(Offset)] and 255);
  end;
  if ((Flags and TDBXFieldHeader.FPositive) = 0) and (LongValue > 0) then
    LongValue := -LongValue;
  Result := LongValue;
end;

class function TDBXFieldPacker.GetBlobHeaderLength(Buffer: TBytes; Off: Integer): Integer;
begin
  if Buffer[Off] = TDBXFieldHeader.FBlobHeader then
  begin
    Result := 5;
    exit;
  end;
//    Diagnostic.check(buffer[off] == FieldHeader.BlobRefHeader?null:""+BlockLog.dump("not a blob header off:  "+off,buffer, 0, buffer.length));
  Result := TDBXFieldHeader.FSmallBlobHeaderLength + TDBXFieldHeader.FTinyHeaderLength + (Buffer[Off + TDBXFieldHeader.FSmallBlobHeaderLength] and TDBXFieldHeader.FTinyHeaderLengthMask);
end;

class function TDBXFieldPacker.GetBlobLength(Buffer: TBytes; Off: Integer): Integer;
begin
  ;
  Result := ((Buffer[Off + 1]) shl 24) or ((Buffer[Off + 2] and 255) shl 16) or ((Buffer[Off + 3] and 255) shl 8) or ((Buffer[Off + 4] and 255));
end;

class procedure TDBXFieldPacker.ComplementIntValue(Buf: TBytes);
var
  Carry: Boolean;
  I: Integer;
begin
  Carry := True;
  for i := Length(Buf) - 1 downto 0 do
  begin
    Buf[I] := Byte((not Buf[I]));
    if Carry then
    begin
      Buf[I] := Buf[I] + 1;
      Carry := (Buf[I] = 0);
    end;
  end;
end;

class function TDBXFieldPacker.PackBigDecimal(Buf: TBytes; Offset: Integer; Bytes: TBytes; Scale: Integer; Signum: Integer; MaxWidth: Integer; Precision: Integer; Compact: Boolean): Integer;
var
  StartOffset: Integer;
  Len: Integer;
  Nzeroes: Integer;
  Size: Integer;
  Sign_header: Integer;
  I: Integer;
  J: Integer;
  K: Integer;
begin
  MaxWidth := MaxWidth - 2;
  StartOffset := Offset;
  Len := Length(Bytes);
  if (Len > 0) and (Bytes[0] = 0) then
    Nzeroes := 1
  else 
    Nzeroes := 0;
  Size := Len - Nzeroes;
  if not Compact and (Signum <> 0) then
  begin
    Size := MaxWidth;
    Scale := Scale + 128;
    if Signum < 0 then
      ComplementIntValue(Bytes);
  end;
  if Signum >= 0 then
    Sign_header := Integer(TDBXFieldHeader.FPositive)
  else 
    Sign_header := 0;
  if Len - Nzeroes > MaxWidth then
  begin
    Result := -1;
    exit;
  end;
  Buf[IncrAfter(Offset)] := Byte((TDBXFieldHeader.FTinyField + Sign_header + 1 + Size));
  Buf[IncrAfter(Offset)] := Byte((Scale));
  if not Compact then
  begin
    if Signum < 0 then
      for i := Len - Nzeroes to MaxWidth - 1 do
        Buf[IncrAfter(Offset)] := 255
    else if Signum > 0 then
      for j := Len - Nzeroes to MaxWidth - 1 do
        Buf[IncrAfter(Offset)] := Byte(0);
  end;
  for k := Nzeroes to Len - 1 do
    Buf[IncrAfter(Offset)] := Bytes[K];
  Result := Offset - StartOffset;
end;

class function TDBXFieldPacker.UnpackBigDecimal(Buf: TBytes; Offset: Integer; Dest: TBytes; ReturnLength: TDBXInt32s): TBytes;
var
  Header: Integer;
  Len: Integer;
  Scale: Integer;
  Compact: Boolean;
  Signum: Integer;
  Limiter: Byte;
begin
  Header := Integer(Buf[IncrAfter(Offset)]);
  Len := (Header and TDBXFieldHeader.FTinyHeaderLengthMask) - 1;
  Scale := Integer(Buf[IncrAfter(Offset)]);
  Compact := ((Scale and 128) = 0);
  if (Header and TDBXFieldHeader.FPositive) = 0 then
    Signum := -1
  else if Len > 0 then
    Signum := 1
  else 
    Signum := 0;
  if not Compact then
  begin
    if Signum < 0 then
      Limiter := 255
    else 
      Limiter := Byte(0);
    while (Len > 1) and (Buf[Offset] = Limiter) do
    begin
      Incr(Offset);
      Decr(Len);
    end;
  end;
  ;
  if Dest = nil then
    SetLength(Dest,Len)
  else 
    ReturnLength[0] := Len;
  TDBXPlatform.CopyByteArray(Buf, Offset, Dest, 0, Len);
  if not Compact and (Signum < 0) then
    ComplementIntValue(Dest);
  Result := Dest;
end;

end.
