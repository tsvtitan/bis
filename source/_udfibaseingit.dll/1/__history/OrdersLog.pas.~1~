unit OrdersLog;

interface

uses Classes;

type
  TOrdersLogType=(ltInformation,ltWarning,ltError);
  TOrdersLogOutput=set of (loScreen,loFile);
  
type

  TOrdersLog=class(TComponent)
  private
    FFileStream: TFileStream;
    FIsInit: Boolean;
    FClearOnInit: Boolean;
    FFileName: string;
    FActive: Boolean;
  protected
    function GetIsInit: Boolean;
    function GetClearOnInit: Boolean;
    procedure SetClearOnInit(Value: Boolean);
    function GetFileName: String;

    property IsInit: Boolean read GetIsInit;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    procedure Init(const FileName: String); virtual;
    procedure Done; virtual; 
    function Write(const Message: String; LogType: TOrdersLogType; LogOutput: TOrdersLogOutput): Boolean;
    function WriteInfo(const Message: String; LogOutput: TOrdersLogOutput=[loScreen,loFile]): Boolean;
    function WriteError(const Message: String; LogOutput: TOrdersLogOutput=[loScreen,loFile]): Boolean;
    function WriteWarn(const Message: String; LogOutput: TOrdersLogOutput=[loScreen,loFile]): Boolean;
    function WriteToFile(const Message: String; LogType: TOrdersLogType): Boolean;
    function WriteToScreen(const Message: String; LogType: TOrdersLogType): Boolean;
    function WriteToBoth(const Message: String; LogType: TOrdersLogType): Boolean;

    procedure Clear; 

    property Active: Boolean read FActive write FActive; 
  end;

implementation

uses SysUtils;

{ TOrdersLog }

constructor TOrdersLog.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FFileStream:=nil;
  FActive:=true;
end;

destructor TOrdersLog.Destroy;
begin
  Done;
  inherited Destroy;
end;

procedure TOrdersLog.Init(const FileName: String); 
begin
  if not FIsInit and not Assigned(FFileStream) then begin
    FFileName:=FileName;
    try
      if not FileExists(FileName) or FClearOnInit then begin
        FFileStream:=TFileStream.Create(FileName,fmCreate);
        FreeAndNil(FFileStream);
      end;

      FFileStream:=TFileStream.Create(FileName,fmOpenWrite or fmShareDenyNone);
      FFileStream.Position:=FFileStream.Size;
      FIsInit:=true;
    except
    end;  
  end;
end;

procedure TOrdersLog.Done; 
begin
  if Assigned(FFileStream) then begin
    FreeAndNil(FFileStream);
    FIsInit:=false;
  end;  
end;

function TOrdersLog.Write(const Message: String; LogType: TOrdersLogType; LogOutput: TOrdersLogOutput): Boolean; 
var
  Buffer: String;
  S: string;
const
  SUnknown='Неизвестно';
  SInformation='Информация';
  SWarning='Предупреждение';
  SError='Ошибка';
  SFormatMessage='%s [%s]: %s';
  SFormatDateTime='dd.mm.yy hh:nn:ss.zzz';
  SReturn=#13#10;
begin
  Result:=false;
  S:=SUnknown;
  case LogType of
    ltInformation: S:=SInformation;
    ltWarning: S:=SWarning;
    ltError: S:=SError;
  end;
  Buffer:=Format(SFormatMessage,[FormatDateTime(SFormatDateTime,Now),S,Message]);
  if loScreen in LogOutput then ;
  if loFile in LogOutput then
    if Assigned(FFileStream) then begin
      Buffer:=Buffer+SReturn;
      FFileStream.Write(Pointer(Buffer)^,Length(Buffer));
    end;
end;

function TOrdersLog.WriteInfo(const Message: String; LogOutput: TOrdersLogOutput=[loScreen,loFile]): Boolean;
begin
  Result:=Write(Message,ltInformation,LogOutput);
end;

function TOrdersLog.WriteError(const Message: String; LogOutput: TOrdersLogOutput=[loScreen,loFile]): Boolean;
begin
  Result:=Write(Message,ltError,LogOutput);
end;

function TOrdersLog.WriteWarn(const Message: String; LogOutput: TOrdersLogOutput=[loScreen,loFile]): Boolean;
begin
  Result:=Write(Message,ltWarning,LogOutput);
end;

function TOrdersLog.WriteToFile(const Message: String; LogType: TOrdersLogType): Boolean; 
begin
  Result:=Write(Message,LogType,[loFile]);
end;

function TOrdersLog.WriteToScreen(const Message: String; LogType: TOrdersLogType): Boolean; 
begin
  Result:=Write(Message,LogType,[loScreen]);
end;

function TOrdersLog.WriteToBoth(const Message: String; LogType: TOrdersLogType): Boolean; 
begin
  Result:=Write(Message,LogType,[loScreen,loFile]);
end;

function TOrdersLog.GetIsInit: Boolean; 
begin
  Result:=FIsInit;
end;

function TOrdersLog.GetClearOnInit: Boolean; 
begin
  Result:=FClearOnInit;
end;

procedure TOrdersLog.SetClearOnInit(Value: Boolean); 
begin
  FClearOnInit:=Value;
end;

procedure TOrdersLog.Clear; 
var
  Old: Boolean;
begin
  FActive:=true;
  Old:=FClearOnInit;
  try
    Done;
    FClearOnInit:=true;
    Init(FFileName);
  finally
    FClearOnInit:=Old;
    FActive:=true;
  end;
end;

function TOrdersLog.GetFileName: String; 
begin
  Result:=FFileName;
end;

end.
